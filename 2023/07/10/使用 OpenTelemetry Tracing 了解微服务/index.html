<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>使用 OpenTelemetry Tracing 了解您的微服务 | 流水易寒の博客</title><meta name="author" content="姬岚忧"><meta name="copyright" content="姬岚忧"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="微服务架构具有诸多优势，包括增强团队自主性、提高扩展与部署灵活性。但缺点是，系统中的服务越多（一个微服务应用可能包含几十个甚至几百个服务），清晰地了解系统总体运行情况的难度就越大。作为复杂软件系统的编写者和维护者，我们深知掌握系统运行情况的重要性。可观测性工具可帮助我们清晰地了解众多服务和支持基础设"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202212290947085.png"><link rel="canonical" href="https://blog.kkun.site/2023/07/10/%E4%BD%BF%E7%94%A8%20OpenTelemetry%20Tracing%20%E4%BA%86%E8%A7%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="zEdV2SVm14BBjmysMbimJptVuSESoCKhQvg2KGyh3tM"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-5936787105308700',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-RRJTLY81FN"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-RRJTLY81FN');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '使用 OpenTelemetry Tracing 了解您的微服务',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-28 09:55:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">39</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://github.com/Ghostpanter"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202301051001001.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">流水易寒の博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://github.com/Ghostpanter"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">使用 OpenTelemetry Tracing 了解您的微服务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-10T00:52:55.000Z" title="发表于 2023-07-10 08:52:55">2023-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-28T01:55:40.401Z" title="更新于 2023-08-28 09:55:40">2023-08-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/kubernetes/">kubernetes</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/kubernetes/ingress/">ingress</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/kubernetes/ingress/opentracing/">opentracing</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="使用 OpenTelemetry Tracing 了解您的微服务"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>微服务架构具有诸多优势，包括增强团队自主性、提高扩展与部署灵活性。但缺点是，系统中的服务越多（一个微服务应用可能包含几十个甚至几百个服务），清晰地了解系统总体运行情况的难度就越大。作为复杂软件系统的编写者和维护者，我们深知掌握系统运行情况的重要性。可观测性工具可帮助我们清晰地了解众多服务和支持基础设施。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307071701943.jpeg" alt="图片"></p>
<p>在本教程中，我们将重点介绍微服务应用的一种非常重要的可观测性工具：链路追踪（tracing）。在步入正题之前，让我们先定义一下讨论可观测性时通常会用到的一些术语：</p>
<ul>
<li><p>可观测性—仅基于对复杂系统（如微服务应用）的外部输出（如链路追踪、日志和指标）的了解就能获悉其内部状态或状况的能力。</p>
</li>
<li><p>监控—观测并检查对象在一段时间内的进度或状态的能力。例如，您可以监控在高峰时段传入应用的流量，并使用这些信息对应用进行相应的扩展。</p>
</li>
<li><p>遥测—收集指标、链路追踪和日志，并将它们从源点转移到另一个系统进行存储和分析的行为。有时，遥测还指数据本身。</p>
</li>
<li><p>链路追踪—记录请求或操作通过分布式系统所有节点的过程。</p>
</li>
<li><p>Span—一项操作链路追踪中的记录及其相关元数据。链路追踪由许多嵌套的 span 组成。</p>
</li>
<li><p>事件记录&#x2F;日志—带时间戳的文本记录，包含元数据。</p>
</li>
<li><p>指标—在运行时捕获的度量值。例如，一个应用在某一时间点占用的内存量。</p>
</li>
</ul>
<p>我们可借助所有这些概念来了解微服务的性能。链路追踪是可观测性策略中特别有用的部分，因为链路追踪提供了发出请求时多个通常松散耦合的组件之间的“全局视图”。这也是识别性能瓶颈的一种尤为高效的方法。</p>
<p>本教程使用了来自 OpenTelemetry (OTel) 的链路追踪工具套件，OTel 是一套用于收集、处理并导出遥测数据的厂商中立的开源标准，正快速被广泛采用。在 OTel 的概念中，链路追踪将一个可能包括多个服务的数据流分成了一系列按时间顺序排列的数据块，以便于您理解：</p>
<ul>
<li><p>在数据块中执行的所有步骤</p>
</li>
<li><p>执行所有这些步骤花费的时间</p>
</li>
<li><p>关于每个步骤的元数据</p>
</li>
</ul>
<h2 id="教程概述"><a href="#教程概述" class="headerlink" title="教程概述"></a>教程概述</h2><p>本教程主要介绍了如何利用 OTel 来跟踪微服务应用的操作。在本教程的四个挑战中，您将学习如何跟踪通过系统的请求并解决有关自身微服务的问题：</p>
<ul>
<li>设置基本 OTel 埋点（instrumentation）</li>
<li>为所有服务设置 OTel 埋点和链路追踪可视化</li>
<li>学习解读 OTel 链路追踪</li>
<li>根据链路追踪解读优化埋点<br>以下挑战介绍了在首次设置链路追踪时我们推荐使用的流程。具体步骤：</li>
</ul>
<p>了解系统以及您正在监测的特定操作。<br>确定您需要从运行系统中获取的信息。<br>对系统进行原生监测（这意味着使用默认配置，不要试图删除您不需要的信息或收集自定义数据点），并评估监测是否有助于您解决问题。<br>调整报告的信息，以便更快地解决这些问题。</p>
<blockquote>
<p>注：我们旨在通过本教程阐释一些有关遥测的核心概念，而非展示如何在生产环境中正确部署微服务。虽然我们会用到真正的“微服务”架构，但需要做以下几点说明：</p>
</blockquote>
<p>本教程没有使用 Kubernetes 或 Nomad 等容器编排框架。这可确保您在学习微服务概念时不会被某个框架的具体细节所困扰。本文介绍的模式可移植到运行这些框架的系统中。<br>服务为方便理解（而非软件工程的严谨性）做了优化，请重点关注服务在系统中的作用及其通信模式，而非代码细节。如欲了解更多信息，请查看各个服务的 README 文件。</p>
<h2 id="教程架构和遥测目标"><a href="#教程架构和遥测目标" class="headerlink" title="教程架构和遥测目标"></a>教程架构和遥测目标</h2><p>架构和用户流<br>下图显示了本教程中所用的微服务及其他元素之间的整体架构和数据流。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307071704817.png" alt="图片"></p>
<p>两种微服务如下：</p>
<ul>
<li><p>信使（messenger）服务(<a target="_blank" rel="noopener" href="https://github.com/microservices-march/messenger">https://github.com/microservices-march/messenger</a>) - 一个简单的聊天 API，具有消息存储功能</p>
</li>
<li><p>通知器（notifier）服务(<a target="_blank" rel="noopener" href="https://github.com/microservices-march/notifier">https://github.com/microservices-march/notifier</a>) - 一个根据用户偏好触发事件以提醒用户的监听器<br>三种支持基础架构包括：</p>
</li>
<li><p>NGINX 开源版 - 通往信使服务和整个系统的入口点</p>
</li>
<li><p>RabbitMQ - 一个常用的开源消息代理，支持服务异步通信</p>
</li>
<li><p>Jaeger - 一个开源的端到端分布式链路追踪系统，用于从相关系统组件中收集遥测数据并实现可视化查看。<br>现在暂时把 OTel 搁置脑后，重点介绍下我们正在跟踪的事件序列，即当用户发送新的聊天消息并且接收者收到相关通知时会发生什么。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307071705312.png" alt="图片"></p>
</li>
</ul>
<p>流程分解如下：</p>
<ol>
<li><p>用户向信使服务发送消息。NGINX 反向代理拦截消息，并将其转发给信使并将其转发给信使服务的众多实例之一。</p>
</li>
<li><p>信使服务将新消息写入其数据库。</p>
</li>
<li><p>信使服务在名为 chat_queue 的 RabbitMQ 消息队列上生成一个事件，以表明消息已发送。该事件为普通事件，无具体目标。</p>
</li>
<li><p>与此同时：</p>
</li>
</ol>
<ul>
<li>4a. 信使信使服务向发送者返回一个响应，报告该消息已成功发送。</li>
<li>4b. 通知器服务注意到 chat_queue 上的新事件，并使用该事件。</li>
</ul>
<ol start="5">
<li><p>通知器服务在其数据库中查看新消息接收者的通知偏好。</p>
</li>
<li><p>通知器服务使用接收者首选的方法发送一个或多个通知(在本教程中，选择的方法是短信和电子邮件)。</p>
</li>
</ol>
<h3 id="遥测目标"><a href="#遥测目标" class="headerlink" title="遥测目标"></a>遥测目标</h3><p>在设置遥测工具时，最好先确定一组明确的监测目标，而不是“发送所有内容，希望获得洞察”。在本教程中，我们有三个主要的遥测目标：</p>
<ol>
<li>了解一个请求在新消息流期间所经历的所有步骤。</li>
<li>确信在正常情况下消息流可在五秒钟内端到端执行完毕。</li>
<li>查看通知器服务在多长时间之后才开始处理信使服务派发的事件（延迟过长可能意味着通知器服务在读取事件队列时遇到了问题，出现事件堆积）。<br>请注意，这些目标与系统的技术操作和用户体验有关。</li>
</ol>
<p>教程准备工作和设置</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>若在自己的环境中完成本教程的学习，您需要：</p>
<ul>
<li>一个兼容 Linux&#x2F;Unix 的环境</li>
</ul>
<p>注：由于 NGINX 的 OpenTelemetry 模块不兼容（包括 Linux aarch64 架构和搭载 M1 或 M2 芯片的苹果设备），本教程中涉及跟踪 NGINX 的活动不能在基于 ARM 的处理器上工作。涉及信使和通知器服务的活动适用于所有架构。</p>
<ul>
<li><p>基本了解 Linux 命令行、JavaScript 和 bashbash （本教程会提供并解释所有代码和命令，因此即使您知识有限也无妨）</p>
</li>
<li><p>Docker 和 Docker Compose</p>
</li>
<li><p>Node.js 19.x 或更高版本</p>
<ul>
<li>我们只测试了版本 19.x，但预计更新版本的 Node.js 也适用。</li>
<li>如欲了解有关 Node,js 安装的详细信息，请查看信使服务代码库中的 README 文件。您也可以通过安装 asdf，获取与教程中所用完全相同的 Node.js 版本。</li>
</ul>
</li>
<li><p>curl（已安装在大多数系统上）</p>
</li>
<li><p>架构和用户流部分提到了以下技术：信使和通知器（将在下一部分中下载）、NGINX 开源版、Jaeger 和 RabbitMQ。</p>
</li>
</ul>
<p>注：本教程用到了 JavaScript SDK，因为信使和通知器服务均使用 Node.js 编写而成。您还需要设置 OTel 自动埋点特性，以便了解 OTel 提供的信息类型。本教程介绍了有关 OTel Node.js SDK 的常用信息，如欲了解更多详情，请参阅 [OTel 文档]：<a target="_blank" rel="noopener" href="https://opentelemetry.io/docs/instrumentation/js/getting-started/nodejs/">https://opentelemetry.io/docs/instrumentation/js/getting-started/nodejs/</a>。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ol>
<li><p>开启终端会话。</p>
</li>
<li><p>在主目录下，创建 microservices-march 目录，并将本教程会用到的 GitHub 代码库复制到其中。（您也可以使用其他目录名称，相应修改指令即可）。</p>
</li>
</ol>
<blockquote>
<p> 注：本教程中省略了 Linux 命令行提示符，以便您将命令复制和粘贴到终端。波浪符 (<strong>~</strong>) 表示您的主目录。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/microservices-march</span><br><span class="line"><span class="built_in">cd</span> ~/microservices-march</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/microservices-march/messenger --branch mm23-metrics-start</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/microservices-march/notifier --branch mm23-metrics-start</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/microservices-march/platform --branch mm23-metrics-start</span><br></pre></td></tr></table></figure>

<h2 id="挑战-1：设置基本-OTel-埋点"><a href="#挑战-1：设置基本-OTel-埋点" class="headerlink" title="挑战 1：设置基本 OTel 埋点"></a>挑战 1：设置基本 OTel 埋点</h2><p>在这个挑战中，启动信使服务并配置 OTel 自动埋点以将遥测数据发送至控制台。</p>
<h3 id="启动信使服务"><a href="#启动信使服务" class="headerlink" title="启动信使服务"></a>启动信使服务</h3><ol>
<li>切换到平台 platform 代码库并启动 Docker Compose：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/microservices-march/platform</span><br><span class="line">docker compose up -d --build</span><br></pre></td></tr></table></figure>

<p>这将同时启动 RabbitMQ 和 Jaeger——两者将在后面的挑战中用到。</p>
<ul>
<li>‑d 标记指示 Docker Compose 在容器启动时与之分离（否则容器将始终与您的终端保持连接）。</li>
<li>–build 标记指示 Docker Compose 在启动时重建所有镜像。这可确保您正在运行的镜像通过任何潜在的文件变更保持更新。</li>
</ul>
<ol start="2">
<li>切换到信使 messenger 代码库的 app 目录并安装 Node.js（您也可以按需采用其他替代方法）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/microservices-march/messenger/app</span><br><span class="line">asdf install</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装依赖项：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>为信使服务启动 PostgreSQL 数据库：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>

<ol>
<li>创建数据库模式和表格，并插入一些种子数据：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run refresh-db</span><br></pre></td></tr></table></figure>

<h3 id="配置发送到控制台的-OTel-自动埋点"><a href="#配置发送到控制台的-OTel-自动埋点" class="headerlink" title="配置发送到控制台的 OTel 自动埋点"></a>配置发送到控制台的 OTel 自动埋点</h3><p>借助 OTel 自动埋点，无需修改信使代码库中的任何内容即可设置链路追踪。所有链路追踪配置并非直接编写在应用代码中，而是在脚本中定义，然后在运行时把脚本导入 Node.js 进程。</p>
<p>此处，您可以配置信使服务的自动埋点使用最基本的链路追踪目标位置，即控制台。在挑战 2 中，您需要更改配置，将链路追踪发送到作为外部收集器的 Jaeger。</p>
<ol>
<li>仍然在 messenger 代码库的 app 目录下操作，安装核心 OTel Node.js 包：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install @opentelemetry/sdk-node@0.36.0 \</span><br><span class="line">            @opentelemetry/auto-instrumentations-node@0.36.4</span><br></pre></td></tr></table></figure>

<p>下列库提供了以下功能：</p>
<ul>
<li>@opentelemetry&#x2F;sdk-node——生成并导出 OTel 数据</li>
<li>@opentelemetry&#x2F;auto-instrumentations-node——使用所有常见 Node.js 埋点的默认配置进行自动设置<blockquote>
<p>注：OTel 的不同之处在于，其 JavaScript SDK 被分解成了多个微小部分。因此，在本教程的基本示例中，您将需要多安装几个安装包。如欲了解除本教程中所列以外还需要哪些安装包才能完成监测任务，请仔细阅读（强推）OTel [入门指南]：<a target="_blank" rel="noopener" href="https://opentelemetry.io/docs/instrumentation/js/getting-started">https://opentelemetry.io/docs/instrumentation/js/getting-started</a> 并查看 OTel [GitHub 代码库]：<a target="_blank" rel="noopener" href="https://github.com/open-telemetry/opentelemetry-js#packages%E3%80%82">https://github.com/open-telemetry/opentelemetry-js#packages。</a></p>
</blockquote>
</li>
</ul>
<ol>
<li>新建一个名为 tracing.mjs 的文件，添加 OTel 链路追踪的设置和配置代码：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> tracing.mjs</span><br></pre></td></tr></table></figure>

<ol>
<li>在您常用的文本编辑器中，打开 tracing.mjs 并添加下列代码：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">import opentelemetry from <span class="string">&quot;@opentelemetry/sdk-node&quot;</span>;</span><br><span class="line">import &#123; getNodeAutoInstrumentations &#125; from <span class="string">&quot;@opentelemetry/auto-instrumentations-node&quot;</span>;</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line">const sdk = new opentelemetry.NodeSDK(&#123;</span><br><span class="line">  traceExporter: new opentelemetry.tracing.ConsoleSpanExporter(),</span><br><span class="line">  instrumentations: [getNodeAutoInstrumentations()],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//3</span><br><span class="line">sdk.start();</span><br></pre></td></tr></table></figure>

<p>这些代码会完成以下操作：</p>
<ol>
<li><p>从 OTel SDK 中导入所需的函数和对象。</p>
</li>
<li><p>新建 NodeSDK 实例并对其进行配置，以便：</p>
</li>
</ol>
<ul>
<li>面向 Postgres 数据库的 @opentelemetry&#x2F;instrumentation-pg 库 (pg)</li>
<li>面向 Node.js Express 框架的 @opentelemetry&#x2F;instrumentation-express</li>
<li>面向 RabbitMQ 的 @opentelemetry&#x2F;instrumentation-amqplib 库 (amqplib)</li>
<li>将 span 发送至控制台 (ConsoleSpanExporter)。</li>
<li>将自动埋点用作基本埋点组。该埋点加载了所有最常见的自动埋点库。本教程用到了以下库：</li>
</ul>
<ol start="3">
<li><p>启动 SDK。</p>
</li>
<li><p>启动信使服务，导入您在第三步中创建的自动埋点脚本。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --import ./tracing.mjs index.mjs</span><br></pre></td></tr></table></figure>

<p>稍后，控制台（您的终端）中开始显示大量与链路追踪相关的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">  traceId: <span class="string">&#x27;9c1801593a9d3b773e5cbd314a8ea89c&#x27;</span>,</span><br><span class="line">  parentId: undefined,</span><br><span class="line">  traceState: undefined,</span><br><span class="line">  name: <span class="string">&#x27;fs statSync&#x27;</span>,</span><br><span class="line">  <span class="built_in">id</span>: <span class="string">&#x27;2ddf082c1d609fbe&#x27;</span>,</span><br><span class="line">  kind: 0,</span><br><span class="line">  timestamp: 1676076410782000,</span><br><span class="line">  duration: 3,</span><br><span class="line">  attributes: &#123;&#125;,</span><br><span class="line">  status: &#123; code: 0 &#125;,</span><br><span class="line">  events: [],</span><br><span class="line">  links: []</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：让终端会话保持打开状态，以便在挑战 2 中使用。</p>
</blockquote>
<h2 id="挑战-2：为所有服务设置-OTel-埋点和链路追踪可视化"><a href="#挑战-2：为所有服务设置-OTel-埋点和链路追踪可视化" class="headerlink" title="挑战 2：为所有服务设置 OTel 埋点和链路追踪可视化"></a>挑战 2：为所有服务设置 OTel 埋点和链路追踪可视化</h2><p>您可以使用许多工具来查看和分析链路追踪，但本教程使用的是 Jaeger。Jaeger 是一个简单的开源端到端分布式链路追踪框架，内置一个基于 Web 的用户界面，用于查看 span 及其他链路追踪数据。平台代码库中提供的基础架构包括 Jaeger（已在挑战 1 的第一步中启动），因此您可以专注于分析数据，不用考虑工具问题。</p>
<p>您可通过在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:16686/">http://localhost:16686</a> 端点来访问 Jaeger，但如果您现在就访问该端点，不会看到与您的系统有关的任何内容。这是因为您目前收集的链路追踪正被发送到控制台！如欲在 Jaeger 中查看链路追踪数据，需使用 OpenTelemetry 协议 (OTLP) 格式导出链路追踪。</p>
<p>在这个挑战中，您需要为以下服务配置埋点以监测核心用户流：</p>
<ul>
<li>信使服务，将链路追踪目标位置从控制台切换到 Jaeger。</li>
<li>通知器服务</li>
<li>NGINX</li>
</ul>
<h3 id="配置-OTel-自动埋点发送到外部收集器"><a href="#配置-OTel-自动埋点发送到外部收集器" class="headerlink" title="配置 OTel 自动埋点发送到外部收集器"></a>配置 OTel 自动埋点发送到外部收集器</h3><p>值得一提的是，使用 OTel 自动埋点意味着您无需修改信使代码库中的任何内容即可设置链路追踪。但所有链路追踪配置都位于在运行时被导入 Node.js 进程的脚本中。此处，您可将由信使服务生成的链路追踪的目标位置从控制台更改为外部收集器（在本教程中为 Jaeger）。</p>
<ol>
<li>仍然在与挑战 1 中相同的终端下操作，在信使代码库的 app 目录下，安装 OTLP 输出器 Node.js 包：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @opentelemetry/exporter-trace-otlp-http@0.36.0</span><br></pre></td></tr></table></figure>

<p><code>@opentelemetry/exporter-trace-otlp-http</code> 库通过 HTTP 导出 OTLP 格式的链路追踪信息，用于向 OTel 外部收集器发送遥测数据。</p>
<ol start="2">
<li>打开 <code>tracing.mjs</code>（已在挑战 1 中创建和编辑），并进行以下修改：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; OTLPTraceExporter &#125; from <span class="string">&quot;@opentelemetry/exporter-trace-otlp-http&quot;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了简单起见，本教程假设收集器位于默认位置 <a target="_blank" rel="noopener" href="http://localhost:4318/v1/traces%E3%80%82%E5%9C%A8%E7%9C%9F%E5%AE%9E%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E6%9C%80%E5%A5%BD%E6%98%8E%E7%A1%AE%E8%AE%BE%E7%BD%AE%E8%AF%A5%E4%BD%8D%E7%BD%AE%E3%80%82">http://localhost:4318/v1/traces。在真实系统中，最好明确设置该位置。</a></p>
</blockquote>
<ul>
<li>将提供给 OTel SDK 的“导出器”从挑战 1 中所用的控制台导出器更改为可通过 HTTP 向兼容 OTLP 的收集器发送 OTLP 数据的导出器。将</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceExporter:new opentelemetry.tracing.ConsoleSpanExporter(),</span><br></pre></td></tr></table></figure>

<p>替换为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceExporter: new OTLPTraceExporter(&#123; headers: &#123;&#125; &#125;),</span><br></pre></td></tr></table></figure>

<ul>
<li>将下列一行添加到文件顶部的 import 语句中：</li>
</ul>
<ol start="3">
<li>按下 Ctrl+c 停止信使服务，该终端是在配置 OTel 自动埋点发送到控制台的第四步中启动的。重启该服务，以使用在第二步中配置的新导出器：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^c</span><br><span class="line">node --import ./tracing.mjs index.mjs</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开启第二个终端会话。（在后面的指令中称其为客户端终端，在第一步和第三步中使用的原始终端被称作信使终端。）等待大约十秒钟，然后向信使服务发送健康检查请求（如要查看多个链路追踪，则可多运行几次）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET http://localhost:4000/health</span><br></pre></td></tr></table></figure>

<p>在发送请求前等待 10 秒钟有助于您的跟踪更容易被找到，因为在服务启动时自动埋点会生成许多链路追踪。</p>
<ol start="5">
<li>在浏览器中，访问 Jaeger 用户界面：<a href="http://localhost:16686，并验证">http://localhost:16686，并验证</a> OTLP 导出器是否按预期运行。在标题栏中点击 Search（搜索），从 Service（服务）字段的下拉菜单中选择名称以 unknown_service 开头的服务。点击 Find Traces（查找追踪）按钮：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307071721624.png" alt="图片"></p>
<ol start="6">
<li>点击窗口右侧的链路追踪，以显示其中的 span 列表。每个 span 都描述了作为链路追踪的一部分运行的各项操作，有时涉及多个服务。截图中的 jsonParser span 显示了运行信使服务的请求处理代码的 jsonParser 部分所用的时长。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307071723413.png" alt="图片"></p>
<ol start="7">
<li>正如第五步中所述，OTel SDK 导出的服务名称 (unknown_service) 毫无意义。要想解决这个问题，在信使终端按下 Ctrl+c 来停止信使服务。 然后再安装几个 Node.js 包：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^c </span><br><span class="line">npm install @opentelemetry/semantic-conventions@1.10.0 \</span><br><span class="line">            @opentelemetry/resources@1.10.0</span><br></pre></td></tr></table></figure>

<p>下列两个库提供以下功能：</p>
<ul>
<li><code>@opentelemetry/semantic-conventions</code>——定义了 OTel 规范中所定义的链路追踪的标准属性。</li>
<li><code>@opentelemetry/resources</code>——定义一个对象（资源）以代表生成 OTel 数据的来源（在本教程中为信使服务）。</li>
</ul>
<ol start="8">
<li>在文本编辑器中打开 <code>tracing.mjs</code> 并进行以下修改：</li>
</ol>
<ul>
<li>将下列行添加到文件顶部的 <code>import</code> 语句中：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Resource &#125; from <span class="string">&quot;@opentelemetry/resources&quot;</span>;</span><br><span class="line">import &#123; SemanticResourceAttributes &#125; from <span class="string">&quot;@opentelemetry/semantic-conventions&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 OTel 规范中的正确键值下创建一个名为 messenger 的 resource，具体方法是在最后一个 import 语句后添加以下行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const resource = new Resource(&#123;</span><br><span class="line">  [SemanticResourceAttributes.SERVICE_NAME]: <span class="string">&quot;messenger&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过在以下黑色行之间添加橙色高亮显示的行，将 resource 对象传递给 NodeSDK 构造函数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sdk = new opentelemetry.NodeSDK(&#123;</span><br><span class="line">  resource,</span><br><span class="line">  traceExporter: new OTLPTraceExporter(&#123; headers: &#123;&#125; &#125;),</span><br><span class="line">  instrumentations: [getNodeAutoInstrumentations()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>重启信使服务：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --import ./tracing.mjs index.mjs</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>等待大约十秒钟，然后在客户端终端中（已在第四步中打开）向服务器发送另一健康检查请求（如欲查看多个链路追踪，则可多运行几次命令）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET http://localhost:4000/health</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：让客户端终端保持打开状态，以便在下一部分中再次使用，同时让信使终端保持打开状态，以在挑战 3 中再次使用。</p>
</blockquote>
<ol start="11">
<li><p>确认一个名为 messenger（信使）的新服务出现在浏览器的 Jaeger 用户界面中（这可能需要几秒钟的时间，而且您可能需要刷新 Jaeger 用户界面）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100810313.png" alt="图片"></p>
</li>
<li><p>从 Service 下拉菜单中选择 messenger，然后点击 Find Traces 按钮，即可查看由信使服务生成的所有最新链路追踪（截图显示了 20 条信息中的两条最新信息）：</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100811164.png" alt="图片"></p>
<ol start="13">
<li>点击一个追踪，以显示其中的 span。每个 span 都被正确地标记为源自于信使服务：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100811699.png" alt="图片"></p>
<h3 id="配置通知器服务的-OTel-自动埋点"><a href="#配置通知器服务的-OTel-自动埋点" class="headerlink" title="配置通知器服务的 OTel 自动埋点"></a>配置通知器服务的 OTel 自动埋点</h3><p>现在为通知器服务启动并配置自动埋点，运行与前两部分中信使服务基本相同的命令。</p>
<ol>
<li>开启新的终端会话（在后续步骤中被称为通知器终端）。切换到通知器代码库的 app 目录并安装 Node.js（您也可以按需采用其他替代方法）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/microservices-march/notifier/app</span><br><span class="line">asdf install</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装依赖项：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>为通知器服务启动 PostgreSQL 数据库：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建数据库模式和表格，并插入一些种子数据：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run refresh-db</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>安装 OTel Node.js 包（关于这些包功能的描述，请参阅“配置 OTel 自动埋点发送到控制台”中的第一步和第三步）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install @opentelemetry/auto-instrumentations-node@0.36.4 \</span><br><span class="line">  @opentelemetry/exporter-trace-otlp-http@0.36.0 \</span><br><span class="line">  @opentelemetry/resources@1.10.0 \</span><br><span class="line">  @opentelemetry/sdk-node@0.36.0 \</span><br><span class="line">  @opentelemetry/semantic-conventions@1.10.0</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>新建一个名为 tracing.mjs 的文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> tracing.mjs</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在您常用的文本编辑器中，打开 tracing.mjs 并添加以下脚本，以启动并运行 OTel SDK：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import opentelemetry from <span class="string">&quot;@opentelemetry/sdk-node&quot;</span>;</span><br><span class="line">import &#123; getNodeAutoInstrumentations &#125; from <span class="string">&quot;@opentelemetry/auto-instrumentations-node&quot;</span>;</span><br><span class="line">import &#123; OTLPTraceExporter &#125; from <span class="string">&quot;@opentelemetry/exporter-trace-otlp-http&quot;</span>;</span><br><span class="line">import &#123; Resource &#125; from <span class="string">&quot;@opentelemetry/resources&quot;</span>;</span><br><span class="line">import &#123; SemanticResourceAttributes &#125; from <span class="string">&quot;@opentelemetry/semantic-conventions&quot;</span>;</span><br><span class="line"></span><br><span class="line">const resource = new Resource(&#123;</span><br><span class="line">  [SemanticResourceAttributes.SERVICE_NAME]: <span class="string">&quot;notifier&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const sdk = new opentelemetry.NodeSDK(&#123;</span><br><span class="line">  resource,</span><br><span class="line">  traceExporter: new OTLPTraceExporter(&#123; headers: &#123;&#125; &#125;),</span><br><span class="line">  instrumentations: [getNodeAutoInstrumentations()],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sdk.start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：本脚本与信使（notifier）服务所用的完全相同，唯一不同之处是SemanticResourceAttributes.SERVICE_NAME 字段中的值是 notifier。</p>
</blockquote>
<ol start="8">
<li>使用 OTel 自动埋点启动通知器服务：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --import ./tracing.mjs index.mjs</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>等待大约十秒钟，然后在客户端终端向通知器服务发送健康检查请求。该服务将监听端口 5000，以防止与监听端口 4000 的信使服务发生冲突：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:5000/health</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：让客户端终端和通知器终端保持打开状态，以便在挑战 3 中再次使用。</p>
</blockquote>
<ol start="10">
<li>确认一个名为 notifier 的新服务出现在浏览器的 Jaeger 用户界面中：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100815289.png" alt="图片"></p>
<h3 id="配置-NGINX-的-OTEL-埋点"><a href="#配置-NGINX-的-OTEL-埋点" class="headerlink" title="配置 NGINX 的 OTEL 埋点"></a>配置 NGINX 的 OTEL 埋点</h3><p>对于 NGINX，您需要手动设置链路追踪，而不是使用 OTel 自动埋点方法。目前，使用 OTel 对 NGINX 进行监测的最常见方式是使用[用 C 语言编写的模块]：<code>https://github.com/open-telemetry/opentelemetry-cpp-contrib/tree/main/instrumentation/otel-webserver-module#nginx-webserver-module</code>。第三方模块是 NGINX 生态系统的一个重要组成部分，但需要进行一些设置。本教程向您展示了如何进行这些设置。有关背景信息，请参阅我们的博文《为 NGINX 和 NGINX Plus 编译第三方动态模块》。</p>
<ol>
<li>开启新的终端会话（NGINX 终端），将目录更改为信使代码库的根目录，并新建一个名为 load-balancer 的目录及三个名为 Dockerfile、nginx.conf 和</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/microservices-march/messenger/</span><br><span class="line"><span class="built_in">mkdir</span> load-balancer</span><br><span class="line"><span class="built_in">cd</span> load-balancer</span><br><span class="line"><span class="built_in">touch</span> Dockerfile</span><br><span class="line"><span class="built_in">touch</span> nginx.conf</span><br><span class="line"><span class="built_in">touch</span> opentelemetry_module.conf</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在您常用的文本编辑器中，打开 Dockerfile 并添加以下内容（注释解释了每一行代码的功能，即便您不完全理解这些注释，也能构建和运行 Docker 容器）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FROM --platform=amd64 nginx:1.23.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用我们自己的文件替换 nginx.conf 文件</span></span><br><span class="line">COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 NGINX OTel 模块的版本</span></span><br><span class="line"></span><br><span class="line">ARG OPENTELEMETRY_CPP_VERSION=1.0.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译和运行 NGINX 时所用共享库的搜索路径</span></span><br><span class="line">ENV LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/opt/opentelemetry-webserver-sdk/sdk_lib/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 下载最新版本的 Consul 模板和 OTEL C++ Web 服务器模块、otel-webserver-module</span></span><br><span class="line">ADD https://github.com/open-telemetry/opentelemetry-cpp-contrib/releases/download/webserver%2Fv<span class="variable">$&#123;OPENTELEMETRY_CPP_VERSION&#125;</span>/opentelemetry-webserver-sdk-x64-linux.tgz /tmp</span><br><span class="line"></span><br><span class="line">RUN apt-get update \</span><br><span class="line">  &amp;&amp; apt-get install -y --no-install-recommends dumb-init unzip \</span><br><span class="line"><span class="comment"># 2. 提取模块文件</span></span><br><span class="line">  &amp;&amp; tar xvfz /tmp/opentelemetry-webserver-sdk-x64-linux.tgz -C /opt \</span><br><span class="line">  &amp;&amp; <span class="built_in">rm</span> -rf /tmp/opentelemetry-webserver-sdk-x64-linux.tgz \</span><br><span class="line"><span class="comment"># 3. 将‘load_module’指令安装并添加至主 NGINX 配置文件的顶部</span></span><br><span class="line">  &amp;&amp; /opt/opentelemetry-webserver-sdk/install.sh \</span><br><span class="line">  &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;load_module /opt/opentelemetry-webserver-sdk/WebServerModule/Nginx/1.23.1/ngx_http_opentelemetry_module.so;\n<span class="subst">$(cat /etc/nginx/nginx.conf)</span>&quot;</span> &gt; /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 复制到 NGINX OTel 模块的配置文件中</span></span><br><span class="line">COPY opentelemetry_module.conf /etc/nginx/conf.d/opentelemetry_module.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 8085</span><br><span class="line"></span><br><span class="line">STOPSIGNAL SIGQUIT</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打开 nginx.conf 并添加以下内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">events &#123;&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include /etc/nginx/conf.d/opentelemetry_module.conf;</span><br><span class="line"></span><br><span class="line">    upstream messenger &#123;</span><br><span class="line">        server localhost:4000;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8085;</span><br><span class="line">    </span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://messenger;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个基本的 NGINX 配置文件指示 NGINX：</p>
<ul>
<li>设置一个名为信使的上游组，以表示信使服务实例组。</li>
<li>在端口 8085 监听 HTTP 请求</li>
<li>将以 &#x2F; 开头的路径的所有传入请求（即所有传入请求）转发到信使上游</li>
</ul>
<blockquote>
<p>注：这与 NGINX 在生产环境中作为反向代理和负载均衡器的实际配置很相似。唯一的主要区别是，upstream 块中 server 指令的参数通常是域名或 IP 地址，而非 localhost。</p>
</blockquote>
<ol>
<li>打开 opentelemetry_module.conf 并添加以下内容：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NginxModuleEnabled ON;</span><br><span class="line">NginxModuleOtelSpanExporter otlp;</span><br><span class="line">NginxModuleOtelExporterEndpoint localhost:4317;</span><br><span class="line">NginxModuleServiceName messenger-lb;</span><br><span class="line">NginxModuleServiceNamespace MicroservicesMarchDemoArchitecture;</span><br><span class="line">NginxModuleServiceInstanceId DemoInstanceId;</span><br><span class="line">NginxModuleResolveBackends ON;</span><br><span class="line">NginxModuleTraceAsError ON;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>构建一个包含 NGINX 和 NGINX OTel 模块的 Docker 镜像：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t messenger-lb .</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>启动 NGINX 反向代理和负载均衡器的 Docker 容器：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --name messenger-lb -p 8085:8085 --network=<span class="string">&quot;host&quot;</span> messenger-lb</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在客户端终端，通过 NGINX 反向代理和负载均衡器向信使服务发送健康检查请求（在发送该请求之前无需等待）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8085/health</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：让 NGINX 和客户端终端保持打开状态，以便在挑战 3 中再次使用。</p>
</blockquote>
<ol start="8">
<li>在浏览器中，确认新的 messenger-lb 服务与您之前启动的服务一同列在 Jaeger 用户界面中。您可能需要在您的浏览器中重新加载 Jaeger 用户界面。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100821177.png" alt="图片"></p>
<h2 id="挑战-3：学习解读-OTel-链路追踪"><a href="#挑战-3：学习解读-OTel-链路追踪" class="headerlink" title="挑战 3：学习解读 OTel 链路追踪"></a>挑战 3：学习解读 OTel 链路追踪</h2><p>在架构和用户流中，我们概述了用户流的各个阶段，现在简单回顾一下：</p>
<ol>
<li><p>一位用户通过向另一位用户发送消息开始对话。</p>
</li>
<li><p>NGINX 反向代理拦截消息并将其转发给信使服务。</p>
</li>
<li><p>该信使服务将消息写入其数据库，然后通过 RabbitMQ 派发事件。</p>
</li>
<li><p>通知器服务使用该事件，查询接收者（第二位用户）的通知偏好，并通过首选方法向接收者发送通知。<br>实施遥测的目标是：</p>
</li>
<li><p>了解一个请求在新的消息流中所经历的所有步骤。</p>
</li>
<li><p>确认在正常情况下消息流可在五秒钟内端到端执行完毕。</p>
</li>
<li><p>查看通知器服务在多长时间之后才开始处理信使服务派发的事件。<br>在这个挑战中，您将学习如何评估 OTel 埋点生成的链路追踪是否满足上述目标要求。首先，运行系统并创建一些链路追踪数据。然后，检查消息流的链路追踪以及其中分别由 NGINX、信使服务和通知器服务生成的部分。</p>
</li>
</ol>
<h3 id="创建链路追踪数据"><a href="#创建链路追踪数据" class="headerlink" title="创建链路追踪数据"></a>创建链路追踪数据</h3><p>在客户端终端，设置对话并在两位用户之间发送几条消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">    -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">    -d <span class="string">&#x27;&#123;&quot;participant_ids&quot;: [1, 2]&#125;&#x27;</span> \</span><br><span class="line">    <span class="string">&#x27;http://localhost:8085/conversations&#x27;</span></span><br><span class="line"></span><br><span class="line">curl -X POST \</span><br><span class="line">    -H <span class="string">&quot;User-Id: 1&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">    -d <span class="string">&#x27;&#123;&quot;content&quot;: &quot;This is the first message&quot;&#125;&#x27;</span> \</span><br><span class="line">    <span class="string">&#x27;http://localhost:8085/conversations/1/messages&#x27;</span></span><br><span class="line"></span><br><span class="line">curl -X POST \</span><br><span class="line">    -H <span class="string">&quot;User-Id: 2&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">    -d <span class="string">&#x27;&#123;&quot;content&quot;: &quot;This is the second message&quot;&#125;&#x27;</span> \</span><br><span class="line">    <span class="string">&#x27;http://localhost:8085/conversations/1/messages&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通知器服务生成如下输出，并显示在通知器终端中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Received new_message: &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;new_message&quot;</span>,<span class="string">&quot;channel_id&quot;</span>:1,<span class="string">&quot;user_id&quot;</span>:1,<span class="string">&quot;index&quot;</span>:1,<span class="string">&quot;participant_ids&quot;</span>:[1,2]&#125;</span><br><span class="line">Sending notification of new message via sms to 12027621401</span><br><span class="line"></span><br><span class="line">Received new_message:  &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;new_message&quot;</span>,<span class="string">&quot;channel_id&quot;</span>:1,<span class="string">&quot;user_id&quot;</span>:2,<span class="string">&quot;index&quot;</span>:2,<span class="string">&quot;participant_ids&quot;</span>:[1,2]&#125;</span><br><span class="line"></span><br><span class="line">Sending notification of new message via email to the_hotstepper@kamo.ze</span><br><span class="line"></span><br><span class="line">Sending notification of new message via sms to 19147379938</span><br></pre></td></tr></table></figure>

<h3 id="准备好解读链路追踪"><a href="#准备好解读链路追踪" class="headerlink" title="准备好解读链路追踪"></a>准备好解读链路追踪</h3><p>在浏览器中打开 Jaeger 用户界面，从 Service 下拉菜单中选择 messenger-lb，然后点击 Find Traces 按钮。 此时界面上会显示一个链路追踪列表，回溯到用户流起初。点击任何链路追踪，即可显示相关详情，如下截图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100822153.png" alt="图片"></p>
<p>点击并查看详情。在继续操作之前，考虑一下链路追踪中的信息可如何帮助您实现挑战 3 的简介中提到的监测目标。相关问题包括：</p>
<ul>
<li>哪些信息有助于实现目标？</li>
<li>缺少什么信息？</li>
<li>哪些信息不相关？</li>
</ul>
<h3 id="检查链路追踪的-NGINX-messenger-lb-部分"><a href="#检查链路追踪的-NGINX-messenger-lb-部分" class="headerlink" title="检查链路追踪的 NGINX (messenger-lb) 部分"></a>检查链路追踪的 NGINX (messenger-lb) 部分</h3><h4 id="目标-1：在新的消息流中查看一个请求所经历的全部步骤"><a href="#目标-1：在新的消息流中查看一个请求所经历的全部步骤" class="headerlink" title="目标 1：在新的消息流中查看一个请求所经历的全部步骤"></a>目标 1：在新的消息流中查看一个请求所经历的全部步骤</h4><p>从 NGINX span 开始，父 span 包含 11 个子 span。由于当前的 NGINX 配置非常简单，因此子 span 意义不大，只显示了 NGINX 请求处理生命周期中每个步骤所用的时间。但 父 span（第一个）提供了一些有价值的信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100823010.png" alt="图片"></p>
<ul>
<li><p>在 Tags（标签）下，您能够看到以下属性：</p>
<p>综合来看，这三条信息传达的意思是：“向 &#x2F;conversations&#x2F;1&#x2F;messages 发送了一个 POST 请求，响应为 201（创建成功）”。这与架构和用户流中的第一步和第 4a 步相对应）。</p>
<ul>
<li>http.method 字段——POST（在 REST 术语中，这意味着创建）</li>
<li>http.status_code 字段——201（表示创建成功）</li>
<li>http.target字段——conversations&#x2F;1&#x2F;messages （消息端点）</li>
</ul>
</li>
<li><p>在 Process（进程）下，webengine.name 字段显示这是该请求的 NGINX 部分。</p>
</li>
</ul>
<p>此外，由于信使和通知器的 span 嵌套在 messenger-lb conversations&#x2F;1 span 内（如准备好解读链路追踪中的截图所示），您可以判断通过 NGINX 反向代理发送给信使服务的请求是否到达了流程中的所有预期组件。</p>
<p>该信息满足目标要求，因为您可以看到 NGINX 反向代理是流程的一部分。</p>
<h4 id="目标-2：验证消息流能否在五秒内执行完毕"><a href="#目标-2：验证消息流能否在五秒内执行完毕" class="headerlink" title="目标 2：验证消息流能否在五秒内执行完毕"></a>目标 2：验证消息流能否在五秒内执行完毕</h4><p>在标记 messenger-lb 的 span 列表中，查看最新 span（位于列表的底部），以了解请求的 NGINX 部分所用时长。在截图中，span 从 589 微秒 (µs) 开始，持续了 24µs，这意味着整个反向代理操作只花了 613µs——约 0.6 毫秒 (ms)。（当然，当您自己操作本教程步骤时，具体数值会有所不同）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100825791.png" alt="图片"></p>
<p>在这样的设置中，大多数情况下，这些值只是相对于其他度量值而言有用，并随系统而变。不过在本例中，该操作的时长显然不到 5 秒阈值。</p>
<p>该信息满足目标要求，因为您可以看到 NGINX 操作的时长都不曾接近 5 秒。如果消息流中出现了非常缓慢的操作，那一定是后来发生的。</p>
<h4 id="目标-3：查看通知器服务读取信使服务派发的事件需要多长时间"><a href="#目标-3：查看通知器服务读取信使服务派发的事件需要多长时间" class="headerlink" title="目标 3：查看通知器服务读取信使服务派发的事件需要多长时间"></a>目标 3：查看通知器服务读取信使服务派发的事件需要多长时间</h4><p>NGINX 反向代理层并不包括任何相关信息，因此您可以转到信使 span。</p>
<h3 id="检查链路追踪的信使部分"><a href="#检查链路追踪的信使部分" class="headerlink" title="检查链路追踪的信使部分"></a>检查链路追踪的信使部分</h3><h4 id="目标-1：在新的消息流中查看一个请求所经历的全部步骤-1"><a href="#目标-1：在新的消息流中查看一个请求所经历的全部步骤-1" class="headerlink" title="目标 1：在新的消息流中查看一个请求所经历的全部步骤"></a>目标 1：在新的消息流中查看一个请求所经历的全部步骤</h4><p>链路追踪的信使服务部分包含另外 11 个 span。同样，大多数子 span 涉及 Express 框架在处理请求时使用的基本步骤，意义不大。但父 span（第一个）再次提供了一些有价值的信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100826997.png" alt="图片"></p>
<p>在 Tags 下，您能够看到以下属性：</p>
<ul>
<li>http.method 字段——POST（同样在 REST 术语中，这意味着创建）</li>
<li>http.route 字段——&#x2F;conversations&#x2F;:conversationId&#x2F;messages（消息路由）</li>
<li>http.target 字段——&#x2F;conversations&#x2F;1&#x2F;messages（消息端点）<br>该信息满足目标要求，因为从中可以看出信使服务是流程的一部分，而且到达的端点是新的消息端点。</li>
</ul>
<h4 id="目标-2：验证消息流能否在五秒内执行完毕-1"><a href="#目标-2：验证消息流能否在五秒内执行完毕-1" class="headerlink" title="目标 2：验证消息流能否在五秒内执行完毕"></a>目标 2：验证消息流能否在五秒内执行完毕</h4><p>如下截图所示，链路追踪的信使部分开始于 1.28 ms，结束于 36.28ms，总时长为 35ms。其中大部分时间花在解析 JSON（middleware - jsonParser）和连接数据库（pg-pool.connect 和 tcp.connect）上。</p>
<p>鉴于在消息编写过程中还进行了几次 SQL 查询，因此这也很合理。这反过来表明，您可能需要增加自动埋点配置，以捕获这些查询的用时。（本教程没有用到这个额外的埋点，因此在挑战 4 中，您会手动创建 span，后者可用于打包数据库查询。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100827801.png" alt="图片"></p>
<p>该信息满足目标要求，因为从中可以看出信使操作的时长都不曾接近 5 秒。如果消息流中出现了非常缓慢的操作，那一定是后来发生的。</p>
<h4 id="目标-3：查看通知器服务读取信使服务派发的事件需要多长时间-1"><a href="#目标-3：查看通知器服务读取信使服务派发的事件需要多长时间-1" class="headerlink" title="目标 3：查看通知器服务读取信使服务派发的事件需要多长时间"></a>目标 3：查看通知器服务读取信使服务派发的事件需要多长时间</h4><p>与 NGINX span 一样，信使 span 不包含这些信息，因此您可以转到通知器 span。</p>
<h3 id="检查链路追踪的通知器部分"><a href="#检查链路追踪的通知器部分" class="headerlink" title="检查链路追踪的通知器部分"></a>检查链路追踪的通知器部分</h3><h4 id="目标-1：在新的消息流中查看一个请求所经历的全部步骤-2"><a href="#目标-1：在新的消息流中查看一个请求所经历的全部步骤-2" class="headerlink" title="目标 1：在新的消息流中查看一个请求所经历的全部步骤"></a>目标 1：在新的消息流中查看一个请求所经历的全部步骤</h4><p>链路追踪的通知器部分只包含两个 span：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100828438.png" alt="图片"></p>
<ul>
<li><p>chat_queue process span——确认通知器服务处理了来自 chat_queue 消息队列的事件</p>
</li>
<li><p>pg-pool.connect span——显示处理完事件后，通知器服务与其数据库建立了某种连接<br>仅凭从这些 span 中获取的信息，无法全面了解每一步。您可以看到通知器服务使用来自队列的事件，但却不知道：</p>
</li>
<li><p>该服务发送的消息通知是否与信使服务派发的事件相对应</p>
</li>
<li><p>相关消息通知是否正确地发送给了消息接收者<br>这表明您需要执行以下操作才能充分了解通知器服务流：</p>
</li>
<li><p>手动监测显示通知正在发送中的 span</p>
</li>
<li><p>确保信使服务派发的事件和通知器服务使用的事件之间以链路追踪 ID 的形式建立了明确的联系</p>
</li>
</ul>
<h4 id="目标-2：验证消息流能否在五秒内执行完毕-2"><a href="#目标-2：验证消息流能否在五秒内执行完毕-2" class="headerlink" title="目标 2：验证消息流能否在五秒内执行完毕"></a>目标 2：验证消息流能否在五秒内执行完毕</h4><p>通过查看通知器服务 span 的总用时，您可以看到请求在消息流的通知器部分花费了 30.77 ms。但是，由于没有表示整个消息流（向接收者发送通知）“结束”的 span，因此您无法确定消息流这一部分的总用时或操作完成的总用时。</p>
<h4 id="目标-3：查看通知器服务读取信使服务派发的事件需要多长时间-2"><a href="#目标-3：查看通知器服务读取信使服务派发的事件需要多长时间-2" class="headerlink" title="目标 3：查看通知器服务读取信使服务派发的事件需要多长时间"></a>目标 3：查看通知器服务读取信使服务派发的事件需要多长时间</h4><p>您可以看到通知器服务的 chat_queue process 开始于 6.12ms，即信使服务的 chat_queue send 开始（于 4.12ms）后 2ms。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100829140.png" alt="图片"></p>
<p>该目标达成了，因为您知道通知器在信使 服务派发事件 2ms 后使用了该事件。与目标 2 不同的是，您不需要知道事件是否已被完全处理，也不需要知道耗时多少便可实现此目标。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>根据我们对当前 OTel 自动埋点生成的链路追踪的分析，可以清楚地发现：</p>
<ul>
<li><p>许多 span 以当前形式而言毫无用处：</p>
<ul>
<li>NGINX 正在生成与功能相关的 span，例如授权检查和文件服务，但这些 span 与您所关心的角色 — 反向代理无关。但目前面向 NGINX 的 OTel 埋点不允许您省略不相关的 span，因此我们也无能为力。</li>
<li>在 Node.js 服务（信使和通知器服务）的 span 中，以下 span 似乎与目标相关：JSON 解析、request handler 以及所有数据库操作的 span。一些中间件 span（例如 expressInit 和 corsMiddleware）似乎不相关，可以移除。</li>
</ul>
</li>
<li><p>以下服务缺少关键 span：</p>
<ul>
<li>通知器服务发送的通知</li>
<li>信使服务派发的 RabbitMQ 事件与通知器服务处理的事件之间的明确映射<br>这意味着，基本埋点满足了最后一个目标要求：</li>
</ul>
</li>
<li><p>查看通知器服务在多长时间之后开始处理信使服务派发的事件。<br>然而，没有足够的信息来实现前两个目标：</p>
</li>
<li><p>了解一个请求在新的消息流中所经历的所有步骤。</p>
</li>
<li><p>确认在正常情况下消息流可在五秒钟内端到端执行完毕。</p>
</li>
</ul>
<h2 id="挑战-4：根据链路追踪解读优化埋点"><a href="#挑战-4：根据链路追踪解读优化埋点" class="headerlink" title="挑战 4：根据链路追踪解读优化埋点"></a>挑战 4：根据链路追踪解读优化埋点</h2><p>在这个挑战中，您将需要根据在挑战 3 中完成的追踪分析，优化 OTel 埋点。其中包括删除不必要的 span, 创建新的自定义 span，并确认通知器服务使用的事件是信使服务生成的事件。</p>
<h3 id="删除不必要的-span"><a href="#删除不必要的-span" class="headerlink" title="删除不必要的 span"></a>删除不必要的 span</h3><ol>
<li>在您常用的文本编辑器中，打开信使代码库的 app 目录下的 tracing.mjs 文件，并在顶部的导入语句列表的末尾添加以下内容：</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const IGNORED_EXPRESS_SPANS = new Set(<span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;middleware - expressInit&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;middleware - corsMiddleware&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span>);</span><br></pre></td></tr></table></figure>

<p>这定义了一组 span 名称，这些名称来自于下面 Jaeger 用户界面截图中的 span 列表，但由于无法为该消息流提供有用的信息而将从追踪中删除。您可能决定也不需要该截图中所列的其他 span，并将其添加到 IGNORED_EXPRESS_SPANS 列表中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100831081.png" alt="图片"></p>
<ol start="2">
<li>将过滤器添加至自动埋点配置，以删除您不需要的 span，具体方法是将下列橙色高亮显示的部分：</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sdk = new opentelemetry.NodeSDK(<span class="punctuation">&#123;</span></span><br><span class="line">  resource<span class="punctuation">,</span></span><br><span class="line">  traceExporter<span class="punctuation">:</span> new OTLPTraceExporter(<span class="punctuation">&#123;</span> headers<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  instrumentations<span class="punctuation">:</span> <span class="punctuation">[</span>getNodeAutoInstrumentations()<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span>);</span><br></pre></td></tr></table></figure>

<p>更改为以下行：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const sdk = new opentelemetry.NodeSDK(<span class="punctuation">&#123;</span></span><br><span class="line">  resource<span class="punctuation">,</span></span><br><span class="line">  traceExporter<span class="punctuation">:</span> new OTLPTraceExporter(<span class="punctuation">&#123;</span> headers<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  instrumentations<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    getNodeAutoInstrumentations(<span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@opentelemetry/instrumentation-express&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        ignoreLayers<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          (name) =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">            return IGNORED_EXPRESS_SPANS.has(name);</span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getNodeAutoInstrumentations 函数引用了第一步中定义的 span 集，以将这些 span 从 @opentelemetry&#x2F;instrumentation-express 生成的链路追踪中滤除。换而言之，对于属于 IGNORED_EXPRESS_SPANS 的 span，将 return 语句解析为 true，同时 ignoreLayers 语句从链路追踪中移除该 span。</p>
<ol start="3">
<li>在信使终端，按下 Ctrl+c 来停止信使服务。然后重启它。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^c</span><br><span class="line">node --import ./tracing.mjs index.mjs</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>等待大约十秒钟，然后在客户端终端发送一条新消息：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line"> -H <span class="string">&quot;User-Id: 2&quot;</span> \</span><br><span class="line"> -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line"> -d <span class="string">&#x27;&#123;&quot;content&quot;: &quot;This is the second message&quot;&#125;&#x27;</span> \</span><br><span class="line"> <span class="string">&#x27;http://localhost:8085/conversations/1/messages&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 Jaeger 用户界面中再检查信使 span。两个 middleware span — expressInit 和 corsMiddleware 不再显示（您可以将其与挑战 3 中检查链路追踪的信使部分的目标 2 截图进行比较）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100833645.png" alt="图片"></p>
<h3 id="设置自定义-span"><a href="#设置自定义-span" class="headerlink" title="设置自定义 span"></a>设置自定义 span</h3><p>在这一部分中，您将首次接触到应用代码。自动埋点无需更改应用便可生成大量信息，但有些见解必须通过对业务逻辑的特定部分进行监测才能获取。</p>
<p>对于您正在监测的新消息流，一个示例是跟踪向消息接收者发送通知。</p>
<ol>
<li>打开通知器代码库的 app 目录下的 index.mjs。该文件包含服务的所有业务逻辑。在文件顶部的 import 语句列表的末尾添加以下行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; trace &#125; from <span class="string">&quot;@opentelemetry/api&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>替换该代码（在文件中的第 91 行左右）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> pref of preferences) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    `Sending notification of new message via <span class="variable">$&#123;pref.address_type&#125;</span> to <span class="variable">$&#123;pref.address&#125;</span>`</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用以下代码替换上文:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const tracer = trace.getTracer(<span class="string">&quot;notifier&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">tracer.startActiveSpan( <span class="comment">// 2</span></span><br><span class="line">  <span class="string">&quot;notification.send_all&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    attributes<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      user_id<span class="punctuation">:</span> msg.user_id<span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  (parentSpan) =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">    for (let pref of preferences) <span class="punctuation">&#123;</span></span><br><span class="line">      tracer.startActiveSpan(  <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;notification.send&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          attributes<span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 4</span></span><br><span class="line">            notification_type<span class="punctuation">:</span> pref.address_type<span class="punctuation">,</span></span><br><span class="line">            user_id<span class="punctuation">:</span> pref.user_id<span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        (span) =&gt; <span class="punctuation">&#123;</span></span><br><span class="line">          console.log(</span><br><span class="line">            `Sending notification of new message via $<span class="punctuation">&#123;</span>pref.address_type<span class="punctuation">&#125;</span> to $<span class="punctuation">&#123;</span>pref.address<span class="punctuation">&#125;</span>`</span><br><span class="line">          );</span><br><span class="line">          span.end(); <span class="comment">// 5</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      );</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    parentSpan.end(); <span class="comment">// 6</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>新代码会执行以下操作：</p>
<ol>
<li>获取 tracer，它是一个全局对象，用于与 OTel 链路追踪进行交互。</li>
<li>开启一个名为 notification.send_all 的新的父 span，并设置 user_id 属性以识别消息的发送者。</li>
<li>进入一个循环，其中列举了接收者的通知偏好，并在 notification.send_all 下新建了一个名为 notification.send 的子 span。每个通知都会生成一个新 span。</li>
<li>为子 span 设置更多的属性：</li>
</ol>
<ul>
<li>notification_type——短信或电子邮件之一</li>
<li>user_id——通知接收用户的 ID</li>
</ul>
<ol start="5">
<li><p>依次关闭每个子 notification.send。</p>
</li>
<li><p>关闭父 notification.send_all。<br>拥有父 span 可确保每个“发送通知”操作都会被报告，即使没有发现用户的通知偏好。</p>
</li>
<li><p>在通知器终端，按下 Ctrl+c 来停止通知器服务。然后重启它：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^c</span><br><span class="line">node --import ./tracing.mjs index.mjs</span><br></pre></td></tr></table></figure>

<p>等待大约十秒钟，然后在客户端终端发送一条新消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line"> -H <span class="string">&quot;User-Id: 2&quot;</span> \</span><br><span class="line"> -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line"> -d <span class="string">&#x27;&#123;&quot;content&quot;: &quot;This is the second message&quot;&#125;&#x27;</span> \</span><br><span class="line"> <span class="string">&#x27;http://localhost:8085/conversations/1/messages&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 Jaeger 用户界面中再检查通知器 span。您会看到父 span 和两个子 span，每个 span 都有“发送通知”操作：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202307100838613.png" alt="图片"></p>
<p>现在您可以完全实现第一个和第二个目标，因为您可以看到一个请求在新的消息流中所经历的所有步骤。在每个 span 上所花费的时间能够暴露这些步骤之间的任何延迟。</p>
<h3 id="确认信使和通知器正在处理同一个事件"><a href="#确认信使和通知器正在处理同一个事件" class="headerlink" title="确认信使和通知器正在处理同一个事件"></a>确认信使和通知器正在处理同一个事件</h3><p>如欲全面了解消息流，您还需要确认以下一点。通知器服务处理的事件实际上是信使服务派发的事件吗？</p>
<p>您不必做出任何明确的修改便可连接这两个追踪，但您也不能盲目相信自动埋点。</p>
<p>考虑到这一点，您可以添加一些快速调试代码，以验证在 NGINX 服务中启动的追踪确实与通知器服务所用的追踪相同（具有相同的追踪 ID）。</p>
<ol>
<li>打开信使代码库的 app 目录下的 index.mjs 文件，并进行以下修改：</li>
</ol>
<ul>
<li>在顶部的导入语句列表的末尾添加以下代码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; trace &#125; from <span class="string">&quot;@opentelemetry/api&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在现有的黑色行下面添加橙色高亮显示的代码：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> createMessageInConversation(req, res) &#123;</span><br><span class="line">  const tracer = trace.getActiveSpan();</span><br><span class="line">  console.log(<span class="string">&quot;TRACE_ID: &quot;</span>, tracer.spanContext().traceId);</span><br></pre></td></tr></table></figure>

<p>新行列出了信使中处理新消息创建的函数内的 TRACE_ID。</p>
<ol start="2">
<li>打开通知器代码库的 app 目录下的 index.mjs 文件，并在现有的黑色行下面添加橙色高亮显示的行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> async <span class="keyword">function</span> handleMessageConsume(channel, msg, handlers) &#123;</span><br><span class="line">  console.log(<span class="string">&quot;RABBIT_MQ_MESSAGE: &quot;</span>, msg);</span><br></pre></td></tr></table></figure>

<p>新行列出了通知服务接收的 AMQP 事件的全部内容。</p>
<ol start="3">
<li>通过在信使和通知器这两个终端运行这些命令，停止并重启信使和通知器服务：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^c</span><br><span class="line">node --import ./tracing.mjs index.mjs</span><br></pre></td></tr></table></figure>

<p>等待大约 10 秒钟，然后在客户端终端上再次发送信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line"> -H <span class="string">&quot;User-Id: 2&quot;</span> \</span><br><span class="line"> -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line"> -d <span class="string">&#x27;&#123;&quot;content&quot;: &quot;This is the second message&quot;&#125;&#x27;</span> \</span><br><span class="line"> <span class="string">&#x27;http://localhost:8085/conversations/1/messages&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>查看信使服务和通知器服务的日志。在信使服务日志中，如下所示的一行报告了消息的链路追踪 ID（当您自己操作本教程步骤时，实际 ID 会有所不同）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE_ID:  29377a9b546c50be629c8e64409bbfb5</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>同样地，通知器服务日志在如下所示的输出中报告链路追踪 ID：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_spanContext: &#123;</span><br><span class="line">  traceId: <span class="string">&#x27;29377a9b546c50be629c8e64409bbfb5&#x27;</span>,</span><br><span class="line">  spanId: <span class="string">&#x27;a94e9462a39e6dbf&#x27;</span>,</span><br><span class="line">  traceFlags: 1,</span><br><span class="line">  traceState: undefined</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在控制台中链路追踪 ID 是匹配的，但最后您可以将其与 Jaeger 用户界面中的链路追踪 ID 进行比较。在相关链路追踪 ID 端点（您的端点会有所不同，但在本例中是 <a target="_blank" rel="noopener" href="http://localhost:16686/trace/29377a9b546c50be629c8e64409bbfb5%EF%BC%89%EF%BC%8C%E6%89%93%E5%BC%80%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%95%B4%E4%B8%AA%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E3%80%82Jaeger">http://localhost:16686/trace/29377a9b546c50be629c8e64409bbfb5），打开用户界面，查看整个链路追踪。Jaeger</a> 链路追踪确认：</li>
</ol>
<ul>
<li>在派发事件时，信使服务中的 AMQP 自动埋点添加了这个链路追踪 ID 作为元数据的一部分。</li>
<li>通知器服务中的 AMQP 自动埋点需要该元数据并相应地设置了链路追踪上下文。<blockquote>
<p>注：在实际生产系统中，一旦确认流程按预期运行，即可删除您在本部分中添加的代码。</p>
</blockquote>
</li>
</ul>
<h2 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h2><p>整个教程下来，您创建了不少容器和镜像！使用以下指令来将其删除。</p>
<ul>
<li>删除任何正在运行的 Docker 容器：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> $(docker stop messenger-lb)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除平台服务以及信使与通知器数据库服务：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/microservices-march/platform &amp;&amp; docker compose down</span><br><span class="line"><span class="built_in">cd</span> ~/microservices-march/notifier &amp;&amp; docker compose down</span><br><span class="line"><span class="built_in">cd</span> ~/microservices-march/messenger &amp;&amp; docker compose down</span><br></pre></td></tr></table></figure>

<h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p>您在一个 NGINX 反向代理和两个 Node.js 服务中设置了 OTel 埋点。<br>您以严谨的眼光审视了 OTel 自动埋点提供的数据，并增添了一些缺失的遥测数据，以实现 OTel 实验的目标：<br>您在不直接更改任何应用代码的情况下，对特定请求在消息传递系统中的经历获得了清晰的视图。<br>您确认了在正常情况下消息流可在五秒内端到端执行完毕。<br>然而，您接触的仅仅是链路追踪配置的基础知识！在生产环境中，您可能希望为每个数据库查询添加自定义 span 等内容，并在所有 span 上添加额外的元数据来描述运行时细节（例如每个服务的容器 ID）。您还可以实现另外两种 OTel 数据类型（指标和日志），以全面了解系统的运行状况。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lat-YIm9KaOc7gZZZscBaw">使用 OpenTelemetry Tracing 了解您的微服务 (qq.com)</a>)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.kkun.site">姬岚忧</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.kkun.site/2023/07/10/%E4%BD%BF%E7%94%A8%20OpenTelemetry%20Tracing%20%E4%BA%86%E8%A7%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1/">https://blog.kkun.site/2023/07/10/%E4%BD%BF%E7%94%A8%20OpenTelemetry%20Tracing%20%E4%BA%86%E8%A7%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.kkun.site" target="_blank">流水易寒の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kubernetes/">kubernetes</a><a class="post-meta__tags" href="/tags/ingress/">ingress</a><a class="post-meta__tags" href="/tags/opentracing/">opentracing</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202301051001001.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/11/%E6%B8%90%E8%BF%9B%E5%BC%8F%E4%BA%A4%E4%BB%98%E7%BB%84%E4%BB%B6Kruise%20Rollouts%E4%BD%BF%E7%94%A8/"><img class="prev-cover" src="https://img.xjh.me/random_img.php?type=bg&amp;return=302" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">渐进式交付组件 Kruise Rollouts 使用</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/13/kubeadm%20%E9%83%A8%E7%BD%B2%20Kubernetes(v1.26.3)%E9%9B%86%E7%BE%A4/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202301101650972.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">kubeadm 部署 Kubernetes(v1.26.3)集群</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/04/ingress%20%E5%85%BC%E5%AE%B9%E6%97%A7%E7%89%88tls/" title="ingress 兼容旧版tls"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/78162562_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-04</div><div class="title">ingress 兼容旧版tls</div></div></a></div><div><a href="/2023/07/28/CGroups%E4%BB%A5%E5%8F%8A%E5%9C%A8K8s%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-IO/" title="CGroups 以及在 K8s 中的应用 - IO"><img class="cover" src="https://api.vvhan.com/api/acgimg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-28</div><div class="title">CGroups 以及在 K8s 中的应用 - IO</div></div></a></div><div><a href="/2023/01/04/CI%E6%9E%84%E5%BB%BA%E6%8A%A5%E9%94%99%E6%8F%90%E7%A4%BANo%20such%20device%20or%20addres/" title="CI构建报错提示No such device or addres"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202301050959939.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-04</div><div class="title">CI构建报错提示No such device or addres</div></div></a></div><div><a href="/2023/02/07/CoreDNS%20%E5%9C%A8%20K8S%20%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%9B%91%E6%8E%A7/" title="CoreDNS 在 K8S 中的作用及监控"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202302071505193.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">CoreDNS 在 K8S 中的作用及监控</div></div></a></div><div><a href="/2022/12/29/ETCD%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98--%E8%87%AA%E5%8A%A8%E5%8E%8B%E7%BC%A9--%E6%9C%80%E5%A4%A7%E5%AD%97%E8%8A%82%E6%95%B0--%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F/" title="ETCD使用中需要注意的问题"><img class="cover" src="https://tenapi.cn/acg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-29</div><div class="title">ETCD使用中需要注意的问题</div></div></a></div><div><a href="/2023/03/24/Grafana%E4%B8%8E%20Tempo%20%E5%92%8C%20Jaeger%20%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/" title="Grafana与 Tempo 和 Jaeger 的分布式跟踪"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/84596624_p0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="title">Grafana与 Tempo 和 Jaeger 的分布式跟踪</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">姬岚忧</div><div class="author-info__description">不想做开发的运维，不是好运维</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">39</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ghostpanter"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ghostpanter" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:18816230062qk@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%99%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">教程概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%99%E7%A8%8B%E6%9E%B6%E6%9E%84%E5%92%8C%E9%81%A5%E6%B5%8B%E7%9B%AE%E6%A0%87"><span class="toc-number">2.</span> <span class="toc-text">教程架构和遥测目标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%A5%E6%B5%8B%E7%9B%AE%E6%A0%87"><span class="toc-number">2.1.</span> <span class="toc-text">遥测目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%91%E6%88%98-1%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%9F%BA%E6%9C%AC-OTel-%E5%9F%8B%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">挑战 1：设置基本 OTel 埋点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BF%A1%E4%BD%BF%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">启动信使服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%91%E9%80%81%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84-OTel-%E8%87%AA%E5%8A%A8%E5%9F%8B%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">配置发送到控制台的 OTel 自动埋点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%91%E6%88%98-2%EF%BC%9A%E4%B8%BA%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE-OTel-%E5%9F%8B%E7%82%B9%E5%92%8C%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">挑战 2：为所有服务设置 OTel 埋点和链路追踪可视化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-OTel-%E8%87%AA%E5%8A%A8%E5%9F%8B%E7%82%B9%E5%8F%91%E9%80%81%E5%88%B0%E5%A4%96%E9%83%A8%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">配置 OTel 自动埋点发送到外部收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%80%9A%E7%9F%A5%E5%99%A8%E6%9C%8D%E5%8A%A1%E7%9A%84-OTel-%E8%87%AA%E5%8A%A8%E5%9F%8B%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">配置通知器服务的 OTel 自动埋点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-NGINX-%E7%9A%84-OTEL-%E5%9F%8B%E7%82%B9"><span class="toc-number">4.3.</span> <span class="toc-text">配置 NGINX 的 OTEL 埋点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%91%E6%88%98-3%EF%BC%9A%E5%AD%A6%E4%B9%A0%E8%A7%A3%E8%AF%BB-OTel-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA"><span class="toc-number">5.</span> <span class="toc-text">挑战 3：学习解读 OTel 链路追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E6%95%B0%E6%8D%AE"><span class="toc-number">5.1.</span> <span class="toc-text">创建链路追踪数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%A5%BD%E8%A7%A3%E8%AF%BB%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA"><span class="toc-number">5.2.</span> <span class="toc-text">准备好解读链路追踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E7%9A%84-NGINX-messenger-lb-%E9%83%A8%E5%88%86"><span class="toc-number">5.3.</span> <span class="toc-text">检查链路追踪的 NGINX (messenger-lb) 部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-1%EF%BC%9A%E5%9C%A8%E6%96%B0%E7%9A%84%E6%B6%88%E6%81%AF%E6%B5%81%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E5%85%A8%E9%83%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.3.1.</span> <span class="toc-text">目标 1：在新的消息流中查看一个请求所经历的全部步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-2%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%B6%88%E6%81%AF%E6%B5%81%E8%83%BD%E5%90%A6%E5%9C%A8%E4%BA%94%E7%A7%92%E5%86%85%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95"><span class="toc-number">5.3.2.</span> <span class="toc-text">目标 2：验证消息流能否在五秒内执行完毕</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-3%EF%BC%9A%E6%9F%A5%E7%9C%8B%E9%80%9A%E7%9F%A5%E5%99%A8%E6%9C%8D%E5%8A%A1%E8%AF%BB%E5%8F%96%E4%BF%A1%E4%BD%BF%E6%9C%8D%E5%8A%A1%E6%B4%BE%E5%8F%91%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%9C%80%E8%A6%81%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4"><span class="toc-number">5.3.3.</span> <span class="toc-text">目标 3：查看通知器服务读取信使服务派发的事件需要多长时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E7%9A%84%E4%BF%A1%E4%BD%BF%E9%83%A8%E5%88%86"><span class="toc-number">5.4.</span> <span class="toc-text">检查链路追踪的信使部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-1%EF%BC%9A%E5%9C%A8%E6%96%B0%E7%9A%84%E6%B6%88%E6%81%AF%E6%B5%81%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E5%85%A8%E9%83%A8%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">目标 1：在新的消息流中查看一个请求所经历的全部步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-2%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%B6%88%E6%81%AF%E6%B5%81%E8%83%BD%E5%90%A6%E5%9C%A8%E4%BA%94%E7%A7%92%E5%86%85%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-1"><span class="toc-number">5.4.2.</span> <span class="toc-text">目标 2：验证消息流能否在五秒内执行完毕</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-3%EF%BC%9A%E6%9F%A5%E7%9C%8B%E9%80%9A%E7%9F%A5%E5%99%A8%E6%9C%8D%E5%8A%A1%E8%AF%BB%E5%8F%96%E4%BF%A1%E4%BD%BF%E6%9C%8D%E5%8A%A1%E6%B4%BE%E5%8F%91%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%9C%80%E8%A6%81%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4-1"><span class="toc-number">5.4.3.</span> <span class="toc-text">目标 3：查看通知器服务读取信使服务派发的事件需要多长时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E7%9A%84%E9%80%9A%E7%9F%A5%E5%99%A8%E9%83%A8%E5%88%86"><span class="toc-number">5.5.</span> <span class="toc-text">检查链路追踪的通知器部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-1%EF%BC%9A%E5%9C%A8%E6%96%B0%E7%9A%84%E6%B6%88%E6%81%AF%E6%B5%81%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E5%85%A8%E9%83%A8%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">5.5.1.</span> <span class="toc-text">目标 1：在新的消息流中查看一个请求所经历的全部步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-2%EF%BC%9A%E9%AA%8C%E8%AF%81%E6%B6%88%E6%81%AF%E6%B5%81%E8%83%BD%E5%90%A6%E5%9C%A8%E4%BA%94%E7%A7%92%E5%86%85%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-2"><span class="toc-number">5.5.2.</span> <span class="toc-text">目标 2：验证消息流能否在五秒内执行完毕</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-3%EF%BC%9A%E6%9F%A5%E7%9C%8B%E9%80%9A%E7%9F%A5%E5%99%A8%E6%9C%8D%E5%8A%A1%E8%AF%BB%E5%8F%96%E4%BF%A1%E4%BD%BF%E6%9C%8D%E5%8A%A1%E6%B4%BE%E5%8F%91%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%9C%80%E8%A6%81%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4-2"><span class="toc-number">5.5.3.</span> <span class="toc-text">目标 3：查看通知器服务读取信使服务派发的事件需要多长时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">6.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%91%E6%88%98-4%EF%BC%9A%E6%A0%B9%E6%8D%AE%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E8%A7%A3%E8%AF%BB%E4%BC%98%E5%8C%96%E5%9F%8B%E7%82%B9"><span class="toc-number">7.</span> <span class="toc-text">挑战 4：根据链路追踪解读优化埋点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-span"><span class="toc-number">7.1.</span> <span class="toc-text">删除不必要的 span</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89-span"><span class="toc-number">7.2.</span> <span class="toc-text">设置自定义 span</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E4%BF%A1%E4%BD%BF%E5%92%8C%E9%80%9A%E7%9F%A5%E5%99%A8%E6%AD%A3%E5%9C%A8%E5%A4%84%E7%90%86%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.3.</span> <span class="toc-text">确认信使和通知器正在处理同一个事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%B8%85%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">资源清理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.</span> <span class="toc-text">后续步骤</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/28/%E4%BD%BF%E7%94%A8%20OpenTelemetry%20Collector%20%E6%94%B6%E9%9B%86%20Kubernetes%20%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE/" title="使用 OpenTelemetry Collector 收集 Kubernetes 日志数据"><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202308280847173.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用 OpenTelemetry Collector 收集 Kubernetes 日志数据"/></a><div class="content"><a class="title" href="/2023/08/28/%E4%BD%BF%E7%94%A8%20OpenTelemetry%20Collector%20%E6%94%B6%E9%9B%86%20Kubernetes%20%E6%97%A5%E5%BF%97%E6%95%B0%E6%8D%AE/" title="使用 OpenTelemetry Collector 收集 Kubernetes 日志数据">使用 OpenTelemetry Collector 收集 Kubernetes 日志数据</a><time datetime="2023-08-28T02:52:55.000Z" title="发表于 2023-08-28 10:52:55">2023-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/28/%E4%BD%BF%E7%94%A8OpenTelemetry%20Collector%E9%87%87%E9%9B%86Kubernetes%E6%8C%87%E6%A0%87%E6%95%B0%E6%8D%AE/" title="使用 OpenTelemetry Collector 采集 Kubernetes 指标数据"><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202308280933314.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用 OpenTelemetry Collector 采集 Kubernetes 指标数据"/></a><div class="content"><a class="title" href="/2023/08/28/%E4%BD%BF%E7%94%A8OpenTelemetry%20Collector%E9%87%87%E9%9B%86Kubernetes%E6%8C%87%E6%A0%87%E6%95%B0%E6%8D%AE/" title="使用 OpenTelemetry Collector 采集 Kubernetes 指标数据">使用 OpenTelemetry Collector 采集 Kubernetes 指标数据</a><time datetime="2023-08-28T01:52:55.000Z" title="发表于 2023-08-28 09:52:55">2023-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/24/Ubuntu%20apt%E6%BA%90%E5%AF%86%E9%92%A5%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Ubuntu apt源密钥不可用解决方案"><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202301050959355.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ubuntu apt源密钥不可用解决方案"/></a><div class="content"><a class="title" href="/2023/08/24/Ubuntu%20apt%E6%BA%90%E5%AF%86%E9%92%A5%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Ubuntu apt源密钥不可用解决方案">Ubuntu apt源密钥不可用解决方案</a><time datetime="2023-08-24T00:03:51.000Z" title="发表于 2023-08-24 08:03:51">2023-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/23/%E4%BD%BF%E7%94%A8helm%E5%AE%89%E8%A3%85NFS-Client%20Provisioner%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8/" title="使用helm安装NFS-Client Provisioner实现动态存储"><img src="https://tenapi.cn/acg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用helm安装NFS-Client Provisioner实现动态存储"/></a><div class="content"><a class="title" href="/2023/08/23/%E4%BD%BF%E7%94%A8helm%E5%AE%89%E8%A3%85NFS-Client%20Provisioner%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8/" title="使用helm安装NFS-Client Provisioner实现动态存储">使用helm安装NFS-Client Provisioner实现动态存储</a><time datetime="2023-08-23T06:22:51.000Z" title="发表于 2023-08-23 14:22:51">2023-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/16/linux%E5%8A%A0%E5%9B%BA%E8%84%9A%E6%9C%AC/" title="Linux加固脚本"><img src="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux加固脚本"/></a><div class="content"><a class="title" href="/2023/08/16/linux%E5%8A%A0%E5%9B%BA%E8%84%9A%E6%9C%AC/" title="Linux加固脚本">Linux加固脚本</a><time datetime="2023-08-16T00:03:51.000Z" title="发表于 2023-08-16 08:03:51">2023-08-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202301051001001.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 姬岚忧</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8017562763" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '119.60681,31.99260';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>