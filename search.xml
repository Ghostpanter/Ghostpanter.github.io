<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>k8s常见的问题处理</title>
    <url>/2022/12/28/k8s%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="Coredns容器或local-dns容器重启"><a href="#Coredns容器或local-dns容器重启" class="headerlink" title="Coredns容器或local-dns容器重启"></a>Coredns容器或local-dns容器重启</h1><p>集群中的coredns组件发生重启(重新创建)，一般是由于coredns组件压力较大导致oom，请检查业务是否异常，是否存在应用容器无法解析域名的异常。</p>
<p>如果是local-dns重启，说明local-dns的性能也不够了，需要优化</p>
<h1 id="Pod-was-OOM-killed"><a href="#Pod-was-OOM-killed" class="headerlink" title="Pod was OOM killed"></a>Pod was OOM killed</h1><p>云应用容器实例发生OOM，请检查云应用是否正常。一般地，如果云应用配置了健康检查，当进程OOM了，健康检查如果失败，集群会自动重启容器。</p>
<p>OOM问题排查步骤：</p>
<p>检查应用进程内存配置，如Java的jvm参数，对比应用监控-基础监控中的内存指标，判断是否是参数设置低导致进程内存不够用，适当进行参数优化</p>
<h1 id="Out-of-memory-Kill-process"><a href="#Out-of-memory-Kill-process" class="headerlink" title="Out of memory: Kill process"></a>Out of memory: Kill process</h1><h2 id="原因描述："><a href="#原因描述：" class="headerlink" title="原因描述："></a>原因描述：</h2><p>一般是操作系统把容器内进程Kill而导致的系统内核事件。比如一个java应用，当实际占用内存超过堆内存配置大小时，就会出现OOM错误。发生进程被Kill之后，容器依旧是存活状态，容器的健康检查还会继续进行。所以后面通常会伴随出现健康检查失败的错误。</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>要具体分析进程被Kill的原因，适当的调整进程内存的限制值。可以结合应用监控来参考进程内存的变化趋势。</p>
<h1 id="Memory-cgroup-out-of-memory-Kill-process"><a href="#Memory-cgroup-out-of-memory-Kill-process" class="headerlink" title="Memory cgroup out of memory: Kill process"></a>Memory cgroup out of memory: Kill process</h1><h2 id="原因描述：-1"><a href="#原因描述：-1" class="headerlink" title="原因描述："></a>原因描述：</h2><p>一般是由于容器的内存实际使用量超过了容器内存限制值而导致的事件。比如容器的内存限制值配置了1Gi，而容器的内存随着容器内进程内存使用量的增加超过了1Gi，就会导致容器被操作系统Cgroup Kill。发生容器被Kill之后，容器已经被停止，所以后续会出现应用实例被重启的情况。</p>
<h2 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h2><p>检查容器内进程是否有内存泄漏问题，同时适当调整容器内存的限制值大小。可以结合应用监控来看变化趋势。需要注意的是，容器内存限制值大小不应该过大，否则可能导致极端资源争抢情况下，容器被迫驱逐的问题。</p>
<h1 id="System-OOM-encountered"><a href="#System-OOM-encountered" class="headerlink" title="System OOM encountered"></a>System OOM encountered</h1><h2 id="原因描述：-2"><a href="#原因描述：-2" class="headerlink" title="原因描述："></a>原因描述：</h2><p>上述两种OOM（进程OOM，容器OOM）发生后，都可能会伴随一个系统OOM事件，该事件的原因是由上述OOM事件伴随导致。</p>
<h2 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要解决上面进程OOM或者容器CgroupOOM的问题。</p>
<h1 id="failed-to-garbage-collect-required-amount-of-images"><a href="#failed-to-garbage-collect-required-amount-of-images" class="headerlink" title="failed to garbage collect required amount of images"></a>failed to garbage collect required amount of images</h1><h2 id="原因描述：-3"><a href="#原因描述：-3" class="headerlink" title="原因描述："></a>原因描述：</h2><p>当容器集群中的节点（宿主机）磁盘使用率达到85%之后，会触发自动的容器镜像回收策略，以便于释放足够的宿主机磁盘。该事件发生于当触发镜像回收策略之后，磁盘空间仍然不足以达到健康阈值（默认为80%）。通常该错误是由于宿主机磁盘被占用太多导致。当磁盘空间占用率持续增长（超过90%），会导致该节点上的所有容器被驱逐，也就是当前节点由于磁盘压力不再对外提供服务，直到磁盘空间释放。</p>
<h2 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h2><p>检查节点的磁盘分配情况，通常有以下一些常见情况导致磁盘占用率过高：</p>
<p>有大量日志在磁盘上没有清理；请清理日志。<br>有进程在宿主机不停的写文件；请控制文件大小，将文件存储至OSS或者NAS。<br>下载的或者是其他的静态资源文件占用空间过大；静态资源请存储至OSS或CDN。</p>
<h1 id="Attempting-to-xxxx"><a href="#Attempting-to-xxxx" class="headerlink" title="Attempting to xxxx"></a>Attempting to xxxx</h1><p>节点资源不足(EvictionThresholdMet)，一般是节点资源将要达到阈值，可能会触发Pod驱逐。如 Attempting to reclaim ephemeral-storage</p>
<h2 id="原因描述：-4"><a href="#原因描述：-4" class="headerlink" title="原因描述："></a>原因描述：</h2><p>ephemeral storage是临时存储空间，当磁盘空间使用率达到阈值，会触发临时存储空间的回收任务。回收任务会尝试回收系统日志，以及没有正在使用的镜像缓存等数据。当磁盘空间占用率持续增长（超过90%），会导致该节点上的所有容器被驱逐，也就是当前节点由于磁盘压力不再对外提供服务，直到磁盘空间释放。</p>
<h2 id="解决方案：-4"><a href="#解决方案：-4" class="headerlink" title="解决方案："></a>解决方案：</h2><p>请注意磁盘空间的使用：</p>
<p>避免使用“空目录”类型的挂载方式；使用NAS或者其他类似方式替代。<br>尽量避免使用“宿主机目录”类型的挂载方式，以便于保证容器是无状态的，可以迁移的。<br>要注意避免在容器内大量写文件，而导致容器运行时可写数据层过大（imagefs）。</p>
<h1 id="NTP-service-is-not-running"><a href="#NTP-service-is-not-running" class="headerlink" title="NTP service is not running"></a>NTP service is not running</h1><h2 id="原因描述：-5"><a href="#原因描述：-5" class="headerlink" title="原因描述："></a>原因描述：</h2><p>NTP service是系统时间校准服务，由操作系统systemd管理的服务。可以通过 systemctl status chronyd 查看对应服务的状态。</p>
<h2 id="解决方案：-5"><a href="#解决方案：-5" class="headerlink" title="解决方案："></a>解决方案：</h2><p>使用命令systemctl start chronyd尝试重新启动。也可以通过命令 journalctl -u chronyd 查看服务的日志。</p>
<h1 id="节点PLEG异常"><a href="#节点PLEG异常" class="headerlink" title="节点PLEG异常"></a>节点PLEG异常</h1><h2 id="原因描述：-6"><a href="#原因描述：-6" class="headerlink" title="原因描述："></a>原因描述：</h2><p>PLEG是pod生命周期事件生成器，会记录Pod生命周期中的各种事件，如容器的启动、终止等。一般是由于节点上的daemon进程异常或者节点systemd版本bug导致。出现该问题会导致集群节点不可用</p>
<h2 id="解决方案：-6"><a href="#解决方案：-6" class="headerlink" title="解决方案："></a>解决方案：</h2><p>可以尝试重启kubelet；再尝试重启Docker进程。重启这两个进程过程中，不会对已运行容器造成影响</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//重启kubelet</span><br><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">//重启docker</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">//查看docker日志</span><br><span class="line">journalctl -xeu docker &gt; docker.log</span><br><span class="line">如果是由于systemd版本问题导致，重启节点可短暂修复，彻底解决的话需要升级节点的systemd</span><br><span class="line"></span><br><span class="line">systemd: (rpm -qa | grep systemd, 版本&lt;219-67.el7需要升级)</span><br><span class="line">升级systemd指令: </span><br><span class="line">yum update -y systemd &amp;&amp; systemctl daemon-reexec &amp;&amp; killall runc</span><br></pre></td></tr></table></figure>
<h1 id="节点PID不足"><a href="#节点PID不足" class="headerlink" title="节点PID不足"></a>节点PID不足</h1><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>通常是节点上的容器占用PID过多导致节点的PID不足</p>
<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>当节点的可用PID低于pid.available配置项时，则节点状态中NodePIDPressure为True，同时该节点上的容器被驱逐。关于节点驱逐，请参见节点压力驱逐。<br>若集群配置了集群节点异常报警，则节点PID不足时可收到相关报警。关于配置报警，请参见容器服务报警管理。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>执行如下命令，查看节点的最大PID数和节点当前的最大PID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl kernel.pid_max  #查看最大PID数。</span><br><span class="line">ps -eLf|awk &#x27;&#123;print $2&#125;&#x27; | sort -rn| head -n 1   #查看当前的最大PID。</span><br><span class="line">执行如下命令，查看占用PID最多的前5个进程。</span><br><span class="line">ps -elT | awk &#x27;&#123;print $4&#125;&#x27; | sort | uniq -c | sort -k1 -g | tail -5</span><br><span class="line">预期输出：</span><br><span class="line"></span><br><span class="line">#第一列为进程占用的PID数，第二列为当前进程号。</span><br><span class="line">73 9743</span><br><span class="line">75 9316</span><br><span class="line">76 2812</span><br><span class="line">77 5726</span><br><span class="line">93 5691</span><br></pre></td></tr></table></figure>
<p>根据进程号找到对应进程和所属的Pod，分析占用PID过多的原因并优化对应代码。<br>降低节点的负载。具体操作，请参见节点调度资源不足。<br>如需重启节点，可尝试重启异常节点。具体操作，请参见重启实例。</p>
<h1 id="节点FD不足"><a href="#节点FD不足" class="headerlink" title="节点FD不足"></a>节点FD不足</h1><h2 id="原因描述：-7"><a href="#原因描述：-7" class="headerlink" title="原因描述："></a>原因描述：</h2><p>节点文件句柄使用数量超过80%，具体原因与节点上进程使用情况相关打开文件未释放打开管道未释放建立网络连接未释放（pipe,eventpoll多出现在 NIO 网络编程未释放资源 —— selector.close()）创建进程调用命令未释放（Runtime.exe(…) 得到的 Process, InputStream, OutputStream 未关闭，这也会导致 pipe,eventpoll 未释放）</p>
<h2 id="解决方案：-7"><a href="#解决方案：-7" class="headerlink" title="解决方案："></a>解决方案：</h2><p>删除不需要的文件，调整应用代码，文件流等操作结束后记得关闭。或者尝试先排空再重启主机</p>
<h1 id="节点Docker-Hung"><a href="#节点Docker-Hung" class="headerlink" title="节点Docker Hung"></a>节点Docker Hung</h1><h2 id="原因描述：-8"><a href="#原因描述：-8" class="headerlink" title="原因描述："></a>原因描述：</h2><p>节点docker daemon异常，导致集群无法与之通信，伴随有docker ps、docker exec等命令hung住或异常失败</p>
<h2 id="解决方案：-8"><a href="#解决方案：-8" class="headerlink" title="解决方案："></a>解决方案：</h2><p>尝试重启docker服务，重启过程不会影响已存在容器的运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//重启节点上的docker daemon，对运行中容器没有影响</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">//查看docker日志</span><br><span class="line">journalctl -xeu docker &gt; docker.log</span><br></pre></td></tr></table></figure>
<p>如果docker服务重启后依然无法解决，可以尝试重启主机。主机重启过程会对容器有影响，谨慎操作。</p>
<h1 id="节点磁盘资源不足"><a href="#节点磁盘资源不足" class="headerlink" title="节点磁盘资源不足"></a>节点磁盘资源不足</h1><p>InvalidDiskCapacity</p>
<h2 id="原因描述：-9"><a href="#原因描述：-9" class="headerlink" title="原因描述："></a>原因描述：</h2><p>节点磁盘不足，无法分配空间给容器镜像</p>
<h2 id="解决方案：-9"><a href="#解决方案：-9" class="headerlink" title="解决方案："></a>解决方案：</h2><p>检查节点的磁盘分配情况，通常有以下一些常见情况导致磁盘占用率过高：</p>
<p>有大量日志在磁盘上没有清理；请清理日志。<br>有进程在宿主机不停的写文件；请控制文件大小，将文件存储至OSS或者NAS。<br>下载的或者是其他的静态资源文件占用空间过大；静态资源请存储至OSS或CDN。</p>
<h1 id="应用相关"><a href="#应用相关" class="headerlink" title="应用相关"></a>应用相关</h1><h1 id="Container-Restart"><a href="#Container-Restart" class="headerlink" title="Container Restart"></a>Container Restart</h1><h2 id="原因描述：-10"><a href="#原因描述：-10" class="headerlink" title="原因描述："></a>原因描述：</h2><p>该事件表示应用实例(重启)重启，一般是由于配置了健康检查且健康检查失败导致，会伴随有Readiness probe failed和Liveness probe failed等事件。健康检查失败的原因有很多，通常情况下，比如进程OOM被Kill、比如高负载情况下应用无法正常响应(例如RDS瓶颈导致应用线程全部hang住)，都可能会导致健康检查失败</p>
<h2 id="解决方案：-10"><a href="#解决方案：-10" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要结合临近的相关事件定位具体的Pod重启原因。如伴随有集群相关的Out of memory事件，参考此文档上面Out of memory事件的解决方案；其他情况下，结合应用监控或者云产品自身监控来定位问题</p>
<h1 id="The-node-had-condition-XXX"><a href="#The-node-had-condition-XXX" class="headerlink" title="The node had condition: [XXX]"></a>The node had condition: [XXX]</h1><h2 id="原因描述：-11"><a href="#原因描述：-11" class="headerlink" title="原因描述："></a>原因描述：</h2><p>该事件表示Pod由于节点上的异常情况被驱逐，比如<em>The node had condition: [DiskPressure]，</em>表示节点磁盘使用率比较高，通常会伴随有 failed to garbage collect required amount of images 和 Attempting to reclaim ephemeral-storage 等集群维度(节点)的异常事件</p>
<h2 id="解决方案：-11"><a href="#解决方案：-11" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要结合临近的相关事件定位具体的驱逐原因。对于已经被驱逐的Pod实例，可以通过kubectl get po 进行查看和手动清理</p>
<h1 id="K8S-Pod-Pending"><a href="#K8S-Pod-Pending" class="headerlink" title="K8S Pod Pending"></a>K8S Pod Pending</h1><h2 id="原因描述：-12"><a href="#原因描述：-12" class="headerlink" title="原因描述："></a>原因描述：</h2><p>该事件表示集群调度Pod被挂起，一般是由于节点资源不足以调度容器或者Volume挂载失败（比如持久化存储卷找不到）或者其他原因导致。</p>
<h2 id="解决方案：-12"><a href="#解决方案：-12" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要结合临近的相关事件定位具体的Pod挂起原因</p>
<h1 id="Readiness-probe-failed"><a href="#Readiness-probe-failed" class="headerlink" title="Readiness probe failed"></a>Readiness probe failed</h1><h2 id="原因描述：-13"><a href="#原因描述：-13" class="headerlink" title="原因描述："></a>原因描述：</h2><p>由于应用就绪探针失败而引发的异常事件。应用就绪探针失败会导致相应容器的流量被摘除，例如被动从SLB摘掉该容器的流量入口。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>需要结合应用就绪探针的配置，定位应用就绪探针失败的原因。</p>
<h1 id="Liveness-probe-failed"><a href="#Liveness-probe-failed" class="headerlink" title="Liveness probe failed"></a>Liveness probe failed</h1><h2 id="原因描述：-14"><a href="#原因描述：-14" class="headerlink" title="原因描述："></a>原因描述：</h2><p>由于应用存活探针失败而引发的异常事件。该事件可能会导致后续达到一定阈值之后，容器被动重启。具体要看应用就绪探针的配置。</p>
<h2 id="解决方案：-13"><a href="#解决方案：-13" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要结合应用存活探针的配置，定位探针检查失败的原因。</p>
<h1 id="Container-runtime-did-not-kill-the-pod-within-specified-grace-period"><a href="#Container-runtime-did-not-kill-the-pod-within-specified-grace-period" class="headerlink" title="Container runtime did not kill the pod within specified grace period."></a>Container runtime did not kill the pod within specified grace period.</h1><h2 id="原因描述：-15"><a href="#原因描述：-15" class="headerlink" title="原因描述："></a>原因描述：</h2><p>此事件表示容器没有在优雅下线的时间段内正常退出。比如如果配置了优雅下线脚本，脚本执行时长需要60s，而优雅下线时间（默认为30s）配置为30s。就会在容器下线期间触发这个事件。</p>
<h2 id="解决方案：-14"><a href="#解决方案：-14" class="headerlink" title="解决方案："></a>解决方案：</h2><p>调整优雅下线探针的配置，或者优雅下线时间的配置。</p>
<h1 id="Back-off-restarting-failed-container"><a href="#Back-off-restarting-failed-container" class="headerlink" title="Back-off restarting failed container"></a>Back-off restarting failed container</h1><h2 id="原因描述：-16"><a href="#原因描述：-16" class="headerlink" title="原因描述："></a>原因描述：</h2><p>此事件表示容器启动失败，而被再次拉起尝试启动。通常常见与应用发布过程中的容器启动失败。具体的原因常见为镜像拉取失败，或者容器启动失败（容器没有打到running状态）。</p>
<h2 id="解决方案：-15"><a href="#解决方案：-15" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要在发布页查看容器启动日志或者调度日志，进一步定位容器启动失败的原因。</p>
<h1 id="The-node-was-low-on-resource-xxxx"><a href="#The-node-was-low-on-resource-xxxx" class="headerlink" title="The node was low on resource: xxxx"></a>The node was low on resource: xxxx</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-07-21 10:24:43.000 [Event] Type: Warning, Reason: Evicted, Message: The node was low on resource: ephemeral-storage. </span><br></pre></td></tr></table></figure>
<h2 id="原因描述：-17"><a href="#原因描述：-17" class="headerlink" title="原因描述："></a>原因描述：</h2><p>该事件表示Pod由于节点上的异常情况(资源不足)被驱逐</p>
<h2 id="解决方案：-16"><a href="#解决方案：-16" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要看具体哪类资源不足，例如示例中的ephemeral-storage，表示集群节点临时存储空间不足，一般是由于磁盘使用量较大导致。请参考文档上方解决方案</p>
<p>检查节点的磁盘分配情况，通常有以下一些常见情况导致磁盘占用率过高：</p>
<p>有大量日志在磁盘上没有清理；请清理日志。<br>有进程在宿主机不停的写文件；请控制文件大小，将文件存储至OSS或者NAS。<br>下载的或者是其他的静态资源文件占用空间过大；静态资源请存储至OSS或CDN。<br>可以对系统盘进行扩容，扩大磁盘空间。</p>
<h1 id="集群DNS性能瓶颈"><a href="#集群DNS性能瓶颈" class="headerlink" title="集群DNS性能瓶颈"></a>集群DNS性能瓶颈</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>集群中的容器实例，DNS解析均依赖集群内的DNS组件，应用中业务请求的地址都需要经过集群DNS组件。例如，代码中访问RDS、REDIS、TOP api等。如果集群dns性能不足，会出现业务请求失败的问题。</p>
<p>集群DNS组件：</p>
<p>默认已安装的集群组件为coredns，副本数为2<br>可选的高性能组件为localdns</p>
<h2 id="是否有性能瓶颈"><a href="#是否有性能瓶颈" class="headerlink" title="是否有性能瓶颈"></a>是否有性能瓶颈</h2><p>应用有大量DNS请求的场景(比如连接rds，凡是涉及到域名地址解析的)<br>PHP等语言自身没有连接池特性的，或者应用自身没有DNS缓存的<br>偶尔出现域名地址无法解析错误的</p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>一、集群默认已安装的coredns组件，进行扩容。扩容比例为1&#x2F;5的节点数(如15台ecs，那么coredns数量为3)</p>
<p>二、为集群安装更高性能的localdns组件(该组件为daemonset，会在每个ECS节点起一个本地缓存)</p>
<p>一般来说，如果业务量小，扩容下coredns就足够了；如果业务量大(域名地址解析QPS高，比如访问RDS)，特别是php等不带连接池的开发语言，建议直接上localdns。如果是java等配置了连接池的应用，可以先扩容coredns观察，如果仍然有解析问题，再上localdns。</p>
<h1 id="localdns缓存原理"><a href="#localdns缓存原理" class="headerlink" title="localdns缓存原理"></a>localdns缓存原理</h1><p>NodeLocalDNS 是一个 DaemonSet，会在Kubernetes集群的每个节点上运行一个专门处理 DNS 查询请求的 Pod，该 Pod 会将集群内部域名查询请求发往 CoreDNS；将集群外部请求直接发往外部域名解析服务器。同时能够Cache所有请求。可以被看作是节点级别的高效DNS 缓存，能够大幅提高集群整体 DNS 查询的 QPS。NodeLocalDNS 会在集群的每个节点上创建一个专用的虚拟接口（接口绑定的 IP 需要通过 local_dns_ip 这个值来指定），节点上所有发往该 IP 的 DNS 查询请求都会被拦截到 NodeLocalDNS Pod 内进行处理；通过集群原有的 kube-dns 服务（该服务的 clusterIP 值需要通过kube_dns_ip来指定）来与CoreDNS进行通信。<br><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image.png" alt="image"></p>
]]></content>
  </entry>
</search>
