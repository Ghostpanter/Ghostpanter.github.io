<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ETCD使用中需要注意的问题</title>
    <url>/2022/12/29/ETCD%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98--%E8%87%AA%E5%8A%A8%E5%8E%8B%E7%BC%A9--%E6%9C%80%E5%A4%A7%E5%AD%97%E8%8A%82%E6%95%B0--%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<h1 id="ETCD使用中需要注意的问题"><a href="#ETCD使用中需要注意的问题" class="headerlink" title="ETCD使用中需要注意的问题"></a>ETCD使用中需要注意的问题</h1><p>我们在实际生产中使用ETCD存储元数据，　起初集群规模不大的时候元数据信息不多没有发现什么问题。　随着集群规模越来越大问题逐渐暴露了</p>
<p>有些实际的配置还是需要在初始化的时候就研究确定</p>
<h2 id="1-自动压缩"><a href="#1-自动压缩" class="headerlink" title="1. 自动压缩"></a>1. 自动压缩</h2><p><code>--auto-compaction-retention</code></p>
<p>由于ETCD数据存储多版本数据，随着写入的主键增加历史版本需要定时清理，　默认的历史数据是不会清理的，数据达到2G就不能写入，必须要清理压缩历史数据才能继续写入；</p>
<p>所以根据业务需求，在上生产环境之前就提前确定，历史数据多长时间压缩一次；　我们的生产环境现在升级后是默认一小时压缩一次数据。这样可以极大的保证集群稳定，减少内存和磁盘占用</p>
<h2 id="2-最大字节数"><a href="#2-最大字节数" class="headerlink" title="2. 最大字节数"></a>2. 最大字节数</h2><p><code>--max-request-bytes</code><br>etcd Raft消息最大字节数，ETCD默认该值为1.5M; 但是很多业务场景发现同步数据的时候1.5M完全没法满足要求，所以提前确定初始值很重要；　由于1.5M导致我们线上的业务无法写入元数据的问题，</p>
<p>我们紧急升级之后把该值修改为默认32M,但是官方推荐的是10M(10485760byts)，大家可以根据业务情况自己调整</p>
<blockquote>
<p>最好按照官方的默认限制来储存，单个value不要超过10M，只要不超过10M生产环境就会很稳定，一旦超过10M集群就会变的不稳定；</p>
</blockquote>
<h2 id="3-存储数据大小"><a href="#3-存储数据大小" class="headerlink" title="3. 存储数据大小"></a>3. 存储数据大小</h2><p><code>--quota-backend-bytes</code></p>
<p>ETCDdb数据大小，默认是２G,当数据达到２G的时候就不允许写入，必须对历史数据进行压缩才能继续写入；　参加1里面说的，我们启动的时候就应该提前确定大小，官方推荐是8G,这里我们也使用8G的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ 启动命令</span><br><span class="line">/usr/bin/etcd --auto-compaction-retention <span class="string">&#x27;1&#x27;</span> --max-request-bytes <span class="string">&#x27;33554432&#x27;</span> --quota-backend-bytes <span class="string">&#x27;8589934592&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kubernetes</category>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd 备份还原</title>
    <url>/2022/12/29/etcd%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F/</url>
    <content><![CDATA[<h1 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h1><h2 id="etcd-备份还原"><a href="#etcd-备份还原" class="headerlink" title="etcd 备份还原"></a>etcd 备份还原</h2><h3 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h3><p>每台的master节点 IP 和主机名需要修改<br>停止集群<br>mv   &#x2F;etc&#x2F;kubernetes&#x2F;manifests.bak</p>
<h1 id="备份原有etcd数据"><a href="#备份原有etcd数据" class="headerlink" title="备份原有etcd数据"></a>备份原有etcd数据</h1><p>mv &#x2F;u01&#x2F;local&#x2F;kube-system&#x2F;etcd &#x2F;u01&#x2F;local&#x2F;kube-system&#x2F;etcd-<code>date &#39;+%Y%m%d-%H:%M:%S&#39;</code><br>​<br>#还原第一台master<br>nerdctl  -n k8s.io run –rm <br>-v ‘&#x2F;tmp:&#x2F;tmp’ <br>-v ‘&#x2F;u01&#x2F;local&#x2F;kube-system:&#x2F;u01&#x2F;local&#x2F;kube-system’ <br>-v ‘&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd:&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd’ <br>--env ETCDCTL_API&#x3D;3 <br>‘docker.kedacom.com:15000&#x2F;etcd:3.5.0-0’ <br>&#x2F;bin&#x2F;sh -c “etcdctl snapshot restore <br>&#x2F;tmp&#x2F;etcd-snapshot-.db <br>--name node-9xct <br>--endpoints&#x3D;10.165.124.13:2379 <br>--cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.crt <br>--key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.key <br>--cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt <br>--initial-advertise-peer-urls&#x3D;<a href="https://10.165.124.13:2380/">https://10.165.124.13:2380</a> <br>--initial-cluster&#x3D;node-9xct&#x3D;<a href="https://10.165.124.13:2380,node-dfkb=https://10.165.124.14:2380,node-24ge=https://10.165.124.15:2380">https://10.165.124.13:2380,node-dfkb=https://10.165.124.14:2380,node-24ge=https://10.165.124.15:2380</a> <br>--data-dir&#x3D;&#x2F;u01&#x2F;local&#x2F;kube-system&#x2F;etcd <br>--skip-hash-check&#x3D;true”<br>nerdctl  -n k8s.io run –rm <br>-v ‘&#x2F;tmp:&#x2F;tmp’ <br>-v ‘&#x2F;u01&#x2F;local&#x2F;kube-system:&#x2F;u01&#x2F;local&#x2F;kube-system’ <br>-v ‘&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd:&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd’ <br>--env ETCDCTL_API&#x3D;3 <br>‘docker.kedacom.com:15000&#x2F;etcd:3.5.0-0’ <br>&#x2F;bin&#x2F;sh -c “etcdctl snapshot restore <br>&#x2F;tmp&#x2F;etcd-snapshot-.db <br>--name node-dfkb <br>--endpoints&#x3D;10.165.124.14:2379 <br>--cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.crt <br>--key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.key <br>--cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt <br>--initial-advertise-peer-urls&#x3D;<a href="https://10.165.124.14:2380/">https://10.165.124.14:2380</a> <br>--initial-cluster&#x3D;node-9xct&#x3D;<a href="https://10.165.124.13:2380,node-dfkb=https://10.165.124.14:2380,node-24ge=https://10.165.124.15:2380">https://10.165.124.13:2380,node-dfkb=https://10.165.124.14:2380,node-24ge=https://10.165.124.15:2380</a> <br>--data-dir&#x3D;&#x2F;u01&#x2F;local&#x2F;kube-system&#x2F;etcd <br>--skip-hash-check&#x3D;true”</p>
<p>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>​<br>nerdctl  -n k8s.io run –rm <br>-v ‘&#x2F;tmp:&#x2F;tmp’ <br>-v ‘&#x2F;u01&#x2F;local&#x2F;kube-system:&#x2F;u01&#x2F;local&#x2F;kube-system’ <br>-v ‘&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd:&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd’ <br>--env ETCDCTL_API&#x3D;3 <br>‘docker.kedacom.com:15000&#x2F;etcd:3.5.0-0’ <br>&#x2F;bin&#x2F;sh -c “etcdctl snapshot restore <br>&#x2F;tmp&#x2F;etcd-snapshot-.db <br>--name node-24ge <br>--endpoints&#x3D;10.165.124.15:2379 <br>--cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.crt <br>--key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.key <br>--cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt <br>--initial-advertise-peer-urls&#x3D;<a href="https://10.165.124.15:2380/">https://10.165.124.15:2380</a> <br>--initial-cluster&#x3D;node-9xct&#x3D;<a href="https://10.165.124.13:2380,node-dfkb=https://10.165.124.14:2380,node-24ge=https://10.165.124.15:2380">https://10.165.124.13:2380,node-dfkb=https://10.165.124.14:2380,node-24ge=https://10.165.124.15:2380</a> <br>--data-dir&#x3D;&#x2F;u01&#x2F;local&#x2F;kube-system&#x2F;etcd <br>--skip-hash-check&#x3D;true”<br>​<br>#恢复集群<br>mv &#x2F;etc&#x2F;kubernetes&#x2F;manifests.bak &#x2F;etc&#x2F;kubernetes&#x2F;manifests<br>备份<br>nerdctl  -n k8s.io run –rm <br>-v ‘&#x2F;tmp:&#x2F;tmp’ <br>-v ‘&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd:&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd’ <br>--env ETCDCTL_API&#x3D;3 <br>‘docker.kedacom.com:15000&#x2F;etcd:3.5.0-0’ <br>&#x2F;bin&#x2F;sh -c “etcdctl snapshot save <br>&#x2F;tmp&#x2F;etcd-snapshot-134.db <br>--endpoints&#x3D;10.165.24.181:2379 <br>--cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.crt <br>--key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;server.key <br>--cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt”<br>docker<br>备份<br>docker run –rm -e ETCDCTL_API&#x3D;3 -v &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd:&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd -v &#x2F;data&#x2F;etcd_backup:&#x2F;data&#x2F;etcd_backup registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;etcd:3.4.13-0 sh -c “etcdctl –endpoints&#x3D;<a href="https://11.1.100.194:2379/">https://11.1.100.194:2379</a> –cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt –cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.crt –key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.key snapshot save &#x2F;data&#x2F;etcd_backup&#x2F;etcd-snapshot-$(date +%Y-%m-%d_%H:%M:%S_%Z).db”</p>
]]></content>
      <categories>
        <category>kubernetes</category>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 的 hostNetwork 和 NetworkPolicy (网络策略)</title>
    <url>/2022/12/29/Kubernetes%20%E7%9A%84%20hostNetwork%20%E5%92%8C%20NetworkPolicy%20(%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5)/</url>
    <content><![CDATA[<h2 id="1-hostNetwork-介绍"><a href="#1-hostNetwork-介绍" class="headerlink" title="1. hostNetwork 介绍"></a>1. hostNetwork 介绍</h2><blockquote>
<p>在 k8s 中，若 <strong>pod 使用主机网络</strong>，也就是<code>hostNetwork=true</code>。则该pod会使用主机的dns以及所有网络配置，<strong>默认情况下是无法使用 k8s 自带的 dns 解析服务</strong>，但是可以修改 DNS 策略或者修改主机上的域名解析（<code>/etc/resolv.conf</code>），使主机可以用 k8s 自身的 dns 服务。一般通过 DNS 策略（<code>ClusterFirstWithHostNet</code>）来使用 k8s DNS 内部域名解析，k8s DNS 策略如下：</p>
</blockquote>
<ul>
<li><code>Default</code>：继承 Pod 所在宿主机的 DNS 设置，hostNetwork 的默认策略。</li>
<li><code>ClusterFirst（默认DNS策略）</code>：优先使用 kubernetes 环境的 dns 服务，将无法解析的域名转发到从宿主机继承的 dns 服务器。</li>
<li><code>ClusterFirstWithHostNet</code>：和 ClusterFirst 类似，对于以 <code>hostNetwork</code> 模式运行的 Pod 应明确知道使用该策略。也是可以同时解析内部和外部的域名。</li>
<li><code>None</code>：忽略 kubernetes 环境的 dns 配置，通过 spec.dnsConfig 自定义 DNS 配置。</li>
</ul>
<p>一般使用主机网络就增加如下几行即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">dnsPolicy:</span> <span class="string">&quot;ClusterFirstWithHostNet&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>『示例』：<code>hostNetwork.yaml</code></strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="comment"># 使用主机网络</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 该设置是使POD使用k8s的dns，dns配置在/etc/resolv.conf文件中</span></span><br><span class="line">      <span class="comment"># 如果不加，pod默认使用所在宿主主机使用的DNS，这样会导致容器</span></span><br><span class="line">      <span class="comment"># 内不能通过service name访问k8s集群中其他POD</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirstWithHostNet</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">metrics</span></span><br><span class="line">          <span class="comment"># 如果hostNetwork: true，hostPort必须跟containerPort一样，所以hostPort一般不写，端口也是占用宿主机上的端口。</span></span><br><span class="line">          <span class="attr">hostPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31280</span></span><br></pre></td></tr></table></figure>

<p><strong>hostPort 和 NodePort的区别：</strong></p>
<blockquote>
<p><code>hostPort</code> 只会在运行机器上开启端口， <code>NodePort</code> 是所有 Node 上都会开启端口。</p>
</blockquote>
<ul>
<li>hostPort 是由 portmap 这个 cni 提供 portMapping 能力，同时如果想使用这个能力，在配置文件中一定需要开启 portmap。</li>
<li>使用 hostPort 后，会在 iptables 的 nat 链中插入相应的规则，而且这些规则是在 KUBE-SERVICES 规则之前插入的，也就是说会优先匹配 hostPort 的规则，我们常用的 NodePort 规则其实是在 KUBE-SERVICES 之中，也排在其后。</li>
<li>hostport 可以通过 iptables 命令查看到， 但是无法在 ipvsadm 中查看到。</li>
<li>使用 lsof&#x2F;netstat 也查看不到这个端口,这是因为 hostport 是通过 iptables 对请求中的目的端口进行转发的，并不是在主机上通过端口监听。</li>
<li><strong>在生产环境中不建议使用 hostPort</strong>。</li>
</ul>
<h2 id="2-K8s-网络策略-NetworkPolicy"><a href="#2-K8s-网络策略-NetworkPolicy" class="headerlink" title="2. K8s 网络策略 NetworkPolicy"></a>2. K8s 网络策略 NetworkPolicy</h2><p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202212290837401.png"></p>
<blockquote>
<p>如果你希望在 IP 地址或端口层面（OSI 第 3 层或第 4 层）控制网络流量， 则你可以考虑为集群中特定应用使用 Kubernetes 网络策略（<code>NetworkPolicy</code>）。**<code>NetworkPolicy</code> 是一种以应用为中心的结构，允许你设置如何允许 Pod 与网络上的各类网络“实体”** 通信。官方文档</p>
</blockquote>
<p>网络策略是通过<strong>网络插件</strong>来实现，常用的网络插件<code>Flannel</code>和<code>Calico</code>：</p>
<ul>
<li><code>Flannel</code>：只能提供网络通讯，<strong>不提供网络策略</strong>，如果需要使用网络策略，建议使用下面的 Calico，关于 Flannel 更详细的介绍和安装可以参考我这篇文章：Kubernetes（k8s）CNI（flannel）网络模型原理。</li>
<li><code>Calico</code>：<strong>支持丰富的网络策略</strong>，Calico以其性能、灵活性而闻名。后面也会出相关文章详细介绍 Calico。</li>
</ul>
<p>更多了解更多的网络策略，可以参考官方文档：<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></p>
<p>Pod 可以通信的 Pod 是通过如下三个标识符的组合来辩识的：</p>
<ul>
<li>其他被允许的 Pods（例外：Pod 无法阻塞对自身的访问）</li>
<li>被允许的名字空间</li>
<li>IP 组块（例外：与 Pod 运行所在的节点的通信总是被允许的， 无论 Pod 或节点的 IP 地址）</li>
</ul>
<h2 id="3-Pod-隔离的两种类型"><a href="#3-Pod-隔离的两种类型" class="headerlink" title="3. Pod 隔离的两种类型"></a>3. Pod 隔离的两种类型</h2><p>Pod 有两种隔离: <strong>出口的隔离</strong>和<strong>入口的隔离</strong>。默认情况下，出口和入口都是非隔离的。</p>
<ul>
<li><strong>网络策略是相加的</strong>，所以不会产生冲突。如果策略适用于 Pod 某一特定方向的流量， Pod 在对应方向所允许的连接是适用的网络策略所允许的集合。因此，评估的顺序不影响策略的结果。</li>
<li>要允许从源 Pod 到目的 Pod 的连接，源 Pod 的出口策略和目的 Pod 的入口策略都需要允许连接。如果任何一方不允许连接，建立连接将会失败。</li>
</ul>
<h2 id="4-NetworkPolicy-资源"><a href="#4-NetworkPolicy-资源" class="headerlink" title="4. NetworkPolicy 资源"></a>4. NetworkPolicy 资源</h2><h3 id="4-1-NetworkPolicy-示例演示"><a href="#4-1-NetworkPolicy-示例演示" class="headerlink" title="4.1 NetworkPolicy 示例演示"></a>4.1 NetworkPolicy 示例演示</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">        <span class="attr">except:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">project:</span> <span class="string">myproject</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">role:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">5978</span></span><br></pre></td></tr></table></figure>

<p>必需字段：与所有其他的 Kubernetes 配置一样，NetworkPolicy 需要 apiVersion、 kind 和 metadata 字段。关于配置文件操作的一般信息， 请参考配置 Pod 以使用 ConfigMap 和对象管理。</p>
<ul>
<li><code>spec</code>：NetworkPolicy 规约 中包含了在一个名字空间中定义特定网络策略所需的所有信息。</li>
<li><code>podSelector</code>：每个 NetworkPolicy 都包括一个 podSelector， 它对该策略所适用的一组 Pod 进行选择。示例中的策略选择带有 “role&#x3D;db” 标签的 Pod。空的 podSelector 选择名字空间下的所有 Pod。</li>
<li><code>policyTypes</code>：每个 NetworkPolicy 都包含一个 policyTypes 列表，其中包含 Ingress 或 Egress 或两者兼具。policyTypes 字段表示给定的策略是应用于进入所选 Pod 的入站流量还是来自所选 Pod 的出站流量，或两者兼有。如果 NetworkPolicy 未指定 policyTypes 则默认情况下始终设置 Ingress；如果 NetworkPolicy 有任何出口规则的话则设置 Egress。</li>
<li><code>ingress</code>：每个 NetworkPolicy 可包含一个 ingress 规则的白名单列表。每个规则都允许同时匹配 from 和 ports 部分的流量。示例策略中包含一条简单的规则：它匹配某个特定端口，来自三个来源中的一个，第一个通过 ipBlock 指定，第二个通过 namespaceSelector 指定，第三个通过 podSelector 指定。</li>
<li><code>egress</code>：每个 NetworkPolicy 可包含一个 egress 规则的白名单列表。每个规则都允许匹配 to 和 port 部分的流量。该示例策略包含一条规则， 该规则将指定端口上的流量匹配到 10.0.0.0&#x2F;24 中的任何目的地。</li>
</ul>
<p>所以，该网络策略示例:</p>
<ul>
<li><p>隔离 “default” 名字空间下 “role&#x3D;db” 的 Pod （如果它们不是已经被隔离的话）。</p>
</li>
<li><p>（Ingress 规则）允许以下 Pod 连接到 “default” 名字空间下的带有 “role&#x3D;db” 标签的所有 Pod 的 6379 TCP 端口：</p>
</li>
<li><ul>
<li>“default” 名字空间下带有 “role&#x3D;frontend” 标签的所有 Pod</li>
<li>带有 “project&#x3D;myproject” 标签的所有名字空间中的 Pod</li>
<li>IP 地址范围为 172.17.0.0–172.17.0.255 和 172.17.2.0–172.17.255.255 （即，除了 172.17.1.0&#x2F;24 之外的所有 172.17.0.0&#x2F;16）</li>
</ul>
</li>
<li><p>（Egress 规则）允许 “default” 命名空间中任何带有标签 “role&#x3D;db” 的 Pod 到 CIDR 10.0.0.0&#x2F;24 下 5978 TCP 端口的连接。</p>
</li>
</ul>
<h3 id="4-2-选择器-to-和-from-的行为"><a href="#4-2-选择器-to-和-from-的行为" class="headerlink" title="4.2 选择器 to 和 from 的行为"></a>4.2 选择器 to 和 from 的行为</h3><p>可以在 ingress 的 from 部分或 egress 的 to 部分中指定四种选择器：</p>
<ul>
<li><code>podSelector</code>：此选择器将在与 NetworkPolicy 相同的名字空间中选择特定的 Pod，应将其允许作为入站流量来源或出站流量目的地。</li>
<li><code>namespaceSelector</code>：此选择器将选择特定的名字空间，应将所有 Pod 用作其入站流量来源或出站流量目的地。</li>
<li><code>namespaceSelector</code> 和 <code>podSelector</code>：一个指定 namespaceSelector 和 podSelector 的 to&#x2F;from 条目选择特定名字空间中的特定 Pod。注意使用正确的 YAML 语法；下面的策略：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ingress:</span><br><span class="line">- from:</span><br><span class="line">  - namespaceSelector:</span><br><span class="line">      matchLabels:</span><br><span class="line">        user: alice</span><br><span class="line">    podSelector:</span><br><span class="line">      matchLabels:</span><br><span class="line">        role: client</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 from 数组中仅包含一个元素，只允许来自标有 role&#x3D;client 的 Pod 且该 Pod 所在的名字空间中标有 user&#x3D;alice 的连接。但是 这项 策略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> ingress:</span><br><span class="line"> - from:</span><br><span class="line">   - namespaceSelector:</span><br><span class="line">       matchLabels:</span><br><span class="line">         user: alice</span><br><span class="line">   - podSelector:</span><br><span class="line">       matchLabels:</span><br><span class="line">         role: client</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>这里只是把官网的摘了一部分，官网介绍的比较清楚，这里就不粘贴复制了，小伙伴可以参考官方文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/">https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/</a></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><ul>
<li>在 k8s 上网络策略是<strong>白名单机制</strong>，所谓白名单机制是指，只有明确定义的策略才会被允许放行，默认没有指定的规则就是拒绝的，即条件不匹配的都会被拒绝。</li>
<li>其次对于 ingress 或 egress 来说，对应的 <code>from</code> 或 <code>to</code> 都是用来指定访问端或被访问端的信息。</li>
<li>如果我们在对应的字段中<strong>没有定义 namespaceSelector 字段</strong>，<strong>默认 ingress 或 egrss 会匹配当前 netpol 所在名称空间</strong>，即在没有明确指定 namespaceSelector 字段时，对应的其他条件都是针对当前 netpol 所在名称空间。</li>
<li><strong>多个条件组合</strong>使用，如果多个条件都在一个列表中，则表示多个条件间是与关系，即指定的条件需要同时满足对应策略才会放行。</li>
<li>如果<strong>多个条件不再同一个列表中</strong>，则多个条件之间是或关系，即满足其中一个条件都会被对应策略放行。</li>
</ul>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Helm进阶使用</title>
    <url>/2022/12/29/helm%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Helm 针对 Kubernetes 的 Helm 包管理器。Helm 的一般操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索 chart</span></span><br><span class="line">helm search: </span><br><span class="line"><span class="comment"># 下载 chart 到本地目录查看</span></span><br><span class="line">helm pull:    </span><br><span class="line"><span class="comment"># 上传 chart 到 Kubernetes</span></span><br><span class="line">helm install: </span><br><span class="line"><span class="comment"># 列出已发布的 chart</span></span><br><span class="line">helm list:      </span><br><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">helm --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/640-20220909090236244.png" alt="图片"><br>官方文档：<a href="https://helm.sh/zh/docs/helm/helm/">https://helm.sh/zh/docs/helm/helm/</a><br><a href="https://blog.kkun.site/2022/12/29/helm%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%AD%E6%B3%95/">Helm 架构和基础语法讲解可以参考这篇文章</a></p>
<h2 id="二、Helm-仓库（helm-repo）"><a href="#二、Helm-仓库（helm-repo）" class="headerlink" title="二、Helm 仓库（helm repo）"></a>二、Helm 仓库（helm repo）</h2><blockquote>
<p><a href="https://blog.kkun.site/2022/12/29/helm%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%AD%E6%B3%95/">添加、列出、删除、更新和索引 chart 仓库。</a></p>
</blockquote>
<h3 id="1）添加-chart-仓库"><a href="#1）添加-chart-仓库" class="headerlink" title="1）添加 chart 仓库"></a>1）添加 chart 仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add bitnami https://charts.bitnami.com/bitnami</span><br></pre></td></tr></table></figure>

<h3 id="2）列出已添加的仓库"><a href="#2）列出已添加的仓库" class="headerlink" title="2）列出已添加的仓库"></a>2）列出已添加的仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo list</span><br></pre></td></tr></table></figure>

<h3 id="3）从-chart-仓库中更新本地可用-chart-的信息"><a href="#3）从-chart-仓库中更新本地可用-chart-的信息" class="headerlink" title="3）从 chart 仓库中更新本地可用 chart 的信息"></a>3）从 chart 仓库中更新本地可用 chart 的信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo update bitnami</span><br></pre></td></tr></table></figure>

<h3 id="4）删除一个或多个仓库"><a href="#4）删除一个或多个仓库" class="headerlink" title="4）删除一个或多个仓库"></a>4）删除一个或多个仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo remove bitnami</span><br></pre></td></tr></table></figure>

<h2 id="三、创建-chart（helm-create）"><a href="#三、创建-chart（helm-create）" class="headerlink" title="三、创建 chart（helm create）"></a>三、创建 chart（helm create）</h2><blockquote>
<p>使用给定名称创建新的 chart，该命令创建 chart 目录和 chart 用到的公共文件目录。</p>
</blockquote>
<p>比如’helm create foo’会创建一个目录结构看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ helm create foo</span><br><span class="line">foo/</span><br><span class="line">├── .helmignore   <span class="comment"># Contains patterns to ignore when packaging Helm charts.</span></span><br><span class="line">├── Chart.yaml    <span class="comment"># Information about your chart</span></span><br><span class="line">├── values.yaml   <span class="comment"># The default values for your templates</span></span><br><span class="line">├── charts/       <span class="comment"># Charts that this chart depends on</span></span><br><span class="line">└── templates/    <span class="comment"># The template files</span></span><br><span class="line">    └── tests/    <span class="comment"># The test files</span></span><br></pre></td></tr></table></figure>

<h2 id="四、chart-包安装（helm-install）"><a href="#四、chart-包安装（helm-install）" class="headerlink" title="四、chart 包安装（helm install）"></a>四、chart 包安装（helm install）</h2><blockquote>
<p>该命令用于<strong>安装 chart 包</strong>。安装参数必须是 chart 的引用，一个<strong>打包后的 chart 路径</strong>，<strong>未打包的 chart 目录或者是一个 URL</strong>。</p>
</blockquote>
<p>要重写 chart 中的值，使用<code>--values</code>参数传递一个文件或者使用<code>--set</code>参数在命令行传递配置，强制使用字符串要用<code>--set-string</code>。当值本身对于命令行太长或者是动态生成的时候，可以使用<code>--set-file</code>设置独立的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install -f myvalues.yaml myredis ./redis</span><br><span class="line"></span><br><span class="line">helm install --<span class="built_in">set</span> name=prod myredis ./redis</span><br><span class="line"></span><br><span class="line">helm install --set-string long_int=1234567890 myredis ./redis</span><br><span class="line"></span><br><span class="line">helm install --set-file my_script=dothings.sh myredis ./redis</span><br></pre></td></tr></table></figure>

<h2 id="五、管理-chart-依赖（helm-dependency）"><a href="#五、管理-chart-依赖（helm-dependency）" class="headerlink" title="五、管理 chart 依赖（helm dependency）"></a>五、管理 chart 依赖（helm dependency）</h2><ul>
<li><a href="https://blog.kkun.site/2022/12/29/helm%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%AD%E6%B3%95/">Helm chart 将依赖存储在’charts&#x2F;‘。对于 chart 开发者，管理依赖比声明了所有依赖的’Chart.yaml’文件更容易。</a></li>
<li><a href="https://blog.kkun.site/2022/12/29/helm%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%AD%E6%B3%95/">依赖命令对该文件进行操作，使得存储在’charts&#x2F;‘目录的需要的依赖和实际依赖之间同步变得很容易。</a></li>
</ul>
<p><a href="https://blog.kkun.site/2022/12/29/helm%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%AD%E6%B3%95/">比如 Chart.yaml 声明了两个依赖：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Chart.yaml</span></span><br><span class="line">dependencies:</span><br><span class="line">- name: nginx</span><br><span class="line">    version: <span class="string">&quot;1.2.3&quot;</span></span><br><span class="line">    repository: <span class="string">&quot;https://example.com/charts&quot;</span></span><br><span class="line">- name: memcached</span><br><span class="line">    version: <span class="string">&quot;3.2.1&quot;</span></span><br><span class="line">    repository: <span class="string">&quot;https://another.example.com/charts&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>name</code> 是 chart 名称，<strong>必须匹配<code>Chart.yaml</code>文件中名称</strong>。</li>
<li><code>version</code> 字段应该包含一个语义化的版本或版本范围。</li>
</ul>
<p>从 2.2.0 开始，仓库可以被定义为本地存储的依赖 chart 的目录路径。路径应该以”file:&#x2F;&#x2F;“前缀开头，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Chart.yaml</span></span><br><span class="line">dependencies:</span><br><span class="line">- name: nginx</span><br><span class="line">    version: <span class="string">&quot;1.2.3&quot;</span></span><br><span class="line">    repository: <span class="string">&quot;file://../dependency_chart/nginx&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="1）列举指定-chart-的依赖"><a href="#1）列举指定-chart-的依赖" class="headerlink" title="1）列举指定 chart 的依赖"></a>1）列举指定 chart 的依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helm dependency list CHART</span></span><br><span class="line">helm dependency list wordpress</span><br></pre></td></tr></table></figure>

<h3 id="2）依赖升级"><a href="#2）依赖升级" class="headerlink" title="2）依赖升级"></a>2）依赖升级</h3><p>基于 Chart.yaml 内容升级 charts&#x2F;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helm dependency update CHART [flags]</span></span><br><span class="line">helm dependency update wordpress</span><br></pre></td></tr></table></figure>

<h2 id="六、Helm-列表（helm-list）"><a href="#六、Helm-列表（helm-list）" class="headerlink" title="六、Helm 列表（helm list）"></a>六、Helm 列表（helm list）</h2><ul>
<li><strong>列举发布版本</strong>，该命令会列举出指定命名空间的所有发布版本，(如果没有指定命名空间，会使用当前命名空间)。</li>
<li><strong>默认</strong>情况下，只会<strong>列举出部署的或者失败的发布</strong>，像<code>--uninstalled</code>或者<code>--all</code>会修改默认行为。这些参数可以组合使用：<code>--uninstalled --failed</code>。</li>
<li>默认情况下，最多返回<code>256</code>项，使用<code>--max</code>限制数量，<code>--max</code>设置为<strong>0 不会返回所有结果</strong>，而是返回服务器默认值，可能要比 256 更多。同时使用<code>--max</code>和<code>--offset</code>参数可以<strong>翻页</strong>显示。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -A显示所有</span></span><br><span class="line">helm list --max=10 --offset=2 -A</span><br></pre></td></tr></table></figure>

<h2 id="七、升级版本（helm-upgrade）"><a href="#七、升级版本（helm-upgrade）" class="headerlink" title="七、升级版本（helm upgrade）"></a>七、升级版本（helm upgrade）</h2><blockquote>
<p>该命令将发布升级到新版的 chart。升级参数必须是发布和 chart。chart 参数可以是：<code>chart引用(&#39;example/mariadb&#39;)</code>，<code>chart目录路径</code>，打包的 chart 或者完整 URL。对于 chart 引用，除非使用’–version’参数指定，否则会使用最新版本。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade --<span class="built_in">set</span> foo=bar --<span class="built_in">set</span> foo=newbar redis ./redis</span><br></pre></td></tr></table></figure>

<h2 id="八、发布历史（helm-history）"><a href="#八、发布历史（helm-history）" class="headerlink" title="八、发布历史（helm history）"></a>八、发布历史（helm history）</h2><blockquote>
<p>检索发布历史，打印给定版本的历史修订。<strong>默认</strong>会返回最大的<code>256</code>个历史版本。设置<code>--max</code>配置返回历史列表的最大长度。</p>
</blockquote>
<p>历史发布集合会被打印成格式化的表格，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ helm <span class="built_in">history</span> angry-bird</span><br><span class="line">REVISION    UPDATED                     STATUS          CHART             APP VERSION     DESCRIPTION</span><br><span class="line">1           Mon Oct 3 10:15:13 2016     superseded      alpine-0.1.0      1.0             Initial install</span><br><span class="line">2           Mon Oct 3 10:15:13 2016     superseded      alpine-0.1.0      1.0             Upgraded successfully</span><br><span class="line">3           Mon Oct 3 10:15:13 2016     superseded      alpine-0.1.0      1.0             Rolled back to 2</span><br><span class="line">4           Mon Oct 3 10:15:13 2016     deployed        alpine-0.1.0      1.0             Upgraded successfully</span><br></pre></td></tr></table></figure>

<h2 id="九、回滚版本（helm-rollback）"><a href="#九、回滚版本（helm-rollback）" class="headerlink" title="九、回滚版本（helm rollback）"></a>九、回滚版本（helm rollback）</h2><blockquote>
<p>回滚发布到上一个版本，回滚命令的第一个参数是发布的名称，第二是修订（版本）号，如果省略此参数，会回滚到上一个版本。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helm rollback &lt;RELEASE&gt; [REVISION] [flags]</span></span><br><span class="line"><span class="comment"># 先查看历史版本</span></span><br><span class="line">helm <span class="built_in">history</span> myharbor -n harbor</span><br><span class="line"><span class="comment"># 不指定版本就回退上个版本</span></span><br><span class="line">helm rollback myharbor 1 -n harbor</span><br><span class="line">helm rollback myharbor -n harbor</span><br></pre></td></tr></table></figure>

<h2 id="十、展示-chart（helm-show）"><a href="#十、展示-chart（helm-show）" class="headerlink" title="十、展示 chart（helm show）"></a>十、展示 chart（helm show）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helm show all [CHART] [flags]</span></span><br><span class="line"><span class="comment"># 该命令检查chart(目录、文件或URL)并显示所有的内容（values.yaml, Chart.yaml, README）</span></span><br><span class="line">helm show all mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># helm show values [CHART] [flags]</span></span><br><span class="line"><span class="comment"># 该命令检查chart(目录、文件或URL)并显示values.yaml文件的内容</span></span><br><span class="line">helm show values mysql</span><br></pre></td></tr></table></figure>

<h2 id="十一、拉取-chart（helm-pull）"><a href="#十一、拉取-chart（helm-pull）" class="headerlink" title="十一、拉取 chart（helm pull）"></a>十一、拉取 chart（helm pull）</h2><p>从仓库下载并（可选）在本地目录解压。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helm pull [chart URL | repo/chartname] [...] [flags]</span></span><br><span class="line"><span class="comment"># 仅下载</span></span><br><span class="line">helm pull bitnami/redis</span><br><span class="line"><span class="comment"># 下载并解压到当前目录</span></span><br><span class="line">helm pull bitnami/redis --untar</span><br></pre></td></tr></table></figure>

<h2 id="十二、Helm-打包（helm-package）"><a href="#十二、Helm-打包（helm-package）" class="headerlink" title="十二、Helm 打包（helm package）"></a>十二、Helm 打包（helm package）</h2><ul>
<li><strong>将 chart 目录打包到 chart 归档中</strong>，该命令将 chart 打包成一个 chart 版本包文件。如果给定路径，就会在该路径中查找 chart（必须包含 Chart.yaml 文件）然后将目录打包。</li>
<li>要签名一个 chart，使用<code>--sign</code>参数，在大多数场景中，也要提供<code>--keyring path/to/secret/keys</code>和<code>--key keyname</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm package mysql/</span><br><span class="line"><span class="comment"># Successfully packaged chart and saved it to: /opt/k8s/helm/mysql-9.3.1.tgz</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果<strong>想忽略 helm 中的文件</strong>，可以在<code>.helmignore</code>进行匹配，该.helmignore 文件支持 Unix shell 全局匹配，相对路径匹配和否定（以！前缀反向匹配）。每行仅考虑一种模式。示例如下：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .helmignore</span></span><br><span class="line">.git</span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">temp?</span><br></pre></td></tr></table></figure>

<h2 id="十三、推送-chart-到-harbor（helm-cm-push）"><a href="#十三、推送-chart-到-harbor（helm-cm-push）" class="headerlink" title="十三、推送 chart 到 harbor（helm cm-push）"></a>十三、推送 chart 到 harbor（helm cm-push）</h2><blockquote>
<p>将 chart 推送到远程。</p>
</blockquote>
<h3 id="1）在线安装"><a href="#1）在线安装" class="headerlink" title="1）在线安装"></a>1）在线安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm plugin install https://github.com/chartmuseum/helm-push</span><br></pre></td></tr></table></figure>

<h3 id="2）离线安装"><a href="#2）离线安装" class="headerlink" title="2）离线安装"></a>2）离线安装</h3><p>下载地址：<a href="https://github.com/chartmuseum/helm-push/tags">https://github.com/chartmuseum/helm-push/tags</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、下载安装包</span></span><br><span class="line">wget https://github.com/chartmuseum/helm-push/releases/tag/v0.10.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、查看helm的plugin路径：helm env</span></span><br><span class="line">helm <span class="built_in">env</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、在该路径下创建helm-push文件夹，并将安装包拷贝到该文件夹下解压即可</span></span><br><span class="line"><span class="built_in">mkdir</span> /root/.local/share/helm/plugins/helm-push</span><br><span class="line"></span><br><span class="line">wget https://github.com/chartmuseum/helm-push/releases/download/v0.10.3/helm-push_0.10.3_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar zxvf /root/.local/share/helm/plugins/helm-push/helm-push_0.10.3_linux_amd64.tar.gz -C /root/.local/share/helm/plugins/helm-push</span><br></pre></td></tr></table></figure>

<p>查看插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm plugin list</span><br></pre></td></tr></table></figure>

<h3 id="3）helm-增加-harbor-repo"><a href="#3）helm-增加-harbor-repo" class="headerlink" title="3）helm 增加 harbor repo"></a>3）helm 增加 harbor repo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chartrepo，固定参数，bigdata自定义项目</span></span><br><span class="line">helm repo add local-harbor --username=admin --password=Harbor12345 https://myharbor.com/chartrepo/bigdata/ --ca-file /opt/k8s/helm/ca.crt</span><br></pre></td></tr></table></figure>

<p>证书直接在 harbor 上下载<br><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/640-20220909085720442.png" alt="图片"></p>
<h3 id="4）示例演示"><a href="#4）示例演示" class="headerlink" title="4）示例演示"></a>4）示例演示</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">helm cm-push --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送，接【目录】</span></span><br><span class="line">helm cm-push mysql/ local-harbor --ca-file /opt/k8s/helm/ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送，接【压缩包】</span></span><br><span class="line">helm cm-push wordpress-15.1.5.tgz local-harbor --ca-file /opt/k8s/helm/ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送，指定版本，--version</span></span><br><span class="line">helm cm-push mychart/ --version=<span class="string">&quot;1.2.3&quot;</span> local-harbor --ca-file /opt/k8s/helm/ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制推送，--force</span></span><br><span class="line">helm cm-push --force mychart-0.3.2.tgz local-harbor</span><br></pre></td></tr></table></figure>

<p>查看<br><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/640-20220909090058216.png" alt="图片"></p>
<h2 id="十四、搜索-hub（helm-search-hub）"><a href="#十四、搜索-hub（helm-search-hub）" class="headerlink" title="十四、搜索 hub（helm search hub）"></a>十四、搜索 hub（helm search hub）</h2><p>在Artifact Hub或自己的 hub 实例中搜索 chart。</p>
<p><code>Artifact Hub</code> 是<strong>基于 web 页面的应用</strong>，支持 CNCF 项目的查找、安装和发布包及配置项，包括了公开发布的 Helm chart。它是 CNCF 的沙盒项目。可以访问<a href="https://artifacthub.io/">https://artifacthub.io/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不带参数，列出所有</span></span><br><span class="line">helm search hub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定chart</span></span><br><span class="line">helm search hub mysql</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/640-20220909085720501.png" alt="图片"></p>
<h2 id="十五、搜索仓库（helm-search-repo）"><a href="#十五、搜索仓库（helm-search-repo）" class="headerlink" title="十五、搜索仓库（helm search repo）"></a>十五、搜索仓库（helm search repo）</h2><blockquote>
<p>用 chart 中关键字搜索仓库，搜索会读取系统上配置的所有仓库，并查找匹配。搜索这些仓库会使用存储在系统中的元数据。它会展示找到<strong>最新稳定版本的 chart</strong>。如果指定了<code>--devel</code>参数，输出会包括预发布版本。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Search for stable release versions matching the keyword &quot;nginx&quot;</span></span><br><span class="line">$ helm search repo nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Search for release versions matching the keyword &quot;nginx&quot;, including pre-release versions</span></span><br><span class="line">$ helm search repo nginx --devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># Search for the latest stable release for nginx-ingress with a major version of 1</span></span><br><span class="line">$ helm search repo nginx-ingress --version ^1.0.0</span><br></pre></td></tr></table></figure>

<h2 id="十六、验证-chart（helm-lint）"><a href="#十六、验证-chart（helm-lint）" class="headerlink" title="十六、验证 chart（helm lint）"></a>十六、验证 chart（helm lint）</h2><blockquote>
<p>该命令使用一个 chart 路径并运行一系列的<strong>测试来验证 chart 的格式是否正确</strong>。如果遇到引起 chart 安装失败的情况，会触发[ERROR]信息，如果遇到违反惯例或建议的问题，会触发[WARNING]。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helm lint PATH [flags]</span></span><br><span class="line">helm lint ./mysql</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/640-20220909085720509.png" alt="图片"><br><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202212291321175.png" alt="图片"></p>
<h2 id="十七、常用命令总结"><a href="#十七、常用命令总结" class="headerlink" title="十七、常用命令总结"></a>十七、常用命令总结</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm version                            // 查看helm版本</span><br><span class="line">helm create xxx                         // 创建一个xxx charts</span><br><span class="line">helm lint ./xxx                         // 检查包的格式或信息是否有问题</span><br><span class="line">helm install xxx1 ./xxx                 // 部署安装xxx，设置名称为xxx1</span><br><span class="line">helm list                               // 列出已经部署的charts</span><br><span class="line">helm <span class="built_in">history</span>                            // 发布历史</span><br><span class="line">helm upgrade                            // 更新版本</span><br><span class="line">helm rollback                           // 回滚版本</span><br><span class="line">helm package ./xxx                      // 打包charts</span><br><span class="line">helm repo add --username admin --password password myharbor xxx  // 增加repo</span><br><span class="line">helm uninstall xxx1                     // 卸载删除xxx1</span><br><span class="line">helm pull                                // 拉取chart包</span><br><span class="line">helm cm-push                            // 推送chart包</span><br><span class="line">helm repo update                        // 更新仓库资源</span><br><span class="line">helm search hub                         // 从 Artifact Hub 中查找并列出 helm charts。Artifact Hub中存放了大量不同的仓库</span><br><span class="line">helm search repo                        // 从你添加（使用 helm repo add）到本地 helm 客户端中的仓库中进行查找。该命令基于本地数据进行搜索，无需连接互联网</span><br></pre></td></tr></table></figure>

<p>Helm 常用命令（chart 安装、升级、回滚、卸载等操作）就先到这里，</p>
]]></content>
      <categories>
        <category>kubernetes</category>
        <category>Helm</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>Helm</tag>
      </tags>
  </entry>
  <entry>
    <title>Helm基础使用及语法</title>
    <url>/2022/12/29/helm%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><blockquote>
<p>我们可以将 Helm 看作 Kubernetes 下的 apt-get&#x2F;yum。Helm 是 kubernetes 的包管理器，helm 仓库里面只有配置清单文件,而没有镜像,镜像还是由镜像仓库来提供,比如 hub.docker.com、私有仓库。</p>
</blockquote>
<p>官方文档：</p>
<blockquote>
<p><a href="https://v3.helm.sh/zh/docs/">https://v3.helm.sh/zh/docs/</a></p>
</blockquote>
<h2 id="二、Helm-架构"><a href="#二、Helm-架构" class="headerlink" title="二、Helm 架构"></a>二、Helm 架构</h2><p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202209071137580.png" alt="图片"></p>
<h2 id="三、Helm-安装"><a href="#三、Helm-安装" class="headerlink" title="三、Helm 安装"></a>三、Helm 安装</h2><p>下载地址：</p>
<blockquote>
<p><a href="https://github.com/helm/helm/releases">https://github.com/helm/helm/releases</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载包</span></span><br><span class="line">$  wget https://get.helm.sh/helm-v3.9.4-linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 解压压缩包</span></span><br><span class="line">$ tar -xf helm-v3.9.4-linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 制作软连接</span></span><br><span class="line">$ <span class="built_in">ln</span> -s /opt/helm/linux-amd64/helm /usr/local/bin/helm</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">$ helm version</span><br><span class="line">$ helm <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h2 id="四、Helm-组件及相关术语"><a href="#四、Helm-组件及相关术语" class="headerlink" title="四、Helm 组件及相关术语"></a>四、Helm 组件及相关术语</h2><ul>
<li><code>Helm</code>——Helm 是一个命令行下的<strong>客户端工具</strong>。主要用于 Kubernetes 应用程序 Chart 的创建、打包、发布以及创建和管理本地和远程的 Chart 仓库。</li>
<li><code>Chart</code>——Chart 代表着 <strong>Helm 包</strong>。它包含在 Kubernetes 集群内部运行应用程序，工具或服务所需的所有资源定义。你可以把它看作是 Homebrew formula，Apt dpkg，或 Yum RPM 在 Kubernetes 中的等价物。</li>
<li><code>Release</code>——Release 是运行在 Kubernetes 集群中的 <strong>chart 的实例</strong>。一个 chart 通常可以在同一个集群中安装多次。每一次安装都会创建一个新的 release。</li>
<li><code>Repoistory</code>——Repository（<strong>仓库</strong>） 是用来存放和共享 charts 的地方。它就像 Perl 的 CPAN 档案库网络 或是 Fedora 的 软件包仓库，只不过它是供 Kubernetes 包所使用的。</li>
</ul>
<h2 id="五、Helm-Chart-详解"><a href="#五、Helm-Chart-详解" class="headerlink" title="五、Helm Chart 详解"></a>五、Helm Chart 详解</h2><h3 id="1）Chart-目录结构"><a href="#1）Chart-目录结构" class="headerlink" title="1）Chart 目录结构"></a>1）Chart 目录结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过helm create命令创建一个新的chart包</span></span><br><span class="line">helm create nginx</span><br><span class="line">tree nginx</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202209071137553.png" alt="图片"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx/</span><br><span class="line">├── charts  <span class="comment">#依赖其他包的charts文件</span></span><br><span class="line">├── Chart.yaml <span class="comment"># 该chart的描述文件,包括ico地址,版本信息等</span></span><br><span class="line">├── templates  <span class="comment"># #存放k8s模板文件目录</span></span><br><span class="line">│   ├── deployment.yaml <span class="comment"># 创建k8s资源的yaml 模板</span></span><br><span class="line">│   ├── _helpers.tpl <span class="comment"># 下划线开头的文件,可以被其他模板引用</span></span><br><span class="line">│   ├── hpa.yaml <span class="comment"># 弹性扩缩容，配置服务资源CPU 内存</span></span><br><span class="line">│   ├── ingress.yaml <span class="comment"># ingress 配合service域名访问的配置</span></span><br><span class="line">│   ├── NOTES.txt <span class="comment"># 说明文件,helm install之后展示给用户看的内容</span></span><br><span class="line">│   ├── serviceaccount.yaml <span class="comment"># 服务账号配置</span></span><br><span class="line">│   ├── service.yaml <span class="comment"># kubernetes Serivce yaml 模板</span></span><br><span class="line">│   └── tests <span class="comment"># 测试模块</span></span><br><span class="line">│       └── test-connection.yaml</span><br><span class="line">└── values.yaml <span class="comment"># 给模板文件使用的变量</span></span><br></pre></td></tr></table></figure>

<p>可能有写包还会有以下几个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wordpress/</span><br><span class="line">...</span><br><span class="line">  LICENSE             <span class="comment"># 可选: 包含chart许可证的纯文本文件</span></span><br><span class="line">  README.md           <span class="comment"># 可选: 可读的README文件</span></span><br><span class="line">  values.schema.json  <span class="comment"># 可选: 一个使用JSON结构的values.yaml文件</span></span><br><span class="line">  charts/             <span class="comment"># 包含chart依赖的其他chart</span></span><br><span class="line">  crds/               <span class="comment"># 自定义资源的定义</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2）Chart-yaml-文件"><a href="#2）Chart-yaml-文件" class="headerlink" title="2）Chart.yaml 文件"></a>2）Chart.yaml 文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: chart API 版本 （必需）</span><br><span class="line">name: chart名称 （必需）</span><br><span class="line">version: chart 版本，语义化2 版本（必需）</span><br><span class="line">kubeVersion: 兼容Kubernetes版本的语义化版本（可选）</span><br><span class="line">description: 一句话对这个项目的描述（可选）</span><br><span class="line"><span class="built_in">type</span>: chart类型 （可选）</span><br><span class="line">keywords:</span><br><span class="line">  - 关于项目的一组关键字（可选）</span><br><span class="line">home: 项目home页面的URL （可选）</span><br><span class="line">sources:</span><br><span class="line">  - 项目源码的URL列表（可选）</span><br><span class="line">dependencies: <span class="comment"># chart 必要条件列表 （可选）</span></span><br><span class="line">  - name: chart名称 (nginx)</span><br><span class="line">    version: chart版本 (<span class="string">&quot;1.2.3&quot;</span>)</span><br><span class="line">    repository: （可选）仓库URL (<span class="string">&quot;https://example.com/charts&quot;</span>) 或别名 (<span class="string">&quot;@repo-name&quot;</span>)</span><br><span class="line">    condition: （可选） 解析为布尔值的yaml路径，用于启用/禁用chart (e.g. subchart1.enabled )</span><br><span class="line">    tags: <span class="comment"># （可选）</span></span><br><span class="line">      - 用于一次启用/禁用 一组chart的tag</span><br><span class="line">    import-values: <span class="comment"># （可选）</span></span><br><span class="line">      - ImportValue 保存源值到导入父键的映射。每项可以是字符串或者一对子/父列表项</span><br><span class="line">    <span class="built_in">alias</span>: （可选） chart中使用的别名。当你要多次添加相同的chart时会很有用</span><br><span class="line">maintainers: <span class="comment"># （可选）</span></span><br><span class="line">  - name: 维护者名字 （每个维护者都需要）</span><br><span class="line">    email: 维护者邮箱 （每个维护者可选）</span><br><span class="line">    url: 维护者URL （每个维护者可选）</span><br><span class="line">icon: 用做icon的SVG或PNG图片URL （可选）</span><br><span class="line">appVersion: 包含的应用版本（可选）。不需要是语义化，建议使用引号</span><br><span class="line">deprecated: 不被推荐的chart （可选，布尔值）</span><br><span class="line">annotations:</span><br><span class="line">  example: 按名称输入的批注列表 （可选）.</span><br></pre></td></tr></table></figure>

<ul>
<li>从 v3.3.2，不再允许额外的字段。推荐的方法是在 <code>annotations</code> 中添加自定义元数据。</li>
<li>每个 chart 都必须有个版本号（<code>version</code>）。版本必须遵循 语义化版本 2 标准。不像经典 Helm， Helm v2 以及后续版本会使用版本号作为发布标记。仓库中的包通过名称加版本号标识。</li>
</ul>
<p>比如 nginx chart 的版本字段 version: 1.2.3 按照名称被设置为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx-1.2.3.tgz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>【温馨提示】<code>appVersion</code>字段与<code>version</code>字段并不相关。这是指定应用版本的一种方式。比如，这个 drupal chart 可能有一个 appVersion: “8.2.1”，表示包含在 chart（默认）的 Drupal 的版本是 8.2.1。</p>
</blockquote>
<h3 id="3）Chart-依赖管理（dependencies）"><a href="#3）Chart-依赖管理（dependencies）" class="headerlink" title="3）Chart 依赖管理（dependencies）"></a>3）Chart 依赖管理（dependencies）</h3><p>当前 chart 依赖的其他 chart 会在 dependencies 字段定义为一个列表。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">apache</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.2</span><span class="number">.3</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">https://example.com/charts</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">3.2</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">https://another.example.com/charts</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name 字段是你需要的 chart 的名称</li>
<li>version 字段是你需要的 chart 的版本</li>
<li>repository 字段是 chart 仓库的完整 URL。注意你必须使用 helm repo add 在本地添加仓库</li>
<li>你可以使用仓库的名称代替 URL</li>
</ul>
<p>示例演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add bitnami https://charts.bitnami.com/bitnami</span><br><span class="line">helm pull bitnami/wordpress</span><br><span class="line">tar -xf wordpress</span><br><span class="line"><span class="built_in">cat</span> wordpress/Chart.yaml</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202212291124189.png" alt="图片"><br>一旦你定义好了依赖，运行 <code>helm dependency update</code> 就会使用你的依赖文件下载所有你指定的 chart 到你的 charts&#x2F;目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm dependency update ./wordpress</span><br></pre></td></tr></table></figure>

<p>当 helm dependency update 拉取 chart 时，会在 charts&#x2F;目录中形成一个 chart 包。因此对于上面的示例，会在 chart 目录中期望看到以下文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wordpress/charts/</span><br><span class="line">├── common</span><br><span class="line">├── common-2.0.1.tgz</span><br><span class="line">├── mariadb</span><br><span class="line">├── mariadb-11.2.2.tgz</span><br><span class="line">├── memcached</span><br><span class="line">└── memcached-6.2.3.tgz</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/645.png" alt="图片"></p>
<p><strong>依赖中的 tag 和条件字段</strong></p>
<blockquote>
<p>除了上面的其他字段外，每个需求项可以包含可选字段 <code>tags</code> 和 <code>condition</code>。<strong>所有的 chart 会默认加载</strong>。如果存在 tags 或者 condition 字段，它们将被评估并用于控制它们应用的 chart 的加载。</p>
</blockquote>
<ul>
<li><code>Condition</code> ——<strong>条件字段</strong>field 包含一个或多个 YAML 路径（用逗号分隔）。如果这个路径在上层 values 中已存在并解析为布尔值，chart 会基于布尔值启用或禁用 chart。只会使用列表中找到的第一个有效路径，如果路径为未找到则条件无效。</li>
<li><code>Tags</code> ——<code>tag</code>字段是与 chart 关联的 YAML 格式的标签列表。在顶层 value 中，通过指定 tag 和布尔值，可以启用或禁用所有的带 tag 的 chart。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parentchart/Chart.yaml</span></span><br><span class="line"></span><br><span class="line">dependencies:</span><br><span class="line">  - name: subchart1</span><br><span class="line">    repository: http://localhost:10191</span><br><span class="line">    version: 0.1.0</span><br><span class="line">    condition: subchart1.enabled, global.subchart1.enabled</span><br><span class="line">    tags:</span><br><span class="line">      - front-end</span><br><span class="line">      - subchart1</span><br><span class="line">  - name: subchart2</span><br><span class="line">    repository: http://localhost:10191</span><br><span class="line">    version: 0.1.0</span><br><span class="line">    condition: subchart2.enabled,global.subchart2.enabled</span><br><span class="line">    tags:</span><br><span class="line">      - back-end</span><br><span class="line">      - subchart2</span><br><span class="line"><span class="comment"># parentchart/values.yaml</span></span><br><span class="line"></span><br><span class="line">subchart1:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">tags:</span><br><span class="line">  front-end: <span class="literal">false</span></span><br><span class="line">  back-end: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的例子中，所有带 front-end tag 的 chart 都会被禁用，但只要上层的 value 中 <code>subchart1.enabled</code> 路径被设置为 <code>&#39;true&#39;</code>，<strong>该条件会覆盖 front-end 标签且 subchart1 会被启用</strong>。</li>
<li>一旦 subchart2 使用了 back-end 标签并被设置为了 true，subchart2 就会被启用。也要注意尽管 subchart2 指定了一个条件字段， 但是上层 value 没有相应的路径和 value，因此这个条件不会生效。</li>
</ul>
<p><code>--set</code> 参数可以用来设置标签和条件值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install --<span class="built_in">set</span> tags.front-end=<span class="literal">true</span> --<span class="built_in">set</span> subchart2.enabled=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>标签和条件的解析：</p>
<ul>
<li>条件 （当设置在 value 中时）总是会覆盖标签 第一个 chart 条件路径存在时会忽略后面的路径。</li>
<li>标签被定义为 ‘如果任意的 chart 标签是 true，chart 就可以启用’。</li>
<li>标签和条件值必须被设置在顶层 value 中。</li>
<li>value 中的 tags:键必须是顶层键。</li>
</ul>
<h3 id="4）通过依赖导入子-Value"><a href="#4）通过依赖导入子-Value" class="headerlink" title="4）通过依赖导入子 Value"></a>4）通过依赖导入子 Value</h3><ul>
<li>在某些情况下，<strong>允许子 chart 的值作为公共默认传递到父 chart 中</strong>是值得的。使用 <code>exports</code>格式的额外好处是它可是将来的工具可以自检用户可设置的值。</li>
<li>被导入的包含值的 key 可以在父 chart 的 dependencies 中的 <code>import-values</code>字段以 YAML 列表形式指定。列表中的每一项是从子 chart 中 exports 字段导入的 key。</li>
<li>导入 exports key 中未包含的值，使用 <strong>子-父格式</strong>。两种格式的示例如下所述。</li>
</ul>
<p>使用导出格式：<br>如果子 chart 的 values.yaml 文件中在根节点包含了 exports 字段，它的内容可以通过指定的可以被直接导入到父 chart 的 value 中， 如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s Chart.yaml file</span></span><br><span class="line"></span><br><span class="line">dependencies:</span><br><span class="line">  - name: subchart</span><br><span class="line">    repository: http://localhost:10191</span><br><span class="line">    version: 0.1.0</span><br><span class="line">    import-values:</span><br><span class="line">      - data</span><br><span class="line"><span class="comment"># child&#x27;s values.yaml file</span></span><br><span class="line"></span><br><span class="line">exports:</span><br><span class="line">  data:</span><br><span class="line">    myint: 99</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只要我们再导入列表中指定了键 data，Helm 就会在子 chart 的 exports 字段查找 data 键并导入它的内容。</p>
</blockquote>
<p>最终的父级 value 会包含我们的导出字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s values</span></span><br><span class="line"></span><br><span class="line">myint: 99</span><br></pre></td></tr></table></figure>

<blockquote>
<p>【注意】父级键 data 没有包含在父级最终的 value 中，如果想指定这个父级键，要使用<code>&#39;子-父&#39; 格式</code>。</p>
</blockquote>
<p>下面示例中的<code>import-values</code> 指示 Helm 去拿到能再 child:路径中找到的任何值，并拷贝到 parent:的指定路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s Chart.yaml file</span></span><br><span class="line"></span><br><span class="line">dependencies:</span><br><span class="line">  - name: subchart1</span><br><span class="line">    repository: http://localhost:10191</span><br><span class="line">    version: 0.1.0</span><br><span class="line">    ...</span><br><span class="line">    import-values:</span><br><span class="line">      - child: default.data</span><br><span class="line">        parent: myimports</span><br></pre></td></tr></table></figure>

<p>上面的例子中，在 subchart1 里面找到的 default.data 的值会被导入到父 chart 的 myimports 键中，细节如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s values.yaml file</span></span><br><span class="line"></span><br><span class="line">myimports:</span><br><span class="line">  myint: 0</span><br><span class="line">  mybool: <span class="literal">false</span></span><br><span class="line">  mystring: <span class="string">&quot;helm rocks!&quot;</span></span><br><span class="line"><span class="comment"># subchart1&#x27;s values.yaml file</span></span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">  data:</span><br><span class="line">    myint: 999</span><br><span class="line">    mybool: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>父 chart 的结果值将会是这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parent&#x27;s final values</span></span><br><span class="line"></span><br><span class="line">myimports:</span><br><span class="line">  myint: 999</span><br><span class="line">  mybool: <span class="literal">true</span></span><br><span class="line">  mystring: <span class="string">&quot;helm rocks!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="六、Templates-and-Values"><a href="#六、Templates-and-Values" class="headerlink" title="六、Templates and Values"></a>六、Templates and Values</h2><h3 id="1）Templates-and-Values-简介"><a href="#1）Templates-and-Values-简介" class="headerlink" title="1）Templates and Values 简介"></a>1）Templates and Values 简介</h3><ul>
<li>Helm Chart 模板是按照 Go 模板语言书写， 增加了 50 个左右的附加模板函数 来自 Sprig 库 和一些其他 指定的函数。</li>
<li>所有模板文件存储在 chart 的 <code>templates/</code> 文件夹。当 Helm 渲染 chart 时，它会通过模板引擎遍历目录中的每个文件。</li>
</ul>
<p>模板的 Value 通过两种方式提供：</p>
<ul>
<li>Chart 开发者可以在 chart 中提供一个命名为 <code>values.yaml</code> 的文件。这个文件包含了默认值。</li>
<li>Chart 用户可以提供一个包含了 value 的 YAML 文件。可以在命令行使用 helm install 命令时通过<code>-f</code>指定 value 文件。</li>
</ul>
<p>模板示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deis-database</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">deis</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/managed-by:</span> <span class="string">deis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">deis-database</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">deis-database</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccount:</span> <span class="string">deis-database</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deis-database</span></span><br><span class="line">          <span class="attr">image:</span> &#123;&#123; <span class="string">.Values.imageRegistry</span> &#125;&#125;<span class="string">/postgres:&#123;&#123;</span> <span class="string">.Values.dockerTag</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> &#123;&#123; <span class="string">.Values.pullPolicy</span> &#125;&#125;</span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5432</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DATABASE_STORAGE</span></span><br><span class="line">              <span class="attr">value:</span> &#123;&#123; <span class="string">default</span> <span class="string">&quot;minio&quot;</span> <span class="string">.Values.storage</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子，松散地基于</p>
<blockquote>
<p><a href="https://github.com/deis/charts">https://github.com/deis/charts</a></p>
</blockquote>
<p>是一个 Kubernetes 副本控制器的模板。可以使用下面四种模板值（一般被定义在 values.yaml 文件）：</p>
<ul>
<li>imageRegistry: Docker 镜像的源注册表</li>
<li>dockerTag: Docker 镜像的 tag</li>
<li>pullPolicy: Kubernetes 的拉取策略</li>
<li>storage: 后台存储，默认设置为”minio”</li>
</ul>
<h3 id="2）预定义的-Values"><a href="#2）预定义的-Values" class="headerlink" title="2）预定义的 Values"></a>2）预定义的 Values</h3><blockquote>
<p>Values 通过模板中.Values 对象可访问的 values.yaml 文件（或者通过 –set 参数)提供， 但可以模板中访问其他预定义的数据片段。</p>
</blockquote>
<p>以下值是预定义的，对每个模板都有效，并且可以被覆盖。和所有值一样，名称 区分大小写。</p>
<ul>
<li><code>Release.Name</code>: 版本名称(非 chart 的)</li>
<li><code>Release.Namespace</code>: 发布的 chart 版本的命名空间</li>
<li><code>Release.Service</code>: 组织版本的服务</li>
<li><code>Release.IsUpgrade</code>: 如果当前操作是升级或回滚，设置为 true</li>
<li><code>Release.IsInstall</code>: 如果当前操作是安装，设置为 true</li>
<li><code>Chart</code>: <code>Chart.yaml</code>的内容。因此，chart 的版本可以从 Chart.Version 获得， 并且维护者在 Chart.Maintainers 里。</li>
<li><code>Files</code>: chart 中的包含了非特殊文件的类图对象。这将不允许您访问模板， 但是可以访问现有的其他文件（除非被.helmignore 排除在外）。使用<code>&#123;&#123; index .Files "file.name" &#125;&#125;</code>可以访问文件或者使用<code>&#123;&#123;.Files.Get name &#125;&#125;</code>功能。您也可以使用<code>&#123;&#123; .Files.GetBytes &#125;&#125;</code>作为[]byte 访问文件内容。</li>
<li><code>Capabilities</code>: 包含了 Kubernetes 版本信息的类图对象。<code>&#123;&#123; .Capabilities.KubeVersion &#125;&#125;</code> 和支持的 Kubernetes API 版本<code>&#123;&#123; .Capabilities.APIVersions.Has "batch/v1" &#125;&#125;</code></li>
</ul>
<p>考虑到前面部分的模板，<code>values.yaml</code>文件提供的必要值如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">imageRegistry: <span class="string">&quot;quay.io/deis&quot;</span></span><br><span class="line">dockerTag: <span class="string">&quot;latest&quot;</span></span><br><span class="line">pullPolicy: <span class="string">&quot;Always&quot;</span></span><br><span class="line">storage: <span class="string">&quot;s3&quot;</span></span><br></pre></td></tr></table></figure>

<p>values 文件被定义为 YAML 格式。chart 会包含一个默认的 values.yaml 文件。Helm 安装命令允许用户使用附加的 YAML values 覆盖这个 values：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install --generate-name --values=myvals.yaml wordpress</span><br></pre></td></tr></table></figure>

<h3 id="3）范围，依赖和值"><a href="#3）范围，依赖和值" class="headerlink" title="3）范围，依赖和值"></a>3）范围，依赖和值</h3><p><strong>Values 文件</strong>可以声明顶级 chart 的值，以及<code>charts/</code>目录中包含的其他任意 chart。或者换个说法，<strong>values 文件可以为 chart 及其任何依赖项提供值</strong>。比如，上面示范的 WordPress chart 同时有 mysql 和 apache 作为依赖。values 文件可以为以下所有这些组件提供依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: <span class="string">&quot;My WordPress Site&quot;</span> <span class="comment"># Sent to the WordPress template</span></span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  max_connections: 100 <span class="comment"># Sent to MySQL</span></span><br><span class="line">  password: <span class="string">&quot;secret&quot;</span></span><br><span class="line"></span><br><span class="line">apache:</span><br><span class="line">  port: 8080 <span class="comment"># Passed to Apache</span></span><br></pre></td></tr></table></figure>

<p>更<strong>高阶的 chart 可以访问下面定义的所有变量</strong>。因此<strong>WordPress chart 可以用.Values.mysql.password 访问 MySQL 密码</strong>。但是<strong>低阶的 chart 不能访问父级 chart</strong>，所以 MySQL 无法访问 title 属性。同样也无法访问 apache.port。</p>
<h3 id="4）全局-Values"><a href="#4）全局-Values" class="headerlink" title="4）全局 Values"></a>4）全局 Values</h3><p>从 2.0.0-Alpha.2 开始，Helm 支持特殊的”global”值。设想一下前面的示例中的修改版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: <span class="string">&quot;My WordPress Site&quot;</span> <span class="comment"># Sent to the WordPress template</span></span><br><span class="line"></span><br><span class="line">global:</span><br><span class="line">  app: MyWordPress</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  max_connections: 100 <span class="comment"># Sent to MySQL</span></span><br><span class="line">  password: <span class="string">&quot;secret&quot;</span></span><br><span class="line"></span><br><span class="line">apache:</span><br><span class="line">  port: 8080 <span class="comment"># Passed to Apache</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>面添加了 global 部分和一个值 app: MyWordPress。这个值以<code>.Values.global.app</code>在 <strong>所有 chart 中有效</strong>。</p>
</blockquote>
<p>比如，mysql 模板可以以<code>&#123;&#123;.Values.global.app&#125;&#125;</code>访问 app，同样 apache chart 也可以访问。实际上，上面的 values 文件会重新生成为这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: <span class="string">&quot;My WordPress Site&quot;</span> <span class="comment"># Sent to the WordPress template</span></span><br><span class="line"></span><br><span class="line">global:</span><br><span class="line">  app: MyWordPress</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  global:</span><br><span class="line">    app: MyWordPress</span><br><span class="line">  max_connections: 100 <span class="comment"># Sent to MySQL</span></span><br><span class="line">  password: <span class="string">&quot;secret&quot;</span></span><br><span class="line"></span><br><span class="line">apache:</span><br><span class="line">  global:</span><br><span class="line">    app: MyWordPress</span><br><span class="line">  port: 8080 <span class="comment"># Passed to Apache</span></span><br></pre></td></tr></table></figure>

<h2 id="七、Helm-资源安装顺序"><a href="#七、Helm-资源安装顺序" class="headerlink" title="七、Helm 资源安装顺序"></a>七、Helm 资源安装顺序</h2><ul>
<li>Namespace</li>
<li>NetworkPolicy</li>
<li>ResourceQuota</li>
<li>LimitRange</li>
<li>PodSecurityPolicy</li>
<li>PodDisruptionBudget</li>
<li>ServiceAccount</li>
<li>Secret</li>
<li>SecretList</li>
<li>ConfigMap</li>
<li>StorageClass</li>
<li>PersistentVolume</li>
<li>PersistentVolumeClaim</li>
<li>CustomResourceDefinition</li>
<li>ClusterRole</li>
<li>ClusterRoleList</li>
<li>ClusterRoleBinding</li>
<li>ClusterRoleBindingList</li>
<li>Role</li>
<li>RoleList</li>
<li>RoleBinding</li>
<li>RoleBindingList</li>
<li>Service</li>
<li>DaemonSet</li>
<li>Pod</li>
<li>ReplicationController</li>
<li>ReplicaSet</li>
<li>Deployment</li>
<li>HorizontalPodAutoscaler</li>
<li>StatefulSet</li>
<li>Job</li>
<li>CronJob</li>
<li>Ingress</li>
<li>APIService</li>
</ul>
<h2 id="八、Helm-安装-Chart-包的三种方式"><a href="#八、Helm-安装-Chart-包的三种方式" class="headerlink" title="八、Helm 安装 Chart 包的三种方式"></a>八、Helm 安装 Chart 包的三种方式</h2><p>Helm 自带一个强大的搜索命令，可以用来从两种来源中进行搜索：</p>
<ul>
<li><code>helm search hub</code> 从 Artifact Hub <code>https://artifacthub.io/</code> 中查找并列出 helm charts。Artifact Hub 中存放了大量不同的仓库。</li>
<li><code>helm search repo</code> 从你添加（使用 <code>helm repo add</code>）到本地 helm 客户端中的仓库中进行查找。该命令基于本地数据进行搜索，无需连接互联网。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加bitnami仓库源</span></span><br><span class="line">helm repo add bitnami https://charts.bitnami.com/bitnami</span><br><span class="line"><span class="comment"># 从bitnami源查找所有chart包，不指定具体源的话，会查找本地添加的所有源地址的所有chart包</span></span><br><span class="line">helm search repo bitnami</span><br></pre></td></tr></table></figure>

<h3 id="1）values-传参"><a href="#1）values-传参" class="headerlink" title="1）values 传参"></a>1）values 传参</h3><p>安装过程中有两种方式传递配置数据：</p>
<ul>
<li><code>--values (或 -f)</code>：使用 YAML 文件覆盖配置。可以指定多次，优先使用最右边的文件。</li>
<li><code>--set</code>：通过命令行的方式对指定项进行覆盖。</li>
</ul>
<p>如果同时使用两种方式，则 –set 中的值会被合并到 –values 中，但是 <code>--set</code> 中的值<strong>优先级更高</strong>。在–set 中覆盖的内容会被被保存在 ConfigMap 中。可以通过 <code>helm get values &lt;release-name&gt;</code> 来<strong>查看指定 release 中 –set 设置的值</strong>。也可以通过运行 helm upgrade 并指定 –reset-values 字段来清除 –set 中设置的值。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;mariadb.auth.database: user0db, mariadb.auth.username: user0&#125;&#x27;</span> &gt; values.yaml</span><br><span class="line">helm install -f values.yaml bitnami/wordpress --generate-name</span><br></pre></td></tr></table></figure>

<h3 id="2）【第一种方式】直接在线-安装不需要先下载包到本地"><a href="#2）【第一种方式】直接在线-安装不需要先下载包到本地" class="headerlink" title="2）【第一种方式】直接在线 安装不需要先下载包到本地"></a>2）【第一种方式】直接在线 安装不需要先下载包到本地</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install mysql bitnami/mysql</span><br><span class="line">helm list</span><br></pre></td></tr></table></figure>

<h3 id="3）【第二种方式】离线安装-直接通过安装包安装"><a href="#3）【第二种方式】离线安装-直接通过安装包安装" class="headerlink" title="3）【第二种方式】离线安装 直接通过安装包安装"></a>3）【第二种方式】离线安装 直接通过安装包安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先删除</span></span><br><span class="line">helm uninstall mysql</span><br><span class="line"><span class="comment"># 拉包到本地</span></span><br><span class="line">helm pull bitnami/mysql</span><br><span class="line"><span class="comment"># 不解压直接安装</span></span><br><span class="line">helm install mysql ./mysql-9.3.1.tgz</span><br><span class="line">helm list</span><br></pre></td></tr></table></figure>

<h3 id="4）【第三种方式】离线安装-解压包再安装"><a href="#4）【第三种方式】离线安装-解压包再安装" class="headerlink" title="4）【第三种方式】离线安装 解压包再安装"></a>4）【第三种方式】离线安装 解压包再安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉包到本地</span></span><br><span class="line">helm pull bitnami/mysql</span><br><span class="line"><span class="comment"># 解压安装</span></span><br><span class="line">tar -xf mysql-9.3.1.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始安装</span></span><br><span class="line">helm install mysql ./mysql \</span><br><span class="line">--namespace=mysql \</span><br><span class="line">--create-namespace \</span><br><span class="line">--<span class="built_in">set</span> image.registry=myharbor.com \</span><br><span class="line">--<span class="built_in">set</span> image.repository=bigdata/mysql \</span><br><span class="line">--<span class="built_in">set</span> image.tag=8.0.30 \</span><br><span class="line">--<span class="built_in">set</span> primary.service.type=NodePort \</span><br><span class="line">--<span class="built_in">set</span> service.nodePorts.mysql=30306</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看在运行的Release</span></span><br><span class="line">helm list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">helm uninstall mysql -n mysql</span><br></pre></td></tr></table></figure>

<h2 id="九、Helm-基础语法"><a href="#九、Helm-基础语法" class="headerlink" title="九、Helm 基础语法"></a>九、Helm 基础语法</h2><h3 id="1）变量"><a href="#1）变量" class="headerlink" title="1）变量"></a>1）变量</h3><p>模板（<code>templates/</code>）中的<strong>变量</strong>都放在<code>&#123;&#123;&#125;&#125;</code>中，比如：<code>&#123;&#123; .Values.images &#125;&#125;</code> 表示 <code>Values 对象</code>下的 images 字段。Values 来源于<code>values.yaml</code>文件或者<code>-f</code>指定的 yaml 文件，或者<code>--set</code>设置的变量。</p>
<blockquote>
<p>【温馨提示】使用<code>-</code>删除空格和换行符，要想删除那行其他的空格和换行符可以用<code>&#123;&#123;-`或者`-&#125;&#125;</code>，**一个是删除左边的<code>空格</code>和<code>换行符</code><strong>，</strong>一个是删除右边的<code>空格</code>和<code>换行符</code>**。</p>
</blockquote>
<h3 id="2）内置对象"><a href="#2）内置对象" class="headerlink" title="2）内置对象"></a>2）内置对象</h3><ul>
<li><p><code>Release</code>：Release 对象描述了版本发布本身。包含了以下对象：</p>
</li>
<li><ul>
<li><code>Release.Name</code>：release 名称；</li>
<li><code>Release.Namespace</code>：版本中包含的命名空间(如果 manifest 没有覆盖的话)；</li>
<li><code>Release.IsUpgrade</code>：如果当前操作是升级或回滚的话，该值将被设置为 true</li>
<li><code>Release.IsInstall</code>：如果当前操作是安装的话，该值将被设置为 true</li>
<li><code>Release.Revision</code>：此次修订的版本号。安装时是 1，每次升级或回滚都会自增；</li>
<li><code>Release.Service</code>：该 service 用来渲染当前模板。Helm 里始终 Helm。</li>
</ul>
</li>
<li><p><code>Values</code>：Values 对象是从<code>values.yaml</code>文件和用户提供的文件传进模板的。默认为空</p>
</li>
<li><p><code>Chart</code>：<code>Chart.yaml</code>文件内容。Chart.yaml 里的所有数据在这里都可以可访问的。比如 <code>&#123;&#123; .Chart.Name &#125;&#125;-&#123;&#123; .Chart.Version &#125;&#125;</code> 会打印出 mychart-0.1.0。</p>
</li>
<li><p><code>Template</code>：包含当前被执行的当前模板信息</p>
</li>
<li><ul>
<li><code>Template.Name</code>: 当前模板的命名空间文件路径 (e.g. mychart&#x2F;templates&#x2F;mytemplate.yaml)；</li>
<li><code>Template.BasePath</code>: 当前 chart 模板目录的路径 (e.g. mychart&#x2F;templates)。</li>
</ul>
</li>
</ul>
<h3 id="3）常用的内置函数"><a href="#3）常用的内置函数" class="headerlink" title="3）常用的内置函数"></a>3）常用的内置函数</h3><h4 id="1、quote-and-squote"><a href="#1、quote-and-squote" class="headerlink" title="1、quote and squote"></a>1、quote and squote</h4><p>该函数将值转<strong>换成字符串</strong>用<strong>双引号(<code>quote</code>)</strong> 或者**单引号(<code>squote</code>)**括起来。示例如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">.Release.Name</span> &#125;&#125;<span class="string">-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">myvalue:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">  <span class="attr">drink:</span> &#123;&#123; <span class="string">.Values.favorite.drink</span> <span class="string">|</span> <span class="string">quote</span> &#125;&#125;</span><br><span class="line">  <span class="attr">food:</span> &#123;&#123; <span class="string">.Values.favorite.food</span> <span class="string">|</span> <span class="string">upper</span> <span class="string">|</span> <span class="string">quote</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>倒置命令是模板中的常见做法。可以经常看到 <code>.val | quote</code> 而不是 <code>quote .val</code>。实际上两种操作都是可以的。</p>
</blockquote>
<h4 id="2、default"><a href="#2、default" class="headerlink" title="2、default"></a>2、default</h4><p>这个函数允许你在模板中指定一个默认值，以防这个值被忽略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果.Values.favorite.drink是非空值，则使用它，否则会返回tea。</span></span><br><span class="line">drink: &#123;&#123; .Values.favorite.drink | default <span class="string">&quot;tea&quot;</span> | quote &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以这样写，如果.Bar是非空值，则使用它，否则会返回foo。</span></span><br><span class="line">default <span class="string">&quot;foo&quot;</span> .Bar</span><br></pre></td></tr></table></figure>

<p>“空”定义取决于以下类型：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">整型: 0</span><br><span class="line">字符串: &quot;&quot;</span><br><span class="line">列表: []</span><br><span class="line">字典: &#123;&#125;</span><br><span class="line">布尔: false</span><br><span class="line">以及所有的nil (或 null)</span><br></pre></td></tr></table></figure>

<h4 id="3、print"><a href="#3、print" class="headerlink" title="3、print"></a>3、print</h4><p>返回各部分组合的字符串，非字符串类型会被转换成字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Matt has &quot;</span> .Dogs <span class="string">&quot; dogs&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>【温馨提示】当相邻两个参数不是字符串时会在它们之间添加一个空格。</p>
</blockquote>
<h4 id="4、println"><a href="#4、println" class="headerlink" title="4、println"></a>4、println</h4><p>和 print 效果一样，但会在末尾新添加一行。</p>
<h4 id="5、printf"><a href="#5、printf" class="headerlink" title="5、printf"></a>5、printf</h4><p>返回参数按顺序传递的格式化字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s has %d dogs.&quot;</span> .Name .NumberDogs</span><br><span class="line">&#123;&#123;- <span class="built_in">printf</span> <span class="string">&quot;%d&quot;</span> (.Values.externalCache.port | int ) -&#125;&#125;</span><br><span class="line">&#123;&#123;- <span class="built_in">printf</span> <span class="string">&quot;%s&quot;</span> .Values.existingSecret -&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- <span class="built_in">printf</span> <span class="string">&quot;%v&quot;</span> .context.Values.redis.enabled -&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># %s 字符串占位符，未解析的二进制字符串或切片</span></span><br><span class="line"><span class="comment"># %d 数字占位符，十进制</span></span><br><span class="line"><span class="comment"># %v 默认格式的值，当打印字典时，加号参数(%+v)可以添加字段名称</span></span><br></pre></td></tr></table></figure>

<p>更多占位符的使用，可以参考官方文档：</p>
<blockquote>
<p><a href="https://helm.sh/zh/docs/chart_template_guide/function_list/">https://helm.sh/zh/docs/chart_template_guide/function_list/</a></p>
</blockquote>
<h4 id="6、trim"><a href="#6、trim" class="headerlink" title="6、trim"></a>6、trim</h4><p>trim 行数移除字符串两边的空格：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trim <span class="string">&quot;   hello    &quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="7、trimAll"><a href="#7、trimAll" class="headerlink" title="7、trimAll"></a>7、trimAll</h4><p>从字符串中移除给定的字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trimAll <span class="string">&quot;$&quot;</span> <span class="string">&quot;<span class="variable">$5</span>.00&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：5.00 (作为一个字符串)。</p>
<h4 id="8、lower"><a href="#8、lower" class="headerlink" title="8、lower"></a>8、lower</h4><p>将整个字符串转换成小写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lower <span class="string">&quot;HELLO&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：hello</p>
<h4 id="9、upper"><a href="#9、upper" class="headerlink" title="9、upper"></a>9、upper</h4><p>将整个字符串转换成大写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upper <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：HELLO</p>
<h4 id="10、title"><a href="#10、title" class="headerlink" title="10、title"></a>10、title</h4><p>首字母转换成大写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：Hello World</p>
<h4 id="11、substr"><a href="#11、substr" class="headerlink" title="11、substr"></a>11、substr</h4><p>获取字符串的子串，有三个参数：</p>
<ul>
<li>start (int)</li>
<li>end (int)</li>
<li>string (string)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">substr 0 5 <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：hello</p>
<h4 id="12、abbrev"><a href="#12、abbrev" class="headerlink" title="12、abbrev"></a>12、abbrev</h4><p>用省略号截断字符串 (…)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">abbrev 5 <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># 第一个参数：最大长度</span></span><br><span class="line"><span class="comment"># 第二个参数：字符串</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：he…， 因为将省略号算进了长度中。</p>
<h4 id="13、contains"><a href="#13、contains" class="headerlink" title="13、contains"></a>13、contains</h4><p>测试字符串是否包含在另一个字符串中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">contains <span class="string">&quot;cat&quot;</span> <span class="string">&quot;catch&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="14、cat"><a href="#14、cat" class="headerlink" title="14、cat"></a>14、cat</h4><p>cat 函数将多个字符串合并成一个，用空格分隔：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> <span class="string">&quot;hello&quot;</span> <span class="string">&quot;beautiful&quot;</span> <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：hello beautiful world</p>
<h4 id="15、indent"><a href="#15、indent" class="headerlink" title="15、indent"></a>15、indent</h4><p>indent 以<strong>指定长度缩进</strong>给定字符串所在行，在对齐多行字符串时很有用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">indent 4 <span class="variable">$lots_of_text</span></span><br></pre></td></tr></table></figure>

<p>上述结果会将每行缩进 4 个空格。</p>
<h4 id="16、nindent"><a href="#16、nindent" class="headerlink" title="16、nindent"></a>16、nindent</h4><p>nindent 函数和 indent 函数一样，但可以在字符串开头添加新行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nindent 4 <span class="variable">$lots_of_text</span></span><br></pre></td></tr></table></figure>

<p>上述结果会在字符串所在行缩进 4 个字符，并且在开头新添加一行。</p>
<h4 id="17、replace"><a href="#17、replace" class="headerlink" title="17、replace"></a>17、replace</h4><p>执行简单的字符串替换。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面两行等价</span></span><br><span class="line">replace <span class="string">&quot; &quot;</span> <span class="string">&quot;-&quot;</span> <span class="string">&quot;I Am Henry VIII&quot;</span></span><br><span class="line"><span class="string">&quot;I Am Henry VIII&quot;</span> | replace <span class="string">&quot; &quot;</span> <span class="string">&quot;-&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数1：待替换字符串</span></span><br><span class="line"><span class="comment"># 参数2：要替换字符串</span></span><br><span class="line"><span class="comment"># 参数3：源字符串</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：I-Am-Henry-VIII</p>
<h4 id="18、date"><a href="#18、date" class="headerlink" title="18、date"></a>18、date</h4><p>date 函数格式化日期，日期格式化为 YEAR-MONTH-DAY：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">now | <span class="built_in">date</span> <span class="string">&quot;2006-01-02&quot;</span></span><br></pre></td></tr></table></figure>

<p>想了解更多内置函数，可以参考官方文档：</p>
<blockquote>
<p><a href="https://helm.sh/zh/docs/chart_template_guide/function_list/">https://helm.sh/zh/docs/chart_template_guide/function_list/</a></p>
</blockquote>
<h3 id="4）类型转换函数"><a href="#4）类型转换函数" class="headerlink" title="4）类型转换函数"></a>4）类型转换函数</h3><p>Helm 提供了以下类型转换函数：</p>
<ul>
<li><code>atoi</code>: 字符串转换成整型。</li>
<li><code>float64</code>: 转换成 float64。</li>
<li><code>int</code>: 按系统整型宽度转换成 int。</li>
<li><code>int64</code>: 转换成 int64。</li>
<li><code>toDecimal</code>: 将 unix 八进制转换成 int64。</li>
<li><code>toString</code>: 转换成字符串。</li>
<li><code>toStrings</code>: 将列表、切片或数组转换成字符串列表。</li>
<li><code>toJson (mustToJson)</code>: 将列表、切片、数组、字典或对象转换成 JSON。</li>
<li><code>toPrettyJson (mustToPrettyJson)</code>: 将列表、切片、数组、字典或对象转换成格式化 JSON。</li>
<li><code>toRawJson (mustToRawJson)</code>: 将列表、切片、数组、字典或对象转换成 HTML 字符未转义的 JSON。</li>
</ul>
<h3 id="5）正则表达式（Regular-Expressions）"><a href="#5）正则表达式（Regular-Expressions）" class="headerlink" title="5）正则表达式（Regular Expressions）"></a>5）正则表达式（Regular Expressions）</h3><p>Helm 包含以下正则表达式函数</p>
<ul>
<li>regexFind(mustRegexFind)</li>
<li>regexFindAll(mustRegexFindAll)</li>
<li>regexMatch (mustRegexMatch)</li>
<li>regexReplaceAll (mustRegexReplaceAll)</li>
<li>regexReplaceAllLiteral(mustRegexReplaceAllLiteral)</li>
<li>regexSplit (mustRegexSplit)</li>
</ul>
<h3 id="6）编码和解码函数"><a href="#6）编码和解码函数" class="headerlink" title="6）编码和解码函数"></a>6）编码和解码函数</h3><p>Helm 有以下编码和解码函数：</p>
<ul>
<li>b64enc&#x2F;b64dec: 编码或解码 Base64</li>
<li>b32enc&#x2F;b32dec: 编码或解码 Base32</li>
</ul>
<h3 id="7）Dictionaries-and-Dict-Functions"><a href="#7）Dictionaries-and-Dict-Functions" class="headerlink" title="7）Dictionaries and Dict Functions"></a>7）Dictionaries and Dict Functions</h3><blockquote>
<p>Helm 提供了一个 key&#x2F;value 存储类型称为 dict（”dictionary”的简称，Python 中也有）。dict 是无序类型。<strong>字典的 key 必须是字符串</strong>。<strong>但值可以是任意类型，甚至是另一个 dict 或 list</strong>。</p>
</blockquote>
<h4 id="1、创建字典（dict）"><a href="#1、创建字典（dict）" class="headerlink" title="1、创建字典（dict）"></a>1、创建字典（dict）</h4><p>下面是创建三个键值对的字典：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$myDict</span> := dict <span class="string">&quot;name1&quot;</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;name2&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;name3&quot;</span> <span class="string">&quot;value 3&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、获取值（get）"><a href="#2、获取值（get）" class="headerlink" title="2、获取值（get）"></a>2、获取值（get）</h4><p>给定一个映射和一个键，从映射中获取值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get <span class="variable">$myDict</span> <span class="string">&quot;name1&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：”value1”</p>
<blockquote>
<p>注意如果没有找到，会简单返回””。不会生成 error。</p>
</blockquote>
<h4 id="3、添加键值对（set）"><a href="#3、添加键值对（set）" class="headerlink" title="3、添加键值对（set）"></a>3、添加键值对（set）</h4><p>使用 set 给字典添加一个键值对。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span> := <span class="built_in">set</span> <span class="variable">$myDict</span> <span class="string">&quot;name4&quot;</span> <span class="string">&quot;value4&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 set 返回字典 (Go 模板函数的一个要求)，因此你可能需要像上面那样使用使用<code>$_</code>赋值来获取值。</p>
</blockquote>
<h4 id="4、删除（unset）"><a href="#4、删除（unset）" class="headerlink" title="4、删除（unset）"></a>4、删除（unset）</h4><p>给定一个映射和 key，从映射中删除这个 key。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span> := <span class="built_in">unset</span> <span class="variable">$myDict</span> <span class="string">&quot;name4&quot;</span></span><br></pre></td></tr></table></figure>

<p>和 set 一样，需要返回字典。</p>
<h4 id="5、判断-key（hasKey）"><a href="#5、判断-key（hasKey）" class="headerlink" title="5、判断 key（hasKey）"></a>5、判断 key（hasKey）</h4><p>hasKey 函数会在给定字典中包含了给定 key 时返回 true。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hasKey <span class="variable">$myDict</span> <span class="string">&quot;name1&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果 key 没找到，会返回 false。</p>
<h4 id="6、pluck"><a href="#6、pluck" class="headerlink" title="6、pluck"></a>6、pluck</h4><p>pluck 函数给定一个键和多个映射，并获得所有匹配项的列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluck <span class="string">&quot;name1&quot;</span> <span class="variable">$myDict</span> <span class="variable">$myOtherDict</span></span><br></pre></td></tr></table></figure>

<p>上述会返回的 list 包含了每个找到的值([value1 otherValue1])。</p>
<h4 id="7、合并-dict（merge-mustMerge）"><a href="#7、合并-dict（merge-mustMerge）" class="headerlink" title="7、合并 dict（merge, mustMerge）"></a>7、合并 dict（merge, mustMerge）</h4><p>将两个或多个字典合并为一个， 目标字典优先：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$newdict</span> := merge <span class="variable">$dest</span> <span class="variable">$source1</span> <span class="variable">$source2</span></span><br></pre></td></tr></table></figure>

<h4 id="8、获取所有-keys"><a href="#8、获取所有-keys" class="headerlink" title="8、获取所有 keys"></a>8、获取所有 keys</h4><p>keys 函数会返回一个或多个 dict 类型中所有的 key 的 list。由于字典是 无序的，key 不会有可预料的顺序。可以使用 sortAlpha 存储。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keys <span class="variable">$myDict</span> | sortAlpha</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当提供了多个词典时，key 会被串联起来。使用<code>uniq</code>函数和<code>sortAlpha</code>获取一个唯一有序的键列表。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keys <span class="variable">$myDict</span> <span class="variable">$myOtherDict</span> | <span class="built_in">uniq</span> | sortAlpha</span><br></pre></td></tr></table></figure>

<h4 id="9、获取所有-values"><a href="#9、获取所有-values" class="headerlink" title="9、获取所有 values"></a>9、获取所有 values</h4><p>values 函数类似于 keys，返回一个新的 list 包含源字典中所有的 value(只支持一个字典)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$vals</span> := values <span class="variable">$myDict</span></span><br></pre></td></tr></table></figure>

<p>上述结果为：list[“value1”, “value2”, “value 3”]。</p>
<blockquote>
<p>注意 values 不能保证结果的顺序；如果你需要顺序， 请使用<code>sortAlpha</code>。</p>
</blockquote>
<h3 id="8）Lists-and-List-Functions"><a href="#8）Lists-and-List-Functions" class="headerlink" title="8）Lists and List Functions"></a>8）Lists and List Functions</h3><blockquote>
<p>Helm 提供了一个简单的 list 类型，包含任意顺序的列表。类似于数组或切片，但列表是被设计用于不可变数据类型。</p>
</blockquote>
<h4 id="1、创建列表"><a href="#1、创建列表" class="headerlink" title="1、创建列表"></a>1、创建列表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$myList</span> := list 1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p>上述会生成一个列表 [1 2 3 4 5]。</p>
<h4 id="2、获取列表第一项（first-mustFirst）"><a href="#2、获取列表第一项（first-mustFirst）" class="headerlink" title="2、获取列表第一项（first, mustFirst）"></a>2、获取列表第一项（first, mustFirst）</h4><p>获取列表中的第一项，使用 first。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">first <span class="variable">$myList</span></span><br><span class="line"><span class="comment"># 返回 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>first 有问题时会出错，mustFirst 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="3、获取列表的尾部内容（rest-mustRest）"><a href="#3、获取列表的尾部内容（rest-mustRest）" class="headerlink" title="3、获取列表的尾部内容（rest, mustRest）"></a>3、获取列表的尾部内容（rest, mustRest）</h4><p>获取列表的尾部内容(除了第一项外的所有内容)，使用 rest。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rest <span class="variable">$myList</span></span><br><span class="line"><span class="comment"># 返回 [2 3 4 5]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>rest 有问题时会出错，mustRest 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="4、获取列表的最后一项（last-mustLast）"><a href="#4、获取列表的最后一项（last-mustLast）" class="headerlink" title="4、获取列表的最后一项（last, mustLast）"></a>4、获取列表的最后一项（last, mustLast）</h4><p>使用 last 获取列表的最后一项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">last <span class="variable">$myList</span></span><br><span class="line"><span class="comment"># 返回 5。这大致类似于反转列表然后调用first。</span></span><br></pre></td></tr></table></figure>

<h4 id="5、获取列表所有内容（initial-mustInitial）"><a href="#5、获取列表所有内容（initial-mustInitial）" class="headerlink" title="5、获取列表所有内容（initial, mustInitial）"></a>5、获取列表所有内容（initial, mustInitial）</h4><p>通过返回所有元素 但 除了最后一个元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">initial <span class="variable">$myList</span></span><br><span class="line"><span class="comment"># 返回 [1 2 3 4]。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>initial 有问题时会出错，但是 mustInitial 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="6、末尾添加元素（append-mustAppend）"><a href="#6、末尾添加元素（append-mustAppend）" class="headerlink" title="6、末尾添加元素（append, mustAppend）"></a>6、末尾添加元素（append, mustAppend）</h4><p>在已有列表中追加一项，创建一个新的列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$new</span> = append <span class="variable">$myList</span> 6</span><br></pre></td></tr></table></figure>

<p>上述语句会设置 为。myList 会保持不变。</p>
<blockquote>
<p>append 有问题时会出错，但 mustAppend 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="7、前面添加元素（prepend-mustPrepend）"><a href="#7、前面添加元素（prepend-mustPrepend）" class="headerlink" title="7、前面添加元素（prepend, mustPrepend）"></a>7、前面添加元素（prepend, mustPrepend）</h4><p>将元素添加到列表的前面，生成一个新的列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prepend <span class="variable">$myList</span> 0</span><br></pre></td></tr></table></figure>

<p>上述语句会生成 [0 1 2 3 4 5]。$myList 会保持不变。</p>
<blockquote>
<p>prepend 有问题时会出错，但 mustPrepend 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="8、多列表连接（concat）"><a href="#8、多列表连接（concat）" class="headerlink" title="8、多列表连接（concat）"></a>8、多列表连接（concat）</h4><p>将任意数量的列表串联成一个。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">concat <span class="variable">$myList</span> ( list 6 7 ) ( list 8 )</span><br></pre></td></tr></table></figure>

<p>上述语句会生成 [1 2 3 4 5 6 7 8]。$myList 会保持不变。</p>
<h4 id="9、反转（reverse-mustReverse）"><a href="#9、反转（reverse-mustReverse）" class="headerlink" title="9、反转（reverse, mustReverse）"></a>9、反转（reverse, mustReverse）</h4><p>反转给定的列表生成一个新列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reverse <span class="variable">$myList</span></span><br></pre></td></tr></table></figure>

<p>上述语句会生成一个列表：[5 4 3 2 1]。</p>
<blockquote>
<p>reverse 有问题时会出错，但 mustReverse 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="10、去重（uniq-mustUniq）"><a href="#10、去重（uniq-mustUniq）" class="headerlink" title="10、去重（uniq, mustUniq）"></a>10、去重（uniq, mustUniq）</h4><p>生成一个移除重复项的列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list 1 1 1 2 | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure>

<p>上述语句会生成 [1 2]</p>
<blockquote>
<p>uniq 有问题时会出错，但 mustUniq 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="11、过滤（without-mustWithout）"><a href="#11、过滤（without-mustWithout）" class="headerlink" title="11、过滤（without, mustWithout）"></a>11、过滤（without, mustWithout）</h4><p>without 函数从列表中过滤内容。<br>    without $myList 3<br>    # 上述语句会生成 [1 2 4 5]</p>
<p>一个过滤器可以过滤多个元素：<br>    without $myList 1 3 5<br>    # 这样会得到： [2 4]</p>
<blockquote>
<p>without 有问题时会出错，但 mustWithout 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="12、判断元素是否存在（has-mustHas）"><a href="#12、判断元素是否存在（has-mustHas）" class="headerlink" title="12、判断元素是否存在（has, mustHas）"></a>12、判断元素是否存在（has, mustHas）</h4><p>验证列表是否有特定元素。<br>    has 4 $myList</p>
<p>上述语句会返回 true, 但 has “hello” $myList 就会返回 false。</p>
<blockquote>
<p>has 有问题时会出错，但 mustHas 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="13、删除空项（compact-mustCompact）"><a href="#13、删除空项（compact-mustCompact）" class="headerlink" title="13、删除空项（compact, mustCompact）"></a>13、删除空项（compact, mustCompact）</h4><p>接收一个列表并删除空值项。<br>    $list :&#x3D; list 1 “a” “foo” “”<br>    $copy :&#x3D; compact $list</p>
<p>compact 会返回一个移除了空值(比如， “”)的新列表。</p>
<blockquote>
<p>compact 有问题时会出错，但 mustCompact 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="14、index"><a href="#14、index" class="headerlink" title="14、index"></a>14、index</h4><p>使用 index list [n]获取列表的第 n 个元素。使用 index list [n] [m] …获取多位列表元素。</p>
<ul>
<li>index $myList 0 返回 1，同 myList[0]</li>
<li>index $myList 0 1 同 myList[0][1]</li>
</ul>
<h4 id="15、获取部分元素（slice-mustSlice）"><a href="#15、获取部分元素（slice-mustSlice）" class="headerlink" title="15、获取部分元素（slice, mustSlice）"></a>15、获取部分元素（slice, mustSlice）</h4><p>从列表中获取部分元素，使用 slice list [n] [m]。等同于 list[n:m].</p>
<ul>
<li>slice $myList 返回 [1 2 3 4 5]。等同于 myList[:]。</li>
<li>slice $myList 3 返回 [4 5]等同于 myList[3:]。</li>
<li>slice $myList 1 3 返回 [2 3]等同于 myList[1:3]。</li>
<li>slice $myList 0 3 返回 [1 2 3]等同于 myList[:3]。</li>
</ul>
<blockquote>
<p>slice 有问题时会出错，但 mustSlice 有问题时会向模板引擎返回错误。</p>
</blockquote>
<h4 id="16、构建一个整数列表（until）"><a href="#16、构建一个整数列表（until）" class="headerlink" title="16、构建一个整数列表（until）"></a>16、构建一个整数列表（until）</h4><p>until 函数构建一个整数范围。<br>    until 5</p>
<p>上述语句会生成一个列表：[0, 1, 2, 3, 4]。</p>
<p>对循环语句很有用：range e :&#x3D; until 5。</p>
<h4 id="17、seq"><a href="#17、seq" class="headerlink" title="17、seq"></a>17、seq</h4><pre><code>seq 5       =&gt; 1 2 3 4 5
seq -3      =&gt; 1 0 -1 -2 -3
seq 0 2     =&gt; 0 1 2
seq 2 -2    =&gt; 2 1 0 -1 -2
seq 0 2 10  =&gt; 0 2 4 6 8 10
seq 0 -2 -5 =&gt; 0 -2 -4
</code></pre>
<h3 id="9）数学函数（Math-Functions）"><a href="#9）数学函数（Math-Functions）" class="headerlink" title="9）数学函数（Math Functions）"></a>9）数学函数（Math Functions）</h3><h4 id="1、求和（add）"><a href="#1、求和（add）" class="headerlink" title="1、求和（add）"></a>1、求和（add）</h4><p>使用 add 求和。接受两个或多个输入。</p>
<pre><code>add 1 2 3
</code></pre>
<h4 id="2、自加-1（add1）"><a href="#2、自加-1（add1）" class="headerlink" title="2、自加 1（add1）"></a>2、自加 1（add1）</h4><p>自增加 1，使用 add1。</p>
<h4 id="3、相减（sub）"><a href="#3、相减（sub）" class="headerlink" title="3、相减（sub）"></a>3、相减（sub）</h4><p>相减使用 sub。</p>
<h4 id="4、除（div）"><a href="#4、除（div）" class="headerlink" title="4、除（div）"></a>4、除（div）</h4><p>整除使用 div。</p>
<h4 id="5、取模（mod）"><a href="#5、取模（mod）" class="headerlink" title="5、取模（mod）"></a>5、取模（mod）</h4><p>取模使用 mod。</p>
<h4 id="6、相乘（mul）"><a href="#6、相乘（mul）" class="headerlink" title="6、相乘（mul）"></a>6、相乘（mul）</h4><p>相乘使用 mul。接受两个或多个输入。<br>    mul 1 2 3</p>
<h4 id="7、获取最大值（max）"><a href="#7、获取最大值（max）" class="headerlink" title="7、获取最大值（max）"></a>7、获取最大值（max）</h4><p>返回一组整数中最大的整数。<br>    max 1 2 3<br>    # 返回 3</p>
<h4 id="8、获取最小值（min）"><a href="#8、获取最小值（min）" class="headerlink" title="8、获取最小值（min）"></a>8、获取最小值（min）</h4><p>返回一组数中最小的数。<br>    min 1 2 3<br>    # 会返回 1。</p>
<h4 id="9、获取长度（len）"><a href="#9、获取长度（len）" class="headerlink" title="9、获取长度（len）"></a>9、获取长度（len）</h4><p>以整数返回参数的长度。<br>    len .Arg</p>
<h4 id="10、Network-Functions"><a href="#10、Network-Functions" class="headerlink" title="10、Network Functions"></a>10、Network Functions</h4><p>Helm 提供了几个网络函数：</p>
<ul>
<li><code>getHostByName</code>接收一个域名返回 IP 地址。</li>
<li><code>getHostByName</code> “<a href="http://www.google.com"会返回对应的/">www.google.com"会返回对应的</a> <a href="http://www.google.com/">www.google.com</a> 的地址。</li>
</ul>
<h3 id="10）条件语句"><a href="#10）条件语句" class="headerlink" title="10）条件语句"></a>10）条件语句</h3><p><strong>运算符：</strong></p>
<pre><code>eq: 等于（equal to）
ne: 不等于（not equal to）
lt: 小于（less than）
le: 小于等于（less than or equal to）
gt: 大于（greater than）
ge: 大于等于（greater than or equal to）
</code></pre>
<p><strong>if&#x2F;else 用法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &#123;&#123;if 命令&#125;&#125;</span><br><span class="line">    …</span><br><span class="line">    &#123;&#123;else if 命令&#125;&#125;</span><br><span class="line">    …</span><br><span class="line">    &#123;&#123;else&#125;&#125;</span><br><span class="line">    …</span><br><span class="line">    &#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line">如果是以下值时，管道会被设置为 false：</span><br><span class="line">    布尔false</span><br><span class="line">    数字0</span><br><span class="line">    空字符串</span><br><span class="line">    nil (空或null)</span><br><span class="line">    空集合(map, slice, tuple, dict, array)</span><br><span class="line"></span><br><span class="line">【示例】</span><br><span class="line">    apiVersion: v1</span><br><span class="line">    kind: ConfigMap</span><br><span class="line">    metadata:</span><br><span class="line">      name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">    data:</span><br><span class="line">      myvalue: &quot;Hello World&quot;</span><br><span class="line">      drink: &#123;&#123; .Values.favorite.drink | default &quot;tea&quot; | quote &#125;&#125;</span><br><span class="line">      food: &#123;&#123; .Values.favorite.food | upper | quote &#125;&#125;</span><br><span class="line">      &#123;&#123; if eq .Values.favorite.drink &quot;coffee&quot; &#125;&#125;mug: &quot;true&quot;&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11）变更作用域-with"><a href="#11）变更作用域-with" class="headerlink" title="11）变更作用域 with"></a>11）变更作用域 with</h3><blockquote>
<p>下一个控制结构是<code>with</code>操作。这个用来<strong>控制变量范围</strong>。回想一下，<code>.</code>是对 当前作用域 的引用。因此 <code>.Values</code>就是告诉模板在当前作用域查找 Values 对象。</p>
</blockquote>
<p>with 的语法与 if 语句类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; with PIPELINE &#125;&#125;</span><br><span class="line">  # restricted scope</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>作用域可以被改变。with 允许你为特定对象设定当前作用域(<code>.</code>)。比如，我们已经在使用.Values.favorite。修改配置映射中的.的作用域指向.Values.favorite：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  &#123;&#123;- with .Values.favorite &#125;&#125;</span><br><span class="line">  drink: &#123;&#123; .drink | default &quot;tea&quot; | quote &#125;&#125;</span><br><span class="line">  food: &#123;&#123; .food | upper | quote &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>但是这里有个注意事项，在限定的作用域内，<strong>无法使用.访问父作用域</strong>的对象。错误示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- with .Values.favorite &#125;&#125;</span><br><span class="line">drink: &#123;&#123; .drink | default &quot;tea&quot; | quote &#125;&#125;</span><br><span class="line">food: &#123;&#123; .food | upper | quote &#125;&#125;</span><br><span class="line">release: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这样会报错因为<code>Release.Name</code><strong>不在<code>.</code>限定的作用域内</strong>。但是如果对调最后两行就是正常的， 因为在之后作用域被重置了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- with .Values.favorite &#125;&#125;</span><br><span class="line">drink: &#123;&#123; .drink | default &quot;tea&quot; | quote &#125;&#125;</span><br><span class="line">food: &#123;&#123; .food | upper | quote &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">release: &#123;&#123; .Release.Name &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>或者，我们可以使用<code>$$</code><strong>从父作用域中访问 Release.Name 对象</strong>。当模板开始执行后<code>$$</code>会被映射到<strong>根作用域</strong>，且执行过程中不会更改。下面这种方式也可以正常工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- with .Values.favorite &#125;&#125;</span><br><span class="line">drink: &#123;&#123; .drink | default &quot;tea&quot; | quote &#125;&#125;</span><br><span class="line">food: &#123;&#123; .food | upper | quote &#125;&#125;</span><br><span class="line">release: &#123;&#123; $.Release.Name &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在外边定义变量，遵循<code>$name变量</code>的格式且指定了一个特殊的赋值运算符：<code>:=</code>。我们可以使用针对 Release.Name 的变量重写上述内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  &#123;&#123;- $relname := .Release.Name -&#125;&#125;</span><br><span class="line">  &#123;&#123;- with .Values.favorite &#125;&#125;</span><br><span class="line">  drink: &#123;&#123; .drink | default &quot;tea&quot; | quote &#125;&#125;</span><br><span class="line">  food: &#123;&#123; .food | upper | quote &#125;&#125;</span><br><span class="line">  release: &#123;&#123; $relname &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意在 with 块开始之前，赋值<code>$relname := .Release.Name</code>。现在在 with 块中，$relname 变量仍会执行版本名称。</p>
</blockquote>
<h3 id="12）rang-循环语句"><a href="#12）rang-循环语句" class="headerlink" title="12）rang 循环语句"></a>12）rang 循环语句</h3><p>很多编程语言支持使用 for 循环，foreach 循环，或者类似的方法机制。在 Helm 的模板语言中，在一个集合中迭代的方式是使用<code>range</code>操作符。</p>
<p>定义 values<br>    favorite:<br>      drink: coffee<br>      food: pizza<br>    pizzaToppings:<br>      - mushrooms<br>      - cheese<br>      - peppers<br>      - onions</p>
<p>现在我们有了一个 pizzaToppings 列表（模板中称为切片）。修改模板把这个列表打印到配置映射中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  &#123;&#123;- with .Values.favorite &#125;&#125;</span><br><span class="line">  drink: &#123;&#123; .drink | default &quot;tea&quot; | quote &#125;&#125;</span><br><span class="line">  food: &#123;&#123; .food | upper | quote &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br><span class="line">  toppings: |-</span><br><span class="line">    &#123;&#123;- range .Values.pizzaToppings &#125;&#125;</span><br><span class="line">    - &#123;&#123; . | title | quote &#125;&#125;</span><br><span class="line">    &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>有时能在模板中快速创建列表然后迭代很有用，Helm 模板的 tuple 可以很容易实现该功能。在计算机科学中， 元组表示一个有固定大小的类似列表的集合，但可以是任意数据类型。这大致表达了<code>tuple</code>的用法。</p>
<pre><code>  sizes: |-
    &#123;&#123;- range tuple "small" "medium" "large" &#125;&#125;
    - &#123;&#123; . &#125;&#125;
    &#123;&#123;- end &#125;&#125;
</code></pre>
<p>上述模板会生成以下内容：</p>
<pre><code>  sizes: |-
    - small
    - medium
    - large
</code></pre>
<h3 id="13）命名模板"><a href="#13）命名模板" class="headerlink" title="13）命名模板"></a>13）命名模板</h3><blockquote>
<p>此时需要越过模板，开始创建其他内容了。该部分我们会看到如何在一个文件中定义 命名模板，并在其他地方使用。<strong>命名模板</strong> (有时称作一个 部分 或一个 子模板)仅仅是在文件内部定义的模板，并使用了一个名字。有两种创建方式和几种不同的使用方法。</p>
</blockquote>
<ul>
<li>三种声明和管理模板的方法：<code>define</code>，<code>template</code>，和<code>block</code>，在这部分，我们将使用这三种操作并介绍一种特殊用途的 <code>include</code>方法，类似于 template 操作。</li>
<li>命名模板时要记住一个重要细节：<strong>模板名称是全局的</strong>。如果您想声明两个相同名称的模板，<strong>哪个最后加载就使用哪个</strong>。因为在子 chart 中的模板和顶层模板一起编译，命名时要注意 chart 特定名称。</li>
<li>一个常见的命名惯例是用 chart 名称作为模板前缀：<code>&#123;&#123; define "mychart.labels" &#125;&#125;</code>。使用<strong>特定 chart 名称作为前缀</strong>可以<strong>避免可能因为 两个不同 chart 使用了相同名称的模板</strong>而引起的冲突。</li>
</ul>
<p>在编写模板细节之前，文件的命名惯例需要注意：</p>
<ul>
<li>templates&#x2F;中的大多数文件被视为包含 Kubernetes 清单</li>
<li>NOTES.txt 是个例外</li>
<li>命名以下划线(<code>_</code>)开始的文件则假定 没有 包含清单内容。这些文件不会渲染为 Kubernetes 对象定义，但在其他 chart 模板中都可用。</li>
</ul>
<blockquote>
<p>这些文件用来存储局部和辅助对象，实际上当我们第一次创建 mychart 时，会看到一个名为<code>_helpers.tpl</code>的文件，这个文件是<strong>模板局部的默认位置</strong>。</p>
</blockquote>
<h4 id="1、用-define-和-template-声明和使用模板"><a href="#1、用-define-和-template-声明和使用模板" class="headerlink" title="1、用 define 和 template 声明和使用模板"></a>1、用 define 和 template 声明和使用模板</h4><p>define 操作允许我们在模板文件中创建一个命名模板，<strong>语法</strong>如下：</p>
<pre><code>&#123;&#123;- define "MY.NAME" &#125;&#125;
  # body of template here
&#123;&#123;- end &#125;&#125;
</code></pre>
<p>比如我们可以定义一个模板封装 Kubernetes 的标签：</p>
<pre><code>&#123;&#123;- define "mychart.labels" &#125;&#125;
  labels:
    generator: helm
    date: &#123;&#123; now | htmlDate &#125;&#125;
&#123;&#123;- end &#125;&#125;
</code></pre>
<p>现在我们将模板嵌入到了已有的配置映射中，然后使用<code>template</code>包含进来：</p>
<pre><code>&#123;&#123;- define "mychart.labels" &#125;&#125;
  labels:
    generator: helm
    date: &#123;&#123; now | htmlDate &#125;&#125;
&#123;&#123;- end &#125;&#125;
apiVersion: v1
kind: ConfigMap
metadata:
  name: &#123;&#123; .Release.Name &#125;&#125;-configmap
  &#123;&#123;- template "mychart.labels" &#125;&#125;
data:
  myvalue: &quot;Hello World&quot;
  &#123;&#123;- range $key, $val := .Values.favorite &#125;&#125;
  &#123;&#123; $key &#125;&#125;: &#123;&#123; $val | quote &#125;&#125;
  &#123;&#123;- end &#125;&#125;
</code></pre>
<p>当模板引擎读取该文件时，它会存储 mychart.labels 的引用直到 template “mychart.labels”被调用。然后会按行渲染模板，因此结果类似这样：</p>
<pre><code># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: running-panda-configmap
  labels:
    generator: helm
    date: 2022-09-04
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;pizza&quot;
</code></pre>
<blockquote>
<p>注意：define 不会有输出，除非像本示例一样用模板调用它。</p>
</blockquote>
<p>按照惯例，Helm chart 将这些模板放置在局部文件中，一般是<code>_helpers.tpl</code>。把这个方法移到那里：</p>
<pre><code>&#123;&#123;/* Generate basic labels */&#125;&#125;
&#123;&#123;- define "mychart.labels" &#125;&#125;
  labels:
    generator: helm
    date: &#123;&#123; now | htmlDate &#125;&#125;
&#123;&#123;- end &#125;&#125;
</code></pre>
<h4 id="2、设置模板范围"><a href="#2、设置模板范围" class="headerlink" title="2、设置模板范围"></a>2、设置模板范围</h4><p>在上面定义的模板中，我们没有使用任何对象，仅仅使用了方法。修改定义好的模板让其包含 chart 名称和版本号：</p>
<pre><code>&#123;&#123;/* Generate basic labels */&#125;&#125;
&#123;&#123;- define "mychart.labels" &#125;&#125;
  labels:
    generator: helm
    date: &#123;&#123; now | htmlDate &#125;&#125;
    chart: &#123;&#123; .Chart.Name &#125;&#125;
    version: &#123;&#123; .Chart.Version &#125;&#125;
&#123;&#123;- end &#125;&#125;
</code></pre>
<h4 id="3、include-方法"><a href="#3、include-方法" class="headerlink" title="3、include 方法"></a>3、include 方法</h4><p>假设定义了一个简单模板如下：</p>
<pre><code>&#123;&#123;- define "mychart.app" -&#125;&#125;
app_name: &#123;&#123; .Chart.Name &#125;&#125;
app_version: &quot;&#123;&#123; .Chart.Version &#125;&#125;&quot;
&#123;&#123;- end -&#125;&#125;
</code></pre>
<p>现在假设我想把这个插入到模板的 labels:部分和 data:部分：</p>
<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: &#123;&#123; .Release.Name &#125;&#125;-configmap
  labels:
    &#123;&#123; template "mychart.app" . &#125;&#125;
data:
  myvalue: &quot;Hello World&quot;
  &#123;&#123;- range $key, $val := .Values.favorite &#125;&#125;
  &#123;&#123; $key &#125;&#125;: &#123;&#123; $val | quote &#125;&#125;
  &#123;&#123;- end &#125;&#125;
&#123;&#123; template "mychart.app" . &#125;&#125;
</code></pre>
<p>如果渲染这个，会得到以下错误：</p>
<pre><code>$ helm install --dry-run measly-whippet ./mychart
Error: unable to build kubernetes objects from release manifest: error validating &quot;&quot;: error validating data: [ValidationError(ConfigMap): unknown field &quot;app_name&quot; in io.k8s.api.core.v1.ConfigMap, ValidationError(ConfigMap): unknown field &quot;app_version&quot; in io.k8s.api.core.v1.ConfigMap]
</code></pre>
<p>要查看渲染了什么，可以用<code>--disable-openapi-validation</code>参数重新执行：<code>helm install --dry-run --disable-openapi-validation measly-whippet ./mychart</code>。输入不是我们想要的：</p>
<pre><code># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: measly-whippet-configmap
  labels:
    app_name: mychart
app_version: &quot;0.1.0&quot;
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;pizza&quot;
app_name: mychart
app_version: &quot;0.1.0&quot;
</code></pre>
<blockquote>
<p>注意两处的<strong>app_version 缩进都不对</strong>，为啥？因为被替换的模板中文本是左对齐的。由于<code>template</code>是一个行为，<strong>不是方法</strong>，<strong>无法将 <code>template</code>调用的输出传给其他方法，数据只是简单地按行插入</strong>。</p>
</blockquote>
<p>为了处理这个问题，Helm 提供了一个<code>include</code>，可以将模板内容导入当前管道，然后传递给管道中的其他方法。下面这个示例，使用<code>indent</code>正确地缩进了 mychart.app 模板：</p>
<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: &#123;&#123; .Release.Name &#125;&#125;-configmap
  labels:
&#123;&#123; include "mychart.app" . | indent 4 &#125;&#125;
data:
  myvalue: &quot;Hello World&quot;
  &#123;&#123;- range $key, $val := .Values.favorite &#125;&#125;
  &#123;&#123; $key &#125;&#125;: &#123;&#123; $val | quote &#125;&#125;
  &#123;&#123;- end &#125;&#125;
&#123;&#123; include "mychart.app" . | indent 2 &#125;&#125;
</code></pre>
<p>现在生成的 YAML 每一部分都可以正确缩进了：</p>
<pre><code># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: edgy-mole-configmap
  labels:
    app_name: mychart
    app_version: &quot;0.1.0&quot;
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;pizza&quot;
  app_name: mychart
  app_version: &quot;0.1.0&quot;
</code></pre>
<blockquote>
<p><code>include</code> 相较于使用 template，在 helm 中<strong>使用 include 被认为是更好的方式</strong> 只是为了更好地处理 YAML 文档的输出格式。</p>
</blockquote>
<h3 id="14）NOTES-txt-文件"><a href="#14）NOTES-txt-文件" class="headerlink" title="14）NOTES.txt 文件"></a>14）NOTES.txt 文件</h3><blockquote>
<p>该部分会<strong>介绍为 chart 用户提供说明的 Helm 工具</strong>。在 helm install 或 helm upgrade 命令的最后，<strong>Helm 会打印出对用户有用的信息</strong>。使用模板可以高度自定义这部分信息。</p>
</blockquote>
<p>要在 chart 添加安装说明，只需创建<code>templates/NOTES.txt</code>文件即可。<strong>该文件是纯文本，但会像模板一样处理</strong>， 所有正常的模板函数和对象都是可用的。让我们创建一个简单的 NOTES.txt 文件：</p>
<pre><code>Thank you for installing &#123;&#123; .Chart.Name &#125;&#125;.

Your release is named &#123;&#123; .Release.Name &#125;&#125;.

To learn more about the release, try:

  $ helm status &#123;&#123; .Release.Name &#125;&#125;
  $ helm get all &#123;&#123; .Release.Name &#125;&#125;
</code></pre>
<p>现在如果我们执行 helm install rude-cardinal .&#x2F;mychart 会在底部看到：</p>
<pre><code>RESOURCES:
==&gt; v1/Secret
NAME                   TYPE      DATA      AGE
rude-cardinal-secret   Opaque    1         0s

==&gt; v1/ConfigMap
NAME                      DATA      AGE
rude-cardinal-configmap   3         0s


NOTES:
Thank you for installing mychart.

Your release is named rude-cardinal.

To learn more about the release, try:

  $ helm status rude-cardinal
  $ helm get all rude-cardinal
</code></pre>
<blockquote>
<p>使用 NOTES.txt 这种方式是给用户提供关于如何使用新安装的 chart 细节信息的好方法。尽管并不是必需的，<strong>强烈建议创建一个<code>NOTES.txt</code>文件</strong>。</p>
</blockquote>
<h3 id="15）模板调试"><a href="#15）模板调试" class="headerlink" title="15）模板调试"></a>15）模板调试</h3><p>调试模板可能很棘手，因为渲染后的模板发送给了 Kubernetes API server，可能会以格式化以外的原因拒绝 YAML 文件。以下命令有助于调试：</p>
<ul>
<li><code>helm lint</code> 是验证 chart 是否遵循最佳实践的首选工具</li>
<li><code>helm install --dry-run --debug</code> 或 <code>helm template --debug</code>：我们已经看过这个技巧了， 这是让服务器渲染模板的好方法，然后返回生成的清单文件。</li>
<li><code>helm get manifest</code>: 这是查看安装在服务器上的模板的好方法。</li>
</ul>
<p>当你的 YAML 文件解析失败，但你想知道生成了什么，检索 YAML 一个简单的方式是<strong>注释掉模板中有问题的部分</strong>， 然后重新运行 <code>helm install --dry-run --debug</code>：</p>
<pre><code>apiVersion: v2
# some: problem section
# &#123;&#123; .Values.foo | quote &#125;&#125;
</code></pre>
<p>以上内容会被渲染同时返回完整的注释：</p>
<pre><code>apiVersion: v2
# some: problem section
#  &quot;bar&quot;
</code></pre>
<p>其实这里主要是正对官方文档进行整理，列出了常见的使用语法，想了解更多，可以参考官方文档，</p>
]]></content>
      <categories>
        <category>kubernetes</category>
        <category>Helm</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>Helm</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet垃圾回收机制</title>
    <url>/2022/12/29/kubelet%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202210111058394.jpeg" alt="图片"></p>
<h3 id="一、Tips"><a href="#一、Tips" class="headerlink" title="一、Tips"></a><strong>一、Tips</strong></h3><ol>
<li>Kubernetes的垃圾回收由kubelet进行管理，每分钟会查询清理一次容器，每五分钟查询清理一次镜像。在kubelet刚启动时并不会立即进行GC，即第一次进行容器回收为kubelet启动一分钟后，第一次进行镜像回收为kubelet启动五分钟后。</li>
<li>不推荐使用其它管理工具或手工进行容器和镜像的清理，因为kubelet需要通过容器来判断pod的运行状态，如果使用其它方式清除容器有可能影响kubelet的正常工作。</li>
<li>镜像的回收针对node结点上由docker管理的所有镜像，无论该镜像是否是在创建pod时pull的。而容器的回收策略只应用于通过kubelet管理的容器。</li>
<li>Kubernetes通过kubelet集成的cadvisor进行镜像的回收，有两个参数可以设置：<code>--image-gc-high-threshold</code>和<code>--image-gc-low-threshold</code>。当用于存储镜像的磁盘使用率达到百分之–image-gc-high-threshold时将触发镜像回收，删除最近最久未使用（LRU，Least Recently Used）的镜像直到磁盘使用率降为百分之<code>--image-gc-low-threshold</code>或无镜像可删为止。默认<code>--image-gc-high-threshold</code>为90，&#96;&#96;–image-gc-low-threshold&#96;为80。</li>
<li>容器的回收有三个参数可设置：<code>--minimum-container-ttl-duration</code>，<code>--maximum-dead-containers-per-container</code>和<code>--maximum-dead-containers</code>。从容器停止运行时起经过<code>--minimum-container-ttl-duration</code>时间后，该容器标记为已过期将来可以被回收（只是标记，不是回收），默认值为1m0s。一般情况下每个pod最多可以保留<code>--maximum-dead-containers-per-container</code>个已停止运行的容器集，默认值为2。整个node节点可以保留<code>--maximum-dead-containers</code>个已停止运行的容器，默认值为100。</li>
<li>如果需要关闭容器的垃圾回收策略，可以将<code>--minimum-container-ttl-duration</code>设为0（表示无限制），<code>--maximum-dead-containers-per-container</code>和<code>--maximum-dead-containers</code>设为负数。</li>
<li><code>--minimum-container-ttl-duration</code>的值可以使用单位后缀，如h表示小时，m表示分钟，s表示秒。</li>
<li>当<code>--maximum-dead-containers-per-container</code>和<code>--maximum-dead-containers</code>冲突时，&#96;&#96;–maximum-dead-containers&#96;优先考虑。</li>
<li>对于那些由kubelet创建的但由于某些原因导致无名字（）的容器，会在到达GC时间点时被删除。</li>
<li>回收容器时，按创建时间排序，优先删除那些创建时间最早的容器。</li>
<li>到达GC时间点时，具体的GC过程如下：1）遍历所有pod，使其满足<code>--maximum-dead-containers-per-container</code>；2）经过上一步后如果不满足<code>--maximum-dead-containers</code>，计算值<code>X=（--maximum-dead-containers）/（pod总数）</code>，再遍历所有pod，使其满足已停止运行的容器集个数不大于X且至少为1；3）经过以上两步后如果还不满足<code>--maximum-dead-containers</code>，则对所有已停止的容器排序，优先删除创建时间最早的容器直到满足<code>--maximum-dead-containers</code>为止。</li>
<li>当某个镜像重新pull或启动某个pod用到该镜像时，该镜像的最近使用时间都会被更新。</li>
<li>Kubernetes的垃圾回收在1.1.4版本开始才渐渐完善，之前的版本存在比较多bug甚至不能发挥作用。</li>
<li>关于容器的回收需要特别注意pod的概念，比如，通过同一个yaml文件create一个pod，再delete这个pod，然后再create这个pod，此时之前的那个pod对应的容器并不会作为新创建pod的已停止容器集，因为这两个pod虽然同名，但已经不是同一个pod了。只有同一个pod中在运行过程中由于意外或其它情况停止的容器才算是这个pod的已停止容器集。</li>
</ol>
<h3 id="二、Experiments"><a href="#二、Experiments" class="headerlink" title="二、Experiments"></a><strong>二、Experiments</strong></h3><ol>
<li>镜像回收（使用docker默认 <code>--graph</code> 参数：<code>/var/lib/docker</code>）</li>
</ol>
<p>结点上运行的docker设置的参数 <code>--graph</code> 使用默认的<code>/var/lib/docker</code>，指向&#x2F;var文件系统，通过df -lh查看目前 &#x2F;var 磁盘使用率为30%，启动kubelet设置镜像回收相关参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--image-gc-high-threshold=40 --image-gc-low-threshold=35</span><br></pre></td></tr></table></figure>

<p>此时任意创建两个使用不同镜像的pod，在node节点上可以看到新pull了三个images（pause镜像是启动pod必需的）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /opt/domeos/openxxs/k8s-1.1.7-flannel]# docker images</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">10.11.150.76:5000/openxxs/iperf   1.2                 1783511c56f8        3 months ago        279 MB</span><br><span class="line">10.11.150.76:5000/centos          7                   5ddf34d4d69b        8 months ago        172.2 MB</span><br><span class="line">pub.domeos.org/kubernetes/pause   latest              f9d5de079539        20 months ago       239.8 kB</span><br></pre></td></tr></table></figure>

<p>此时查看&#x2F;var磁盘使用率达到了41%，然后将使用<code>10.11.150.76:5000/centos:7</code>镜像的pod删除，等待GC的镜像回收时间点。然而五分钟过去了，什么事情也没有发生&#x3D;_&#x3D;!!。还记得 docker rmi 镜像时有个前提条件是什么吗？没错，要求使用该镜像的容器都已经被删除了才可以。前面删除pod只是停止了容器，并没有将容器删除。因此手工将对应的容器docker rm掉，再等待五分钟后，可以看到镜像已经被删除回收了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /opt/domeos/openxxs/k8s-1.1.7-flannel]# docker images</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">10.11.150.76:5000/openxxs/iperf   1.2                 1783511c56f8        3 months ago        279 MB</span><br><span class="line">pub.domeos.org/kubernetes/pause   latest              f9d5de079539        20 months ago       239.8 kB</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：只有相关联的容器都被停止并删除回收后，才能将Kubernetes的镜像垃圾回收策略应用到该镜像上。</p>
</blockquote>
<ol>
<li>镜像回收（使用自定义docker <code>--graph</code> 参数：<code>/opt/docker</code>）</li>
</ol>
<p>结点上运行的docker设置的参数<code>--graph</code>指向 &#x2F;opt 磁盘，通过 df -lh 查看目前 &#x2F;opt 磁盘使用率为 48% ，启动 kubelet 设置镜像回收相关参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--image-gc-high-threshold=50 --image-gc-low-threshold=40</span><br></pre></td></tr></table></figure>

<p>此时任意创建两个使用不同镜像的pod，在node节点上可以看到新pull了三个images：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /opt/domeos/openxxs/k8s-1.1.7-flannel]# docker images</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">10.11.150.76:5000/openxxs/iperf   1.2                 1783511c56f8        3 months ago        279 MB</span><br><span class="line">10.11.150.76:5000/centos          7                   5ddf34d4d69b        8 months ago        172.2 MB</span><br><span class="line">pub.domeos.org/kubernetes/pause   latest              f9d5de079539        20 months ago       239.8 kB</span><br></pre></td></tr></table></figure>

<p>此时查看&#x2F;opt磁盘使用率达到了51%，然后将使用10.11.150.76:5000&#x2F;centos:7镜像的pod删除，手工将对应的容器docker rm掉，等待GC的镜像回收时间点。然而五分钟过去了，十分钟过去了，docker images时centos镜像依旧顽固地坚守在阵地。</p>
<blockquote>
<p>结论：目前Kubernetes的镜像垃圾回收策略可以在docker  <code>--graph</code> 参数默认为 <code>/var/lib/docker</code> 时正常工作，当 <code>--graph</code> 设置为其它磁盘路径时还存在bug。</p>
</blockquote>
<p>问题反馈在 Github 的相关 issue 里：<a href="https://github.com/kubernetes/kubernetes/issues/17994">https://github.com/kubernetes/kubernetes/issues/17994</a>，可以继续跟进。</p>
<p>Append: 根据Github上的反馈，这个bug将在后续版本中解决，目前版本需要让设置了–graph的镜像垃圾回收生效，在启动kubelet时还需要加上参数 <code>--docker-root=&lt;docker --graph参数值&gt;</code>。</p>
<ol>
<li>容器回收之 <code>--maximum-dead-containers-per-container</code> 参数</li>
</ol>
<p>启动kubelet设置容器回收相关参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--maximum-dead-containers-per-container=1 --minimum-container-ttl-duration=30s --maximum-dead-containers=100</span><br></pre></td></tr></table></figure>

<p>创建一个只包含一个容器且该容器一运行就退出的pod，此时在node节点上可以看到该pod中的容器不断的创建退出创建退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /home/domeos]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                    COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">2fe969499164        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         4 seconds ago       Exited (0) 2 seconds ago                        k8s_iperf1.57dfe29d_test-gc-pod-exit_default_92e8bd05-e9e6-11e5-974c-782bcb2a316a_68cc6f03</span><br><span class="line">555b5e7a8550        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         24 seconds ago      Exited (0) 22 seconds ago                       k8s_iperf1.57dfe29d_test-gc-pod-exit_default_92e8bd05-e9e6-11e5-974c-782bcb2a316a_ad4a5e39</span><br><span class="line">94b30a0b32c2        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         34 seconds ago      Exited (0) 32 seconds ago                       k8s_iperf1.57dfe29d_test-gc-pod-exit_default_92e8bd05-e9e6-11e5-974c-782bcb2a316a_4027e3e1</span><br><span class="line">d458e6a7d396        pub.domeos.org/kubernetes/pause:latest   &quot;/pause&quot;            34 seconds ago      Up 33 seconds                                   k8s_POD.bdb2e1f5_test-gc-pod-exit_default_92e8bd05-e9e6-11e5-974c-782bcb2a316a_09798975</span><br></pre></td></tr></table></figure>

<p>GC的容器回收时间点到达时，可以看到创建时间大于30秒的已退出容器只剩下一个（pause容器不计算），且先创建的容器被优先删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /home/domeos]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                    COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">5aae6157aeff        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         46 seconds ago      Exited (0) 45 seconds ago                       k8s_iperf1.57dfe29d_test-gc-pod-exit_default_92e8bd05-e9e6-11e5-974c-782bcb2a316a_f126d2a8</span><br><span class="line">d458e6a7d396        pub.domeos.org/kubernetes/pause:latest   &quot;/pause&quot;            2 minutes ago       Up 2 minutes                                    k8s_POD.bdb2e1f5_test-gc-pod-exit_default_92e8bd05-e9e6-11e5-974c-782bcb2a316a_09798975</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：Kubernetes容器垃圾回收的<code>--maximum-dead-containers-per-container</code>参数设置可正常工作。</p>
</blockquote>
<ol>
<li><code>--maximum-dead-containers-per-container</code> 针对容器还是容器集</li>
</ol>
<p>启动kubelet设置容器回收相关参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--maximum-dead-containers-per-container=1 --minimum-container-ttl-duration=30s --maximum-dead-containers=100</span><br></pre></td></tr></table></figure>

<p>创建一个包含三个容器且这些容器一运行就退出的pod，此时在node节点上可以看到该pod中的容器不断的创建退出创建退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /home/domeos]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                    COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">dec04bd28a03        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         7 seconds ago       Exited (0) 6 seconds ago                        k8s_iperf1.57dfe29d_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_830a9375</span><br><span class="line">7c94d4a963a7        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         7 seconds ago       Exited (0) 6 seconds ago                        k8s_iperf3.5c8de29f_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_975d44d3</span><br><span class="line">4f3e7e8ddfd5        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         8 seconds ago       Exited (0) 7 seconds ago                        k8s_iperf2.5a36e29e_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_d024eb06</span><br><span class="line">cb48cf2ba133        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         12 seconds ago      Exited (0) 11 seconds ago                       k8s_iperf3.5c8de29f_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_b5ff7373</span><br><span class="line">ec2941f046f0        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         13 seconds ago      Exited (0) 12 seconds ago                       k8s_iperf2.5a36e29e_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_69b1a996</span><br><span class="line">f831e8ed5687        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         13 seconds ago      Exited (0) 12 seconds ago                       k8s_iperf1.57dfe29d_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_fbc02e2e</span><br><span class="line">ee972a4537fc        pub.domeos.org/kubernetes/pause:latest   &quot;/pause&quot;            14 seconds ago      Up 13 seconds                                   k8s_POD.bdb2e1f5_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_85b3c032</span><br></pre></td></tr></table></figure>

<p>GC的容器回收时间点到达时，可以看到创建时间大于30秒的已退出容器剩下三个（pause容器不计算），且这三个容器正好是一组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /home/domeos]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                    COMMAND             CREATED              STATUS                      PORTS               NAMES</span><br><span class="line">e4351e6855ae        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         51 seconds ago       Exited (0) 50 seconds ago                       k8s_iperf3.5c8de29f_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_263dd820</span><br><span class="line">990baa6e6a7a        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         52 seconds ago       Exited (0) 51 seconds ago                       k8s_iperf2.5a36e29e_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_b16b5eaa</span><br><span class="line">c6916fb06d65        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         53 seconds ago       Exited (0) 51 seconds ago                       k8s_iperf1.57dfe29d_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_1d8ea284</span><br><span class="line">ee972a4537fc        pub.domeos.org/kubernetes/pause:latest   &quot;/pause&quot;            About a minute ago   Up About a minute                               k8s_POD.bdb2e1f5_test-gc-pod-exit_default_d1677c09-e9e7-11e5-974c-782bcb2a316a_85b3c032</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：<code>--maximum-dead-containers-per-container</code> 的计数针对一个pod内的容器集而不是容器的个数。</p>
</blockquote>
<ol>
<li>容器回收之 <code>--maximum-dead-containers</code> 参数</li>
</ol>
<p>启动kubelet设置容器回收相关参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--maximum-dead-containers-per-container=2 --minimum-container-ttl-duration=30s --maximum-dead-containers=3</span><br></pre></td></tr></table></figure>

<p>创建一个包含三个容器的pod，再删除该pod，再创建该pod，再删除该pod，这样就产生了8个已退出容器（包括两个pause容器）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /home/domeos]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                    COMMAND             CREATED             STATUS                              PORTS               NAMES</span><br><span class="line">a28625d189df        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         1 seconds ago       Exited (0) Less than a second ago                       k8s_iperf3.5c8de29f_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_48c11200</span><br><span class="line">97aca44f0deb        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         2 seconds ago       Exited (0) 1 seconds ago                                k8s_iperf2.5a36e29e_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_df34f48d</span><br><span class="line">4e57b6c839ae        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         3 seconds ago       Exited (0) 2 seconds ago                                k8s_iperf1.57dfe29d_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_afd622b2</span><br><span class="line">12588fce1433        pub.domeos.org/kubernetes/pause:latest   &quot;/pause&quot;            3 seconds ago       Exited (2) Less than a second ago                       k8s_POD.bdb2e1f5_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_c9d4cbaa</span><br><span class="line">621ed207d452        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         4 seconds ago       Exited (0) 3 seconds ago                                k8s_iperf3.5c8de29f_test-gc-pod-exit_default_c5cbddbb-e9ee-11e5-974c-782bcb2a316a_a91278cd</span><br><span class="line">023c10fad4fd        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         5 seconds ago       Exited (0) 4 seconds ago                                k8s_iperf2.5a36e29e_test-gc-pod-exit_default_c5cbddbb-e9ee-11e5-974c-782bcb2a316a_6cc03f37</span><br><span class="line">756eb7bb4b53        10.11.150.76:5000/centos:7               &quot;/bin/bash&quot;         5 seconds ago       Exited (0) 4 seconds ago                                k8s_iperf1.57dfe29d_test-gc-pod-exit_default_c5cbddbb-e9ee-11e5-974c-782bcb2a316a_83312ec2</span><br><span class="line">d54bdc22773e        pub.domeos.org/kubernetes/pause:latest   &quot;/pause&quot;            6 seconds ago       Exited (2) 3 seconds ago                                k8s_POD.bdb2e1f5_test-gc-pod-exit_default_c5cbddbb-e9ee-11e5-974c-782bcb2a316a_ccb57220</span><br></pre></td></tr></table></figure>

<p>GC的容器回收时间点到达时，可以看到已退出容器只剩下了三个，pause容器也被回收了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /home/domeos]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                        COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">a28625d189df        10.11.150.76:5000/centos:7   &quot;/bin/bash&quot;         2 minutes ago       Exited (0) 2 minutes ago                       k8s_iperf3.5c8de29f_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_48c11200</span><br><span class="line">97aca44f0deb        10.11.150.76:5000/centos:7   &quot;/bin/bash&quot;         2 minutes ago       Exited (0) 2 minutes ago                       k8s_iperf2.5a36e29e_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_df34f48d</span><br><span class="line">4e57b6c839ae        10.11.150.76:5000/centos:7   &quot;/bin/bash&quot;         2 minutes ago       Exited (0) 2 minutes ago                       k8s_iperf1.57dfe29d_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_afd622b2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：Kubernetes容器垃圾回收的 <code>--maximum-dead-containers</code> 参数设置可正常工作；pause容器也作为可回收容器被管理着；Tips第11条第3）点。</p>
</blockquote>
<ol>
<li><code>--maximum-dead-containers</code> 对于非kubelet管理的容器是否计数</li>
</ol>
<p>在第5个实验的基础上，手工创建一个container，等待GC的容器回收时间点到达，一分钟过去了，两分钟过去了，docker ps -a 显示的依然是4个容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@tc-151-100 /home/domeos]# docker run -it 10.11.150.76:5000/openxxs/iperf:1.2 /bin/sh</span><br><span class="line">sh-4.2# exit</span><br><span class="line">exit</span><br><span class="line">[@tc-151-100 /home/domeos]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                 COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">939b932dc7db        10.11.150.76:5000/openxxs/iperf:1.2   &quot;/bin/sh&quot;           2 minutes ago       Exited (0) 2 minutes ago                        backstabbing_aryabhata</span><br><span class="line">a28625d189df        10.11.150.76:5000/centos:7            &quot;/bin/bash&quot;         12 minutes ago      Exited (0) 12 minutes ago                       k8s_iperf3.5c8de29f_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_48c11200</span><br><span class="line">97aca44f0deb        10.11.150.76:5000/centos:7            &quot;/bin/bash&quot;         12 minutes ago      Exited (0) 12 minutes ago                       k8s_iperf2.5a36e29e_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_df34f48d</span><br><span class="line">4e57b6c839ae        10.11.150.76:5000/centos:7            &quot;/bin/bash&quot;         12 minutes ago      Exited (0) 12 minutes ago                       k8s_iperf1.57dfe29d_test-gc-pod-exit_default_c7612b59-e9ee-11e5-974c-782bcb2a316a_afd622b2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：Kubernetes容器垃圾回收的策略不适用于非kubelet管理的容器。</p>
</blockquote>
]]></content>
      <categories>
        <category>kubernetes</category>
        <category>Kubelet</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>Kubelet</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s常见的问题处理</title>
    <url>/2022/12/28/k8s%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="Coredns容器或local-dns容器重启"><a href="#Coredns容器或local-dns容器重启" class="headerlink" title="Coredns容器或local-dns容器重启"></a>Coredns容器或local-dns容器重启</h1><p>集群中的coredns组件发生重启(重新创建)，一般是由于coredns组件压力较大导致oom，请检查业务是否异常，是否存在应用容器无法解析域名的异常。</p>
<p>如果是local-dns重启，说明local-dns的性能也不够了，需要优化</p>
<h1 id="Pod-was-OOM-killed"><a href="#Pod-was-OOM-killed" class="headerlink" title="Pod was OOM killed"></a>Pod was OOM killed</h1><p>云应用容器实例发生OOM，请检查云应用是否正常。一般地，如果云应用配置了健康检查，当进程OOM了，健康检查如果失败，集群会自动重启容器。</p>
<p>OOM问题排查步骤：</p>
<p>检查应用进程内存配置，如Java的jvm参数，对比应用监控-基础监控中的内存指标，判断是否是参数设置低导致进程内存不够用，适当进行参数优化</p>
<h1 id="Out-of-memory-Kill-process"><a href="#Out-of-memory-Kill-process" class="headerlink" title="Out of memory: Kill process"></a>Out of memory: Kill process</h1><h2 id="原因描述："><a href="#原因描述：" class="headerlink" title="原因描述："></a>原因描述：</h2><p>一般是操作系统把容器内进程Kill而导致的系统内核事件。比如一个java应用，当实际占用内存超过堆内存配置大小时，就会出现OOM错误。发生进程被Kill之后，容器依旧是存活状态，容器的健康检查还会继续进行。所以后面通常会伴随出现健康检查失败的错误。</p>
<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>要具体分析进程被Kill的原因，适当的调整进程内存的限制值。可以结合应用监控来参考进程内存的变化趋势。</p>
<h1 id="Memory-cgroup-out-of-memory-Kill-process"><a href="#Memory-cgroup-out-of-memory-Kill-process" class="headerlink" title="Memory cgroup out of memory: Kill process"></a>Memory cgroup out of memory: Kill process</h1><h2 id="原因描述：-1"><a href="#原因描述：-1" class="headerlink" title="原因描述："></a>原因描述：</h2><p>一般是由于容器的内存实际使用量超过了容器内存限制值而导致的事件。比如容器的内存限制值配置了1Gi，而容器的内存随着容器内进程内存使用量的增加超过了1Gi，就会导致容器被操作系统Cgroup Kill。发生容器被Kill之后，容器已经被停止，所以后续会出现应用实例被重启的情况。</p>
<h2 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h2><p>检查容器内进程是否有内存泄漏问题，同时适当调整容器内存的限制值大小。可以结合应用监控来看变化趋势。需要注意的是，容器内存限制值大小不应该过大，否则可能导致极端资源争抢情况下，容器被迫驱逐的问题。</p>
<h1 id="System-OOM-encountered"><a href="#System-OOM-encountered" class="headerlink" title="System OOM encountered"></a>System OOM encountered</h1><h2 id="原因描述：-2"><a href="#原因描述：-2" class="headerlink" title="原因描述："></a>原因描述：</h2><p>上述两种OOM（进程OOM，容器OOM）发生后，都可能会伴随一个系统OOM事件，该事件的原因是由上述OOM事件伴随导致。</p>
<h2 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要解决上面进程OOM或者容器CgroupOOM的问题。</p>
<h1 id="failed-to-garbage-collect-required-amount-of-images"><a href="#failed-to-garbage-collect-required-amount-of-images" class="headerlink" title="failed to garbage collect required amount of images"></a>failed to garbage collect required amount of images</h1><h2 id="原因描述：-3"><a href="#原因描述：-3" class="headerlink" title="原因描述："></a>原因描述：</h2><p>当容器集群中的节点（宿主机）磁盘使用率达到85%之后，会触发自动的容器镜像回收策略，以便于释放足够的宿主机磁盘。该事件发生于当触发镜像回收策略之后，磁盘空间仍然不足以达到健康阈值（默认为80%）。通常该错误是由于宿主机磁盘被占用太多导致。当磁盘空间占用率持续增长（超过90%），会导致该节点上的所有容器被驱逐，也就是当前节点由于磁盘压力不再对外提供服务，直到磁盘空间释放。</p>
<h2 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h2><p>检查节点的磁盘分配情况，通常有以下一些常见情况导致磁盘占用率过高：</p>
<p>有大量日志在磁盘上没有清理；请清理日志。<br>有进程在宿主机不停的写文件；请控制文件大小，将文件存储至OSS或者NAS。<br>下载的或者是其他的静态资源文件占用空间过大；静态资源请存储至OSS或CDN。</p>
<h1 id="Attempting-to-xxxx"><a href="#Attempting-to-xxxx" class="headerlink" title="Attempting to xxxx"></a>Attempting to xxxx</h1><p>节点资源不足(EvictionThresholdMet)，一般是节点资源将要达到阈值，可能会触发Pod驱逐。如 Attempting to reclaim ephemeral-storage</p>
<h2 id="原因描述：-4"><a href="#原因描述：-4" class="headerlink" title="原因描述："></a>原因描述：</h2><p>ephemeral storage是临时存储空间，当磁盘空间使用率达到阈值，会触发临时存储空间的回收任务。回收任务会尝试回收系统日志，以及没有正在使用的镜像缓存等数据。当磁盘空间占用率持续增长（超过90%），会导致该节点上的所有容器被驱逐，也就是当前节点由于磁盘压力不再对外提供服务，直到磁盘空间释放。</p>
<h2 id="解决方案：-4"><a href="#解决方案：-4" class="headerlink" title="解决方案："></a>解决方案：</h2><p>请注意磁盘空间的使用：</p>
<p>避免使用“空目录”类型的挂载方式；使用NAS或者其他类似方式替代。<br>尽量避免使用“宿主机目录”类型的挂载方式，以便于保证容器是无状态的，可以迁移的。<br>要注意避免在容器内大量写文件，而导致容器运行时可写数据层过大（imagefs）。</p>
<h1 id="NTP-service-is-not-running"><a href="#NTP-service-is-not-running" class="headerlink" title="NTP service is not running"></a>NTP service is not running</h1><h2 id="原因描述：-5"><a href="#原因描述：-5" class="headerlink" title="原因描述："></a>原因描述：</h2><p>NTP service是系统时间校准服务，由操作系统systemd管理的服务。可以通过 systemctl status chronyd 查看对应服务的状态。</p>
<h2 id="解决方案：-5"><a href="#解决方案：-5" class="headerlink" title="解决方案："></a>解决方案：</h2><p>使用命令systemctl start chronyd尝试重新启动。也可以通过命令 journalctl -u chronyd 查看服务的日志。</p>
<h1 id="节点PLEG异常"><a href="#节点PLEG异常" class="headerlink" title="节点PLEG异常"></a>节点PLEG异常</h1><h2 id="原因描述：-6"><a href="#原因描述：-6" class="headerlink" title="原因描述："></a>原因描述：</h2><p>PLEG是pod生命周期事件生成器，会记录Pod生命周期中的各种事件，如容器的启动、终止等。一般是由于节点上的daemon进程异常或者节点systemd版本bug导致。出现该问题会导致集群节点不可用</p>
<h2 id="解决方案：-6"><a href="#解决方案：-6" class="headerlink" title="解决方案："></a>解决方案：</h2><p>可以尝试重启kubelet；再尝试重启Docker进程。重启这两个进程过程中，不会对已运行容器造成影响</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//重启kubelet</span><br><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">//重启docker</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">//查看docker日志</span><br><span class="line">journalctl -xeu docker &gt; docker.log</span><br><span class="line">如果是由于systemd版本问题导致，重启节点可短暂修复，彻底解决的话需要升级节点的systemd</span><br><span class="line"></span><br><span class="line">systemd: (rpm -qa | grep systemd, 版本&lt;219-67.el7需要升级)</span><br><span class="line">升级systemd指令: </span><br><span class="line">yum update -y systemd &amp;&amp; systemctl daemon-reexec &amp;&amp; killall runc</span><br></pre></td></tr></table></figure>
<h1 id="节点PID不足"><a href="#节点PID不足" class="headerlink" title="节点PID不足"></a>节点PID不足</h1><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>通常是节点上的容器占用PID过多导致节点的PID不足</p>
<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>当节点的可用PID低于pid.available配置项时，则节点状态中NodePIDPressure为True，同时该节点上的容器被驱逐。关于节点驱逐，请参见节点压力驱逐。<br>若集群配置了集群节点异常报警，则节点PID不足时可收到相关报警。关于配置报警，请参见容器服务报警管理。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>执行如下命令，查看节点的最大PID数和节点当前的最大PID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl kernel.pid_max  #查看最大PID数。</span><br><span class="line">ps -eLf|awk &#x27;&#123;print $2&#125;&#x27; | sort -rn| head -n 1   #查看当前的最大PID。</span><br><span class="line">执行如下命令，查看占用PID最多的前5个进程。</span><br><span class="line">ps -elT | awk &#x27;&#123;print $4&#125;&#x27; | sort | uniq -c | sort -k1 -g | tail -5</span><br><span class="line">预期输出：</span><br><span class="line"></span><br><span class="line">#第一列为进程占用的PID数，第二列为当前进程号。</span><br><span class="line">73 9743</span><br><span class="line">75 9316</span><br><span class="line">76 2812</span><br><span class="line">77 5726</span><br><span class="line">93 5691</span><br></pre></td></tr></table></figure>
<p>根据进程号找到对应进程和所属的Pod，分析占用PID过多的原因并优化对应代码。<br>降低节点的负载。具体操作，请参见节点调度资源不足。<br>如需重启节点，可尝试重启异常节点。具体操作，请参见重启实例。</p>
<h1 id="节点FD不足"><a href="#节点FD不足" class="headerlink" title="节点FD不足"></a>节点FD不足</h1><h2 id="原因描述：-7"><a href="#原因描述：-7" class="headerlink" title="原因描述："></a>原因描述：</h2><p>节点文件句柄使用数量超过80%，具体原因与节点上进程使用情况相关打开文件未释放打开管道未释放建立网络连接未释放（pipe,eventpoll多出现在 NIO 网络编程未释放资源 —— selector.close()）创建进程调用命令未释放（Runtime.exe(…) 得到的 Process, InputStream, OutputStream 未关闭，这也会导致 pipe,eventpoll 未释放）</p>
<h2 id="解决方案：-7"><a href="#解决方案：-7" class="headerlink" title="解决方案："></a>解决方案：</h2><p>删除不需要的文件，调整应用代码，文件流等操作结束后记得关闭。或者尝试先排空再重启主机</p>
<h1 id="节点Docker-Hung"><a href="#节点Docker-Hung" class="headerlink" title="节点Docker Hung"></a>节点Docker Hung</h1><h2 id="原因描述：-8"><a href="#原因描述：-8" class="headerlink" title="原因描述："></a>原因描述：</h2><p>节点docker daemon异常，导致集群无法与之通信，伴随有docker ps、docker exec等命令hung住或异常失败</p>
<h2 id="解决方案：-8"><a href="#解决方案：-8" class="headerlink" title="解决方案："></a>解决方案：</h2><p>尝试重启docker服务，重启过程不会影响已存在容器的运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//重启节点上的docker daemon，对运行中容器没有影响</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">//查看docker日志</span><br><span class="line">journalctl -xeu docker &gt; docker.log</span><br></pre></td></tr></table></figure>
<p>如果docker服务重启后依然无法解决，可以尝试重启主机。主机重启过程会对容器有影响，谨慎操作。</p>
<h1 id="节点磁盘资源不足"><a href="#节点磁盘资源不足" class="headerlink" title="节点磁盘资源不足"></a>节点磁盘资源不足</h1><p>InvalidDiskCapacity</p>
<h2 id="原因描述：-9"><a href="#原因描述：-9" class="headerlink" title="原因描述："></a>原因描述：</h2><p>节点磁盘不足，无法分配空间给容器镜像</p>
<h2 id="解决方案：-9"><a href="#解决方案：-9" class="headerlink" title="解决方案："></a>解决方案：</h2><p>检查节点的磁盘分配情况，通常有以下一些常见情况导致磁盘占用率过高：</p>
<p>有大量日志在磁盘上没有清理；请清理日志。<br>有进程在宿主机不停的写文件；请控制文件大小，将文件存储至OSS或者NAS。<br>下载的或者是其他的静态资源文件占用空间过大；静态资源请存储至OSS或CDN。</p>
<h1 id="应用相关"><a href="#应用相关" class="headerlink" title="应用相关"></a>应用相关</h1><h1 id="Container-Restart"><a href="#Container-Restart" class="headerlink" title="Container Restart"></a>Container Restart</h1><h2 id="原因描述：-10"><a href="#原因描述：-10" class="headerlink" title="原因描述："></a>原因描述：</h2><p>该事件表示应用实例(重启)重启，一般是由于配置了健康检查且健康检查失败导致，会伴随有Readiness probe failed和Liveness probe failed等事件。健康检查失败的原因有很多，通常情况下，比如进程OOM被Kill、比如高负载情况下应用无法正常响应(例如RDS瓶颈导致应用线程全部hang住)，都可能会导致健康检查失败</p>
<h2 id="解决方案：-10"><a href="#解决方案：-10" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要结合临近的相关事件定位具体的Pod重启原因。如伴随有集群相关的Out of memory事件，参考此文档上面Out of memory事件的解决方案；其他情况下，结合应用监控或者云产品自身监控来定位问题</p>
<h1 id="The-node-had-condition-XXX"><a href="#The-node-had-condition-XXX" class="headerlink" title="The node had condition: [XXX]"></a>The node had condition: [XXX]</h1><h2 id="原因描述：-11"><a href="#原因描述：-11" class="headerlink" title="原因描述："></a>原因描述：</h2><p>该事件表示Pod由于节点上的异常情况被驱逐，比如<em>The node had condition: [DiskPressure]，</em>表示节点磁盘使用率比较高，通常会伴随有 failed to garbage collect required amount of images 和 Attempting to reclaim ephemeral-storage 等集群维度(节点)的异常事件</p>
<h2 id="解决方案：-11"><a href="#解决方案：-11" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要结合临近的相关事件定位具体的驱逐原因。对于已经被驱逐的Pod实例，可以通过kubectl get po 进行查看和手动清理</p>
<h1 id="K8S-Pod-Pending"><a href="#K8S-Pod-Pending" class="headerlink" title="K8S Pod Pending"></a>K8S Pod Pending</h1><h2 id="原因描述：-12"><a href="#原因描述：-12" class="headerlink" title="原因描述："></a>原因描述：</h2><p>该事件表示集群调度Pod被挂起，一般是由于节点资源不足以调度容器或者Volume挂载失败（比如持久化存储卷找不到）或者其他原因导致。</p>
<h2 id="解决方案：-12"><a href="#解决方案：-12" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要结合临近的相关事件定位具体的Pod挂起原因</p>
<h1 id="Readiness-probe-failed"><a href="#Readiness-probe-failed" class="headerlink" title="Readiness probe failed"></a>Readiness probe failed</h1><h2 id="原因描述：-13"><a href="#原因描述：-13" class="headerlink" title="原因描述："></a>原因描述：</h2><p>由于应用就绪探针失败而引发的异常事件。应用就绪探针失败会导致相应容器的流量被摘除，例如被动从SLB摘掉该容器的流量入口。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>需要结合应用就绪探针的配置，定位应用就绪探针失败的原因。</p>
<h1 id="Liveness-probe-failed"><a href="#Liveness-probe-failed" class="headerlink" title="Liveness probe failed"></a>Liveness probe failed</h1><h2 id="原因描述：-14"><a href="#原因描述：-14" class="headerlink" title="原因描述："></a>原因描述：</h2><p>由于应用存活探针失败而引发的异常事件。该事件可能会导致后续达到一定阈值之后，容器被动重启。具体要看应用就绪探针的配置。</p>
<h2 id="解决方案：-13"><a href="#解决方案：-13" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要结合应用存活探针的配置，定位探针检查失败的原因。</p>
<h1 id="Container-runtime-did-not-kill-the-pod-within-specified-grace-period"><a href="#Container-runtime-did-not-kill-the-pod-within-specified-grace-period" class="headerlink" title="Container runtime did not kill the pod within specified grace period."></a>Container runtime did not kill the pod within specified grace period.</h1><h2 id="原因描述：-15"><a href="#原因描述：-15" class="headerlink" title="原因描述："></a>原因描述：</h2><p>此事件表示容器没有在优雅下线的时间段内正常退出。比如如果配置了优雅下线脚本，脚本执行时长需要60s，而优雅下线时间（默认为30s）配置为30s。就会在容器下线期间触发这个事件。</p>
<h2 id="解决方案：-14"><a href="#解决方案：-14" class="headerlink" title="解决方案："></a>解决方案：</h2><p>调整优雅下线探针的配置，或者优雅下线时间的配置。</p>
<h1 id="Back-off-restarting-failed-container"><a href="#Back-off-restarting-failed-container" class="headerlink" title="Back-off restarting failed container"></a>Back-off restarting failed container</h1><h2 id="原因描述：-16"><a href="#原因描述：-16" class="headerlink" title="原因描述："></a>原因描述：</h2><p>此事件表示容器启动失败，而被再次拉起尝试启动。通常常见与应用发布过程中的容器启动失败。具体的原因常见为镜像拉取失败，或者容器启动失败（容器没有打到running状态）。</p>
<h2 id="解决方案：-15"><a href="#解决方案：-15" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要在发布页查看容器启动日志或者调度日志，进一步定位容器启动失败的原因。</p>
<h1 id="The-node-was-low-on-resource-xxxx"><a href="#The-node-was-low-on-resource-xxxx" class="headerlink" title="The node was low on resource: xxxx"></a>The node was low on resource: xxxx</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-07-21 10:24:43.000 [Event] Type: Warning, Reason: Evicted, Message: The node was low on resource: ephemeral-storage. </span><br></pre></td></tr></table></figure>
<h2 id="原因描述：-17"><a href="#原因描述：-17" class="headerlink" title="原因描述："></a>原因描述：</h2><p>该事件表示Pod由于节点上的异常情况(资源不足)被驱逐</p>
<h2 id="解决方案：-16"><a href="#解决方案：-16" class="headerlink" title="解决方案："></a>解决方案：</h2><p>需要看具体哪类资源不足，例如示例中的ephemeral-storage，表示集群节点临时存储空间不足，一般是由于磁盘使用量较大导致。请参考文档上方解决方案</p>
<p>检查节点的磁盘分配情况，通常有以下一些常见情况导致磁盘占用率过高：</p>
<p>有大量日志在磁盘上没有清理；请清理日志。<br>有进程在宿主机不停的写文件；请控制文件大小，将文件存储至OSS或者NAS。<br>下载的或者是其他的静态资源文件占用空间过大；静态资源请存储至OSS或CDN。<br>可以对系统盘进行扩容，扩大磁盘空间。</p>
<h1 id="集群DNS性能瓶颈"><a href="#集群DNS性能瓶颈" class="headerlink" title="集群DNS性能瓶颈"></a>集群DNS性能瓶颈</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>集群中的容器实例，DNS解析均依赖集群内的DNS组件，应用中业务请求的地址都需要经过集群DNS组件。例如，代码中访问RDS、REDIS、TOP api等。如果集群dns性能不足，会出现业务请求失败的问题。</p>
<p>集群DNS组件：</p>
<p>默认已安装的集群组件为coredns，副本数为2<br>可选的高性能组件为localdns</p>
<h2 id="是否有性能瓶颈"><a href="#是否有性能瓶颈" class="headerlink" title="是否有性能瓶颈"></a>是否有性能瓶颈</h2><p>应用有大量DNS请求的场景(比如连接rds，凡是涉及到域名地址解析的)<br>PHP等语言自身没有连接池特性的，或者应用自身没有DNS缓存的<br>偶尔出现域名地址无法解析错误的</p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>一、集群默认已安装的coredns组件，进行扩容。扩容比例为1&#x2F;5的节点数(如15台ecs，那么coredns数量为3)</p>
<p>二、为集群安装更高性能的localdns组件(该组件为daemonset，会在每个ECS节点起一个本地缓存)</p>
<p>一般来说，如果业务量小，扩容下coredns就足够了；如果业务量大(域名地址解析QPS高，比如访问RDS)，特别是php等不带连接池的开发语言，建议直接上localdns。如果是java等配置了连接池的应用，可以先扩容coredns观察，如果仍然有解析问题，再上localdns。</p>
<h1 id="localdns缓存原理"><a href="#localdns缓存原理" class="headerlink" title="localdns缓存原理"></a>localdns缓存原理</h1><p>NodeLocalDNS 是一个 DaemonSet，会在Kubernetes集群的每个节点上运行一个专门处理 DNS 查询请求的 Pod，该 Pod 会将集群内部域名查询请求发往 CoreDNS；将集群外部请求直接发往外部域名解析服务器。同时能够Cache所有请求。可以被看作是节点级别的高效DNS 缓存，能够大幅提高集群整体 DNS 查询的 QPS。NodeLocalDNS 会在集群的每个节点上创建一个专用的虚拟接口（接口绑定的 IP 需要通过 local_dns_ip 这个值来指定），节点上所有发往该 IP 的 DNS 查询请求都会被拦截到 NodeLocalDNS Pod 内进行处理；通过集群原有的 kube-dns 服务（该服务的 clusterIP 值需要通过kube_dns_ip来指定）来与CoreDNS进行通信。<br><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image.png" alt="image"></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet源码执行流程分析</title>
    <url>/2022/12/29/kubelet%E6%BA%90%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="k8s学习：kubelet源码执行流程分析"><a href="#k8s学习：kubelet源码执行流程分析" class="headerlink" title="k8s学习：kubelet源码执行流程分析"></a>k8s学习：kubelet源码执行流程分析</h1><p>容器技术应用范围越来越广，通过理解整个框架的执行流程，学习源码执行思路，对以后的编程很有帮助， kubernetes有很多组件，我们今天通过kubelet这个组件来进行深入的分析，来看看里面的执行流程，kubelet里面涉及的方法非常多且层层嵌套，通过我这一篇文章肯定是讲不全的，大家可以根据自己的情况不断深入来学习。我们这篇文章主要分析其执行流程，不深入底层的执行细节。抓主干。学习源码版本：1.19</p>
<h3 id="kubelet-主要功能"><a href="#kubelet-主要功能" class="headerlink" title="kubelet 主要功能"></a>kubelet 主要功能</h3><p>在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器，并负责健康检查和监控信息提供。</p>
<h4 id="pod-管理"><a href="#pod-管理" class="headerlink" title="pod 管理"></a>pod 管理</h4><p>每个pod都有其对应的yaml文件，来描述其运行过程中的一些参数和配置信息，kubelet 采用一组通过各种机制来保证运行在此物理机上的容器，符合 PodSpecs 中描述的 Pod 状态，正常健康运行。</p>
<p>官方提供了4中方式来获取容器信息：</p>
<ol>
<li>apiserver：通过 API Server 监听 etcd 目录获取数据；</li>
<li>File：启动参数 –config 指定的配置目录下的文件；</li>
<li>通过 url 从网络上某个地址来获取信息</li>
</ol>
<p>拿apiserver来说，如果Kubelet 监听到etcd中有新的绑定到本节点的 Pod，则按照 Pod 清单的要求创建该 Pod；如果发现本地的 Pod 被修改，则 Kubelet 会做出相应的修改。</p>
<h4 id="容器健康检查"><a href="#容器健康检查" class="headerlink" title="容器健康检查"></a>容器健康检查</h4><p>容器健康检查，主要是通过LivenessProbe 与ReadinessProbe来判断容器是否健康。</p>
<ol>
<li>LivenessProbe ：用于判断容器是否健康，告诉 Kubelet 一个容器什么时候处于不健康的状态。如果 LivenessProbe 探针探测到容器不健康，则 Kubelet 将删除该容器，并根据容器的重启策略做相应的处理。如果一个容器不包含 LivenessProbe 探针，那么 Kubelet 认为该容器的 LivenessProbe 探针返回的值永远是 “Success”；</li>
<li>ReadinessProbe：用于判断容器是否启动完成且准备接收请求。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 IP 地址的 Endpoint 条目。</li>
</ol>
<h4 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h4><p>Kubelet 通过 cAdvisor 获取其所在节点及容器的数据。cAdvisor 是一个开源的分析容器资源使用率和性能特性的代理工具，集成到 Kubelet中，当Kubelet启动时会同时启动cAdvisor，且一个cAdvisor只监控一个Node节点的信息。cAdvisor 自动查找所有在其所在节点上的容器，自动采集 CPU、内存、文件系统和网络使用的统计信息。cAdvisor 通过它所在节点机的 Root 容器，采集并分析该节点机的全面使用情况。</p>
<h3 id="kubelet-工作原理"><a href="#kubelet-工作原理" class="headerlink" title="kubelet 工作原理"></a>kubelet 工作原理</h3><p>这里借用网上的一张图来说明情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202210111512447.png" alt="20210131-9142139592.png"></p>
<p>由图我们可以看到kubelet 的工作核心，就是一个控制循环，即：SyncLoop。驱动整个控制循环的事件有：pod更新事件、pod生命周期变化、kubelet本身设置的执行周期、定时清理事件等。</p>
<p>在SyncLoop循环上还有很多xxManager，例如probeManager 会定时去监控 pod 中容器的健康状况，当前支持两种类型的探针：livenessProbe 和readinessProbe；statusManager 负责维护状态信息，并把 pod 状态更新到 apiserver；containerRefManager 容器引用的管理，相对简单的Manager，用来报告容器的创建，失败等事件等等。</p>
<p>kubelet 调用下层容器运行时的执行过程，并不会直接调用 Docker 的 API，而是通过一组叫作 CRI（Container Runtime Interface，容器运行时接口）的 gRPC 接口来间接执行的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202210111521889.png" alt="20210131-3878407432.png"></p>
<p>CRI是k8s对容器的操作抽离出的一系列的接口，kubelet 就只需要跟这个接口打交道，而不需要关注底层的容器时docker还是rkt，底层的容器只需要自己提供一个该接口的实现，然后对 kubelet 暴露出 gRPC 服务即可。有关CRI的可以内容可以看看这篇：Introducing Container Runtime Interface。</p>
<p>一般来说CRI接口可以分为两组：</p>
<ol>
<li>一组是ImageService，主要是容器镜像相关的操作，比如拉取镜像、删除镜像等。</li>
<li>一组是RuntimeService，主要是跟容器相关的操作，比如创建、启动、删除Container、Exec等。</li>
</ol>
<h3 id="kubelet执行源码分析"><a href="#kubelet执行源码分析" class="headerlink" title="kubelet执行源码分析"></a>kubelet执行源码分析</h3><p>Run</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202210111512279.png" alt="kubelet.png"></p>
<p>文件地址：kubernetes\pkg\kubelet\kubelet.go</p>
<pre><code>func (kl *Kubelet) Run(updates &lt;-chan kubetypes.PodUpdate) &#123;
    //注册 logServer
    if kl.logServer == nil &#123;
        kl.logServer = http.StripPrefix(&quot;/logs/&quot;, http.FileServer(http.Dir(&quot;/var/log/&quot;)))
    &#125;
    if kl.kubeClient == nil &#123;
        klog.Warning(&quot;No api server defined - no node status update will be sent.&quot;)
    &#125;

    //Cloud Provider 扩展相关：https://kubernetes.feisky.xyz/extension/cloud-provider
    if kl.cloudResourceSyncManager != nil &#123;
        go kl.cloudResourceSyncManager.Run(wait.NeverStop)
    &#125;
    //调用 kl.initializeModules 首先启动不依赖 container runtime 的一些模块
    if err := kl.initializeModules(); err != nil &#123;
        kl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())
        klog.Fatal(err)
    &#125;

    //启动 volume manager
    go kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)

    if kl.kubeClient != nil &#123; 
        //执行 kl.syncNodeStatus 定时同步 Node 状态
        go wait.Until(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, wait.NeverStop)
        //调用 kl.fastStatusUpdateOnce 更新容器运行时启动时间以及执行首次状态同步
        go kl.fastStatusUpdateOnce()

        // start syncing lease
        //NodeLease 机制
        go kl.nodeLeaseController.Run(wait.NeverStop)
    &#125;
    //执行 kl.updateRuntimeUp 定时更新 Runtime 状态
    go wait.Until(kl.updateRuntimeUp, 5*time.Second, wait.NeverStop)

    // Set up iptables util rules
    //执行 kl.syncNetworkUtil 定时同步 iptables 规则
    if kl.makeIPTablesUtilChains &#123;
        kl.initNetworkUtil()
    &#125;

    //获取 pk.podKillingCh异常pod， 并定时清理异常 pod
    go wait.Until(kl.podKiller.PerformPodKillingWork, 1*time.Second, wait.NeverStop)

    // Start component sync loops.
    //启动 statusManager、probeManager、runtimeClassManager
    kl.statusManager.Start()
    kl.probeManager.Start()

    // Start syncing RuntimeClasses if enabled.
    if kl.runtimeClassManager != nil &#123;
        kl.runtimeClassManager.Start(wait.NeverStop)
    &#125;

    // Start the pod lifecycle event generator.
    //启动 pleg 该模块主要用于周期性地向 container runtime 刷新当前所有容器的状态
    //https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md
    kl.pleg.Start()
    kl.syncLoop(updates, kl)&#125;
</code></pre>
<p>这个方法会做以下事情：</p>
<ol>
<li>注册logServer；</li>
<li>如果设置了Cloud Provider，那么会启动云资源管理器，具体的可以查看文章：cloud-provider；</li>
<li>调用kl.initializeModules启动不依赖 container runtime 的一些模块，这个方法我们下面再分析；</li>
<li>启动 volume manager；</li>
<li>执行 kl.syncNodeStatus 定时同步 Node 状态；</li>
<li>调用kl.fastStatusUpdateOnce启动一个循环更新pod CIDR、runtime状态以及node状态；</li>
<li>调用kl.nodeLeaseController.Run启动NodeLease机制，NodeLease机制是一种上报心跳的方式，可以通过更加轻量化节约资源的方式，并提升性能上报node的心跳信息，具体看： Lease object；</li>
<li>执行 kl.updateRuntimeUp 定时更新 Runtime 状态；</li>
<li>执行 kl.syncNetworkUtil 定时同步 iptables 规则；</li>
<li>获取 pk.podKillingCh异常pod， 并定时清理异常 pod；</li>
<li>然后启动 statusManager、probeManager、runtimeClassManager；</li>
<li>启动 pleg模块，该模块主要用于周期性地向 container runtime 上报当前所有容器的状态，具体可以看：Pod Lifecycle Event Generator (PLEG)；</li>
<li>调用kl.syncLoop启动kublet事件循环；</li>
</ol>
<h3 id="initializeModules"><a href="#initializeModules" class="headerlink" title="initializeModules"></a>initializeModules</h3><p>下面我们看看initializeModules方法做了些什么。</p>
<pre><code>func (kl *Kubelet) initializeModules() error &#123;
    ...
    //创建文件目录
    if err := kl.setupDataDirs(); err != nil &#123;
        return err    &#125;

    //创建 ContainerLogsDir
    if _, err := os.Stat(ContainerLogsDir); err != nil &#123;
        if err := kl.os.MkdirAll(ContainerLogsDir, 0755); err != nil &#123;
            return fmt.Errorf(&quot;failed to create directory %q: %v&quot;, ContainerLogsDir, err)
        &#125;
    &#125;

    //启动 imageManager
    kl.imageManager.Start()

    //启动 certificate manager ，证书相关
    if kl.serverCertificateManager != nil &#123;
        kl.serverCertificateManager.Start()
    &#125;

    //启动 oomWatcher.
    if err := kl.oomWatcher.Start(kl.nodeRef); err != nil &#123;
        return fmt.Errorf(&quot;failed to start OOM watcher %v&quot;, err)
    &#125;

    //启动 resource analyzer,刷新volume stats到缓存中
    kl.resourceAnalyzer.Start()

    return nil&#125;
</code></pre>
<p>initializeModules方法主要做了以下几件事：</p>
<ol>
<li>创建创建文件目录、Container的log目录；</li>
<li>启动 imageManager，这个管理器实际上是realImageGCManager，我们待会看；</li>
<li>启动 certificate manager ，证书相关；</li>
<li>启动 oomWatcher监视器；</li>
<li>启动 resource analyzer,定时刷新volume stats到缓存中；</li>
</ol>
<h3 id="realImageGCManager-Start"><a href="#realImageGCManager-Start" class="headerlink" title="realImageGCManager#Start"></a>realImageGCManager#Start</h3><p>文件路径：pkg&#x2F;kubelet&#x2F;images&#x2F;image_gc_manager.go</p>
<pre><code>func (im *realImageGCManager) Start() &#123;
    go wait.Until(func() &#123; 
        var ts time.Time        if im.initialized &#123;
            ts = time.Now()
        &#125;
        //找出所有的image，并删除不再使用的image
        _, err := im.detectImages(ts)
        if err != nil &#123;
            klog.Warningf(&quot;[imageGCManager] Failed to monitor images: %v&quot;, err)
        &#125; else &#123;
            im.initialized = true
        &#125;
    &#125;, 5*time.Minute, wait.NeverStop)

    //更新image的缓存
    go wait.Until(func() &#123;
        //调用容器接口，获取最新的image
        images, err := im.runtime.ListImages()
        if err != nil &#123;
            klog.Warningf(&quot;[imageGCManager] Failed to update image list: %v&quot;, err)
        &#125; else &#123;
            im.imageCache.set(images)
        &#125;
    &#125;, 30*time.Second, wait.NeverStop)&#125;
</code></pre>
<p>realImageGCManager的start方法会启动两个协程，然后分别定时调用detectImages方法与imageCache的set方法。detectImages方法里面主要就是调用ImageService和RuntimeService的方法找出所有正在使用的image，然后删除不再使用的image。</p>
<p>这里ListImages和detectImages里面用到的GetPods方法都是调用了CRI的方法，</p>
<h3 id="fastStatusUpdateOnce"><a href="#fastStatusUpdateOnce" class="headerlink" title="fastStatusUpdateOnce"></a>fastStatusUpdateOnce</h3><pre><code>func (kl *Kubelet) fastStatusUpdateOnce() &#123;
    for &#123;
        time.Sleep(100 * time.Millisecond)
        node, err := kl.GetNode()
        if err != nil &#123;
            klog.Errorf(err.Error())
            continue
        &#125;
        if len(node.Spec.PodCIDRs) != 0 &#123;
            podCIDRs := strings.Join(node.Spec.PodCIDRs, &quot;,&quot;)
            if _, err := kl.updatePodCIDR(podCIDRs); err != nil &#123;
                klog.Errorf(&quot;Pod CIDR update to %v failed %v&quot;, podCIDRs, err)
                continue
            &#125;
            //更新 Runtime 状态
            kl.updateRuntimeUp()
            //更新 节点 状态
            kl.syncNodeStatus()
            return
        &#125;
    &#125;&#125;
</code></pre>
<p>FastStatusUpdateOnce 函数启动一个循环，尝试立即更新POD CIDR。更新pod CIDR后，它会触发运行时更新和节点状态更新。函数在一次成功的节点状态更新后直接返回。该功能仅在 kubelet 启动期间执行，通过尽快更新 pod cidr、运行时状态和节点状态来提高准备就绪节点的延迟。</p>
<h3 id="updateRuntimeUp"><a href="#updateRuntimeUp" class="headerlink" title="updateRuntimeUp"></a>updateRuntimeUp</h3><p>&#x2F;&#x2F;首次执行的时候会初始化runtime依赖模块，然后更新runtimeState</p>
<pre><code>//首次执行的时候会初始化runtime依赖模块，然后更新runtimeStatefunc (kl *Kubelet) updateRuntimeUp() &#123;
    kl.updateRuntimeMux.Lock()
    defer kl.updateRuntimeMux.Unlock()
    //获取 containerRuntime Status
    s, err := kl.containerRuntime.Status()
    if err != nil &#123;
        klog.Errorf(&quot;Container runtime sanity check failed: %v&quot;, err)
        return
    &#125;
    if s == nil &#123;
        klog.Errorf(&quot;Container runtime status is nil&quot;)
        return
    &#125; 
    klog.V(4).Infof(&quot;Container runtime status: %v&quot;, s)
    //检查 network 和 runtime 是否处于 ready 状态
    networkReady := s.GetRuntimeCondition(kubecontainer.NetworkReady)
    if networkReady == nil || !networkReady.Status &#123;
        klog.Errorf(&quot;Container runtime network not ready: %v&quot;, networkReady)
        kl.runtimeState.setNetworkState(fmt.Errorf(&quot;runtime network not ready: %v&quot;, networkReady))
    &#125; else &#123;
        // Set nil if the container runtime network is ready.
        kl.runtimeState.setNetworkState(nil)
    &#125;
    // information in RuntimeReady condition will be propagated to NodeReady condition.
    //获取运行时状态
    runtimeReady := s.GetRuntimeCondition(kubecontainer.RuntimeReady)
    // If RuntimeReady is not set or is false, report an error.
    if runtimeReady == nil || !runtimeReady.Status &#123;
        err := fmt.Errorf(&quot;Container runtime not ready: %v&quot;, runtimeReady)
        klog.Error(err)
        kl.runtimeState.setRuntimeState(err)
        return
    &#125;
    kl.runtimeState.setRuntimeState(nil)
    //调用 kl.initializeRuntimeDependentModules 启动依赖模块
    kl.oneTimeInitializer.Do(kl.initializeRuntimeDependentModules)
    kl.runtimeState.setRuntimeSync(kl.clock.Now())&#125;
</code></pre>
<p>updateRuntimeUp会获取container运行状态信息，然后根据返回RuntimeStatus检查网络、runtime是不是已经处于ready状态；接着调用kl.initializeRuntimeDependentModules初始化依赖模块，这里会启动cadvisor、containerManager、evictionManager、containerLogManager、pluginManager；最后设置Runtime同步时间。</p>
<h3 id="最后看看syncLoop方法"><a href="#最后看看syncLoop方法" class="headerlink" title="最后看看syncLoop方法"></a>最后看看syncLoop方法</h3><pre><code>func (kl *Kubelet) syncLoop(updates &lt;-chan kubetypes.PodUpdate, handler SyncHandler) &#123;
    ...
    syncTicker := time.NewTicker(time.Second)
    defer syncTicker.Stop()
    housekeepingTicker := time.NewTicker(housekeepingPeriod)
    defer housekeepingTicker.Stop()
    plegCh := kl.pleg.Watch()
    for &#123;
        ...
        kl.syncLoopMonitor.Store(kl.clock.Now())
        if !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;
            break
        &#125;
        kl.syncLoopMonitor.Store(kl.clock.Now())
    &#125;&#125;
</code></pre>
<p>syncLoop方法在一个循环中不断的调用syncLoopIteration方法执行主要逻辑。</p>
<h3 id="syncLoopIteration方法比较长，拆开来看"><a href="#syncLoopIteration方法比较长，拆开来看" class="headerlink" title="syncLoopIteration方法比较长，拆开来看"></a>syncLoopIteration方法比较长，拆开来看</h3><pre><code>func (kl *Kubelet) syncLoopIteration(configCh &lt;-chan kubetypes.PodUpdate, handler SyncHandler,
    //方法会监听多个 channel，当发现任何一个 channel 有数据就交给 handler 去处理，在 handler 中通过调用 dispatchWork 分发任务
    syncCh &lt;-chan time.Time, housekeepingCh &lt;-chan time.Time, plegCh &lt;-chan *pleg.PodLifecycleEvent) bool &#123;
    select &#123;
        //该模块将同时 watch 3 个不同来源的 pod 信息的变化（file，http，apiserver），
        //一旦某个来源的 pod 信息发生了更新（创建/更新/删除），这个 channel 中就会出现被更新的 pod 信息和更新的具体操作；
    case u, open := &lt;-configCh: 
        if !open &#123;
            klog.Errorf(&quot;Update channel is closed. Exiting the sync loop.&quot;)
            return false
        &#125;

        switch u.Op &#123;
        case kubetypes.ADD:
            klog.V(2).Infof(&quot;SyncLoop (ADD, %q): %q&quot;, u.Source, format.Pods(u.Pods)) 
            handler.HandlePodAdditions(u.Pods)
        case kubetypes.UPDATE:
            klog.V(2).Infof(&quot;SyncLoop (UPDATE, %q): %q&quot;, u.Source, format.PodsWithDeletionTimestamps(u.Pods))
            handler.HandlePodUpdates(u.Pods)
        case kubetypes.REMOVE:
            klog.V(2).Infof(&quot;SyncLoop (REMOVE, %q): %q&quot;, u.Source, format.Pods(u.Pods))
            handler.HandlePodRemoves(u.Pods)
        case kubetypes.RECONCILE:
            klog.V(4).Infof(&quot;SyncLoop (RECONCILE, %q): %q&quot;, u.Source, format.Pods(u.Pods))
            handler.HandlePodReconcile(u.Pods)
        case kubetypes.DELETE:
            klog.V(2).Infof(&quot;SyncLoop (DELETE, %q): %q&quot;, u.Source, format.Pods(u.Pods)) 
            handler.HandlePodUpdates(u.Pods)
        case kubetypes.SET: 
            klog.Errorf(&quot;Kubelet does not support snapshot update&quot;)
        default:
            klog.Errorf(&quot;Invalid event type received: %d.&quot;, u.Op)
        &#125;

        kl.sourcesReady.AddSource(u.Source)

     ...&#125;
</code></pre>
<p>configCh读取配置事件的管道，该模块将同时 watch 3 个不同来源的 pod 信息的变化（file，http，apiserver），一旦某个来源的 pod 信息发生了更新（创建&#x2F;更新&#x2F;删除），这个 channel 中就会出现被更新的 pod 信息和更新的具体操作。这里对于pod的操作我们下一篇再讲。</p>
<p>plegCh</p>
<pre><code>func (kl *Kubelet) syncLoopIteration(configCh &lt;-chan kubetypes.PodUpdate, handler SyncHandler,
    //方法会监听多个 channel，当发现任何一个 channel 有数据就交给 handler 去处理，在 handler 中通过调用 dispatchWork 分发任务
    syncCh &lt;-chan time.Time, housekeepingCh &lt;-chan time.Time, plegCh &lt;-chan *pleg.PodLifecycleEvent) bool &#123;
    ...
    case e := &lt;-plegCh:
        if e.Type == pleg.ContainerStarted &#123;
            kl.lastContainerStartedTime.Add(e.ID, time.Now())
        &#125;
        if isSyncPodWorthy(e) &#123; 
            if pod, ok := kl.podManager.GetPodByUID(e.ID); ok &#123;
                klog.V(2).Infof(&quot;SyncLoop (PLEG): %q, event: %#v&quot;, format.Pod(pod), e)
                handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)
            &#125; else &#123; 
                klog.V(4).Infof(&quot;SyncLoop (PLEG): ignore irrelevant event: %#v&quot;, e)
            &#125;
        &#125; 
        if e.Type == pleg.ContainerDied &#123;
            if containerID, ok := e.Data.(string); ok &#123;
                kl.cleanUpContainersInPod(e.ID, containerID)
            &#125;
        &#125;
    ...&#125;
</code></pre>
<p>PLEG.Start的时候会每秒钟启动调用一次relist，根据最新的PodStatus生成PodLiftCycleEvent，然后存入到PLE Channel中。</p>
<p>syncLoop会调用pleg.Watch方法获取PLE Channel管道，然后传给syncLoopIteration方法，在syncLoopIteration方法中也就是plegCh这个管道，syncLoopIteration会消费plegCh中的数据，在 handler 中通过调用 dispatchWork 分发任务。</p>
<p>syncCh</p>
<pre><code>func (kl *Kubelet) syncLoopIteration(configCh &lt;-chan kubetypes.PodUpdate, handler SyncHandler,
    syncCh &lt;-chan time.Time, housekeepingCh &lt;-chan time.Time, plegCh &lt;-chan *pleg.PodLifecycleEvent) bool &#123;
    ...
    //  每秒钟会执行到一次
    case &lt;-syncCh:
        // Sync pods waiting for sync
        podsToSync := kl.getPodsToSync()
        if len(podsToSync) == 0 &#123;
            break
        &#125;
        klog.V(4).Infof(&quot;SyncLoop (SYNC): %d pods; %s&quot;, len(podsToSync), format.Pods(podsToSync))
        //同步最新保存的 pod 状态
        handler.HandlePodSyncs(podsToSync)
    ...&#125;
</code></pre>
<p>syncCh是由syncLoop方法里面创建的一个定时任务，每秒钟会向syncCh添加一个数据，然后就会执行到这里。这个方法会同步所有等待同步的pod。</p>
<p>livenessManager.Updates</p>
<pre><code>func (kl *Kubelet) syncLoopIteration(configCh &lt;-chan kubetypes.PodUpdate, handler SyncHandler,
    syncCh &lt;-chan time.Time, housekeepingCh &lt;-chan time.Time, plegCh &lt;-chan *pleg.PodLifecycleEvent) bool &#123;
    ...
    case update := &lt;-kl.livenessManager.Updates():
        //如果探针检测失败，需要更新pod的状态
        if update.Result == proberesults.Failure &#123; 
            pod, ok := kl.podManager.GetPodByUID(update.PodUID)
            if !ok &#123; 
                klog.V(4).Infof(&quot;SyncLoop (container unhealthy): ignore irrelevant update: %#v&quot;, update)
                break
            &#125;
            klog.V(1).Infof(&quot;SyncLoop (container unhealthy): %q&quot;, format.Pod(pod))
            handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)
        &#125;
    ...&#125;
</code></pre>
<p>对失败的pod或者liveness检查失败的pod进行sync操作。</p>
<p>housekeepingCh</p>
<pre><code>func (kl *Kubelet) syncLoopIteration(configCh &lt;-chan kubetypes.PodUpdate, handler SyncHandler,
    syncCh &lt;-chan time.Time, housekeepingCh &lt;-chan time.Time, plegCh &lt;-chan *pleg.PodLifecycleEvent) bool &#123;
    ...
    //  每两秒钟执行一次
    case &lt;-housekeepingCh:
        if !kl.sourcesReady.AllReady() &#123; 
            klog.V(4).Infof(&quot;SyncLoop (housekeeping, skipped): sources aren&#39;t ready yet.&quot;)
        &#125; else &#123;
            klog.V(4).Infof(&quot;SyncLoop (housekeeping)&quot;)
            //执行一些清理工作，包括终止pod workers、删除不想要的pod，移除volumes、pod目录
            if err := handler.HandlePodCleanups(); err != nil &#123;
                klog.Errorf(&quot;Failed cleaning pods: %v&quot;, err)
            &#125;
        &#125;
    ...&#125;
</code></pre>
<p>housekeepingCh这个管道也是由syncLoop创建，每两秒钟会触发清理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>kubelet.Run部分主要执行kubelet包含的各种manager的运行，大部分会以一部线程的方式定时运行。了解了CRI是怎么一回事，通过CRI接口可以做什么。</p>
<p>接下来看了syncLoop主函数，这个函数主要对pod的生命周期进行管理，包括对pod进行add 、update、remove、delete等操作，这些具体的代码执行过程大家有兴趣的可以自己了解。</p>
]]></content>
      <categories>
        <category>kubernetes</category>
        <category>Kubelet</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>Kubelet</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Dockerfile 定制镜像</title>
    <url>/2022/12/29/%E4%BD%BF%E7%94%A8%20Dockerfile%20%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="一、使用-Dockerfile-定制镜像"><a href="#一、使用-Dockerfile-定制镜像" class="headerlink" title="一、使用 Dockerfile 定制镜像"></a>一、使用 Dockerfile 定制镜像</h2><h3 id="1-1、Dockerfile-定制镜像"><a href="#1-1、Dockerfile-定制镜像" class="headerlink" title="1.1、Dockerfile 定制镜像"></a>1.1、Dockerfile 定制镜像</h3><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>以 nginx 镜像为例，这次我们使用 Dockerfile 来定制。</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mynginx</span><br><span class="line"><span class="built_in">cd</span> mynginx</span><br><span class="line"><span class="built_in">touch</span> Dockerfile</span><br></pre></td></tr></table></figure>

<p>其内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p>
<h3 id="1-2、FROM-指定基础镜像"><a href="#1-2、FROM-指定基础镜像" class="headerlink" title="1.2、FROM 指定基础镜像"></a>1.2、FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM是必备的指令，并且必须是第一条指令。</p>
<p>在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>httpd</code>、<code>php</code>、<code>tomcat</code> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如<code>node</code>、<code>openjdk</code>、<code>python</code>、<code>ruby</code>、<code>golang</code>等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如<code>ubuntu</code>、<code>debian</code>、<code>centos</code>、<code>fedora</code>、<code>alpine</code> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如<code>swarm</code>、coreos&#x2F;etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 Go 语言开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h3 id="1-3、RUN-执行命令"><a href="#1-3、RUN-执行命令" class="headerlink" title="1.3、RUN 执行命令"></a>1.3、RUN 执行命令</h3><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。<br>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span></span><br><span class="line">RUN <span class="built_in">mkdir</span> -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>

<p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。这是很多初学 Docker 的人常犯的一个错误。</p>
<p><code>Union FS</code> 是有最大层数限制的，比如 AUFS，曾经是最大不能超过 42 层，现在是不能超过 127 层。</p>
<p>上面的 Dockerfile 正确的写法应该是这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN buildDeps=<span class="string">&#x27;gcc libc6-dev make&#x27;</span> \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span> \</span><br><span class="line">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure>

<p>首先，之前所有的命令只有一个目的，就是编译、安装 Redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 <code>Shell</code> 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
<h3 id="1-4、构建镜像"><a href="#1-4、构建镜像" class="headerlink" title="1.4、构建镜像"></a>1.4、构建镜像</h3><p>再回到之前定制的 Nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p>
<p>在 Dockerfile 文件所在目录执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9cdc27646c7b</span><br><span class="line"> ---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure>

<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p>
<p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>

<p>在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2一样。</p>
<h3 id="1-5、镜像构建上下文（Context）"><a href="#1-5、镜像构建上下文（Context）" class="headerlink" title="1.5、镜像构建上下文（Context）"></a>1.5、镜像构建上下文（Context）</h3><p>如果注意，会看到 docker build 命令最后有一个 .，. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？</p>
<p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 Dockerfile 中这么写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure>

<p>这并不是要复制执行 docker build 命令所在的目录下的 <code>package.json</code>，也不是复制 Dockerfile 所在目录下的 <code>package.json</code>，而是复制 上下文（context） 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 .，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 Dockerfile。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
<h3 id="1-6、其他-docker-build-的用法"><a href="#1-6、其他-docker-build-的用法" class="headerlink" title="1.6、其他 docker build 的用法"></a>1.6、其他 docker build 的用法</h3><h4 id="1-6-1、直接用-Git-repo-进行构建"><a href="#1-6-1、直接用-Git-repo-进行构建" class="headerlink" title="1.6.1、直接用 Git repo 进行构建"></a>1.6.1、直接用 Git repo 进行构建</h4><p>docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:8.14</span></span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git\<span class="comment">#:8.14</span></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0</span><br><span class="line">8.14.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 &#x2F;8.14&#x2F;，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<h4 id="1-6-2、用给定的-tar-压缩包构建"><a href="#1-6-2、用给定的-tar-压缩包构建" class="headerlink" title="1.6.2、用给定的 tar 压缩包构建"></a>1.6.2、用给定的 tar 压缩包构建</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>

<p>如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<h4 id="1-6-3、从标准输入中读取-Dockerfile-进行构建"><a href="#1-6-3、从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="1.6.3、从标准输入中读取 Dockerfile 进行构建"></a>1.6.3、从标准输入中读取 Dockerfile 进行构建</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> Dockerfile | docker build -</span><br></pre></td></tr></table></figure>

<p>如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p>
<h4 id="1-6-4、从标准输入中读取上下文压缩包进行构建"><a href="#1-6-4、从标准输入中读取上下文压缩包进行构建" class="headerlink" title="1.6.4、从标准输入中读取上下文压缩包进行构建"></a>1.6.4、从标准输入中读取上下文压缩包进行构建</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>

<p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
<h2 id="二、Dockerfile-指令"><a href="#二、Dockerfile-指令" class="headerlink" title="二、Dockerfile 指令"></a>二、Dockerfile 指令</h2><p>我们已经介绍了 <code>FROM</code>，<code>RUN</code>，还提及了 <code>COPY</code>, <code>ADD</code>，其实 Dockerfile 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。</p>
<h3 id="2-1、COPY"><a href="#2-1、COPY" class="headerlink" title="2.1、COPY"></a>2.1、COPY</h3><p>格式：</p>
<p><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code><br><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code><br>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p><code>COPY</code> 指令将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure>

<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <code>filepath.Match</code> 规则，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>

<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<h3 id="2-2、ADD"><a href="#2-2、ADD" class="headerlink" title="2.2、ADD"></a>2.2、ADD</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code>以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p>
<h3 id="2-3、CMD"><a href="#2-3、CMD" class="headerlink" title="2.3、CMD"></a>2.3、CMD</h3><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<p><code>shell 格式：CMD &lt;命令&gt;</code><br><code>exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code><br>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code>指令后，用 CMD 指定具体的参数。<br>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 &#x2F;bin&#x2F;bash，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。</p>
<p>如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure>

<p>在实际执行中，会将其变更为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure>

<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart&#x2F;systemd 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure>

<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 sh。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，sh 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2-4、ENTRYPOINT"><a href="#2-4、ENTRYPOINT" class="headerlink" title="2.4、ENTRYPOINT"></a>2.4、ENTRYPOINT</h3><p><code>ENTRYPOINT</code> 的格式和 RUN 指令格式一样，分为 exec 格式和 shell格式。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 –entrypoint 来指定。</p>
<p>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">&quot;&lt;CMD&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 &lt;ENTRYPOINT&gt; “&lt;CMD&gt;” 有什么好处么？让我们来看几个场景。</p>
<h4 id="2-4-1、场景一：让镜像变成像命令一样使用"><a href="#2-4-1、场景一：让镜像变成像命令一样使用" class="headerlink" title="2.4.1、场景一：让镜像变成像命令一样使用"></a>2.4.1、场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：160.155.224.xx 来自：XX市 联通</span><br></pre></td></tr></table></figure>

<p>这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 <code>HTTP</code> 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 docker run myip 么？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value <span class="string">&quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in <span class="variable">$PATH</span>\&quot;\n&quot;</span>.</span><br></pre></td></tr></table></figure>

<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 command，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 -i 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run myip curl -s http://ip.cn -i</span><br></pre></td></tr></table></figure>

<p>这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>这次我们再来尝试直接使用 docker run myip -i：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：160.155.224.xx 来自：XX市 联通</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">当前 IP：160.155.224.xx 来自：XX市 联通</span><br></pre></td></tr></table></figure>

<p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 ENTRYPOINT，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
<h4 id="2-4-2、场景二：应用运行前的准备工作"><a href="#2-4-2、场景二：应用运行前的准备工作" class="headerlink" title="2.4.2、场景二：应用运行前的准备工作"></a>2.4.2、场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 &lt;CMD&gt;）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [ <span class="string">&quot;redis-server&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>可以看到其中为了 Redis 服务创建了 Redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">chown</span> -R redis .</span><br><span class="line"> <span class="built_in">exec</span> su-exec redis <span class="string">&quot;<span class="variable">$0</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it redis <span class="built_in">id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root)</span><br></pre></td></tr></table></figure>

<h3 id="2-5、ENV"><a href="#2-5、ENV" class="headerlink" title="2.5、ENV"></a>2.5、ENV</h3><p>格式有两种：</p>
<p><code>ENV &lt;key&gt; &lt;value&gt;</code><br><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code><br>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=<span class="string">&quot;Happy Feet&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span><br><span class="line">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span><br><span class="line">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="line">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="built_in">sha256sum</span> -c - \</span><br><span class="line">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span><br><span class="line">  &amp;&amp; <span class="built_in">rm</span> <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="line">  &amp;&amp; <span class="built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span><br></pre></td></tr></table></figure>

<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开：<code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p>
<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h3 id="2-6、VOLUME"><a href="#2-6、VOLUME" class="headerlink" title="2.6、VOLUME"></a>2.6、VOLUME</h3><p>格式为：</p>
<p><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code><br><code>VOLUME &lt;路径&gt;</code><br>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>

<p>这里的 &#x2F;data 目录就会在运行时自动挂载为匿名卷，任何向 &#x2F;data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>

<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 &#x2F;data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p>
<h3 id="2-7、EXPOSE"><a href="#2-7、EXPOSE" class="headerlink" title="2.7、EXPOSE"></a>2.7、EXPOSE</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 –icc&#x3D;false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 –links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 –icc&#x3D;false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。</p>
<p>要将 EXPOSE 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="2-8、WORKDIR"><a href="#2-8、WORKDIR" class="headerlink" title="2.8、WORKDIR"></a>2.8、WORKDIR</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 <code>Shell</code> 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UN <span class="built_in">cd</span> /app</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span><br></pre></td></tr></table></figure>

<p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 &#x2F;app&#x2F;world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR指令。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制部署一套完整的企业级K8s集群</title>
    <url>/2022/12/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E4%B8%80%E5%A5%97%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BC%81%E4%B8%9A%E7%BA%A7K8s%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="部署一套完整的企业级K8s集群"><a href="#部署一套完整的企业级K8s集群" class="headerlink" title="部署一套完整的企业级K8s集群"></a>部署一套完整的企业级K8s集群</h1><p><strong>v1.22</strong>**，二进制方式**</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>  该文档有导航窗格，方便阅读，如果左侧没有显示，请检查word是否启用。    文档中涉及涉及文件都下载好了，如果有需要可私信阿良获取最新包。     转载请注明作者，拒绝不道德行为！</th>
</tr>
</thead>
<tbody><tr>
<td>一键部署脚本</td>
<td><a href="https://github.com/lizhenliang/ansible-install-k8s">https://github.com/lizhenliang/ansible-install-k8s</a></td>
</tr>
<tr>
<td>最后更新时间</td>
<td>2021-11-25</td>
</tr>
</tbody></table>
<h2 id="一、前置知识点"><a href="#一、前置知识点" class="headerlink" title="一、前置知识点"></a>一、前置知识点</h2><h3 id="1-1-生产环境部署K8s集群的两种方式"><a href="#1-1-生产环境部署K8s集群的两种方式" class="headerlink" title="1.1 生产环境部署K8s集群的两种方式"></a>1.1 生产环境部署K8s集群的两种方式</h3><p>•   <strong>kubeadm</strong></p>
<p>Kubeadm是一个K8s部署工具，提供kubeadm init和kubeadm join，用于快速部署Kubernetes集群。</p>
<p>•   <strong>二进制包</strong></p>
<p>从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p>
<p>小结：Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p>
<h3 id="1-2-准备环境"><a href="#1-2-准备环境" class="headerlink" title="1.2 准备环境"></a>1.2 准备环境</h3><p>服务器要求：</p>
<p>•   建议最小硬件配置：2核CPU、2G内存、30G硬盘</p>
<p>•   服务器最好可以访问外网，会有从网上拉取镜像需求，如果服务器不能上网，需要提前下载对应镜像并导入节点，或者替换国内源</p>
<p>软件环境：</p>
<table>
<thead>
<tr>
<th><strong>软件</strong></th>
<th><strong>版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>CentOS7.x_x64  （mini）</td>
</tr>
<tr>
<td>容器引擎</td>
<td>Docker  CE 19</td>
</tr>
<tr>
<td>Kubernetes</td>
<td>Kubernetes  v1.20</td>
</tr>
</tbody></table>
<p>服务器整体规划：</p>
<table>
<thead>
<tr>
<th><strong>角色</strong></th>
<th><strong>IP</strong></th>
<th><strong>组件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>k8s-master1</td>
<td>192.168.31.71</td>
<td>kube-apiserver，kube-controller-manager，kube-scheduler，kubelet，kube-proxy，docker，etcd，  nginx，keepalived</td>
</tr>
<tr>
<td>k8s-master2</td>
<td>192.168.31.74</td>
<td>kube-apiserver，kube-controller-manager，kube-scheduler，kubelet，kube-proxy，docker，  nginx，keepalived</td>
</tr>
<tr>
<td>k8s-node1</td>
<td>192.168.31.72</td>
<td>kubelet，kube-proxy，docker，etcd</td>
</tr>
<tr>
<td>k8s-node2</td>
<td>192.168.31.73</td>
<td>kubelet，kube-proxy，docker，etcd</td>
</tr>
<tr>
<td>负载均衡器IP</td>
<td>192.168.31.88 (VIP)</td>
<td></td>
</tr>
</tbody></table>
<p>须知：考虑到有些朋友电脑配置较低，一次性开四台机器会跑不动，所以搭建这套K8s高可用集群分两部分实施，先部署一套单Master架构（3台），再扩容为多Master架构（4台或6台），顺便再熟悉下Master扩容流程。</p>
<p>单Master架构图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202209051505469.png" alt="image-20220905150320750"></p>
<p>单Master服务器规划：</p>
<table>
<thead>
<tr>
<th><strong>角色</strong></th>
<th><strong>IP</strong></th>
<th><strong>组件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>k8s-master</td>
<td>192.168.31.71</td>
<td>kube-apiserver，kube-controller-manager，kube-scheduler，etcd</td>
</tr>
<tr>
<td>k8s-node1</td>
<td>192.168.31.72</td>
<td>kubelet，kube-proxy，docker，etcd</td>
</tr>
<tr>
<td>k8s-node2</td>
<td>192.168.31.73</td>
<td>kubelet，kube-proxy，docker，etcd</td>
</tr>
</tbody></table>
<h3 id="1-3-操作系统初始化配置"><a href="#1-3-操作系统初始化配置" class="headerlink" title="1.3 操作系统初始化配置"></a>1.3 操作系统初始化配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙 </span></span><br><span class="line">systemctl stop firewalld </span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭selinux </span></span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="comment"># 永久</span></span><br><span class="line">setenforce 0  <span class="comment"># 临时 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 关闭swap </span></span><br><span class="line">swapoff -a  <span class="comment"># 临时 </span></span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab    <span class="comment"># 永久</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 根据规划设置主机名 </span></span><br><span class="line">hostnamectl set-hostname &lt;hostname&gt; </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在master添加hosts </span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">192.168.31.71 k8s-master1 </span></span><br><span class="line"><span class="string">192.168.31.72 k8s-node1 </span></span><br><span class="line"><span class="string">192.168.31.73 k8s-node2 </span></span><br><span class="line"><span class="string">EOF</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将桥接的IPv4流量传递到iptables的链 </span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1 </span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1 </span></span><br><span class="line"><span class="string">EOF</span> </span><br><span class="line">sysctl --system  <span class="comment"># 生效 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 时间同步 </span></span><br><span class="line">yum install ntpdate -y </span><br><span class="line">ntpdate time.windows.com</span><br></pre></td></tr></table></figure>

<h2 id="二、部署Etcd集群"><a href="#二、部署Etcd集群" class="headerlink" title="二、部署Etcd集群"></a>二、部署Etcd集群</h2><p>Etcd 是一个分布式键值存储系统，Kubernetes使用Etcd进行数据存储，所以先准备一个Etcd数据库，为解决Etcd单点故障，应采用集群方式部署，这里使用3台组建集群，可容忍1台机器故障，当然，你也可以使用5台组建集群，可容忍2台机器故障。</p>
<table>
<thead>
<tr>
<th><strong>节点名称</strong></th>
<th><strong>IP</strong></th>
</tr>
</thead>
<tbody><tr>
<td>etcd-1</td>
<td>192.168.31.71</td>
</tr>
<tr>
<td>etcd-2</td>
<td>192.168.31.72</td>
</tr>
<tr>
<td>etcd-3</td>
<td>192.168.31.73</td>
</tr>
</tbody></table>
<p>注：为了节省机器，这里与K8s节点机器复用。也可以独立于k8s集群之外部署，只要apiserver能连接到就行。</p>
<h3 id="2-1-准备cfssl证书生成工具"><a href="#2-1-准备cfssl证书生成工具" class="headerlink" title="2.1 准备cfssl证书生成工具"></a>2.1 准备cfssl证书生成工具</h3><p>cfssl是一个开源的证书管理工具，使用json文件生成证书，相比openssl更方便使用。</p>
<p>找任意一台服务器操作，这里用Master节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64</span><br><span class="line"><span class="built_in">mv</span> cfssl_linux-amd64 /usr/local/bin/cfssl</span><br><span class="line"><span class="built_in">mv</span> cfssljson_linux-amd64 /usr/local/bin/cfssljson</span><br><span class="line"><span class="built_in">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure>

<h3 id="2-2-生成Etcd证书"><a href="#2-2-生成Etcd证书" class="headerlink" title="2.2 生成Etcd证书"></a>2.2 生成Etcd证书</h3><h4 id="1-自签证书颁发机构（CA）"><a href="#1-自签证书颁发机构（CA）" class="headerlink" title="1. 自签证书颁发机构（CA）"></a>1. 自签证书颁发机构（CA）</h4><p>创建工作目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/TLS/&#123;etcd,k8s&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/TLS/etcd</span><br></pre></td></tr></table></figure>

<p>自签CA：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ca-config.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;www&quot;: &#123;</span></span><br><span class="line"><span class="string">         &quot;expiry&quot;: &quot;87600h&quot;,</span></span><br><span class="line"><span class="string">         &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; ca-csr.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;etcd CA&quot;,</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;Beijing&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;Beijing&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>生成证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br></pre></td></tr></table></figure>

<p>会生成ca.pem和ca-key.pem文件。</p>
<h4 id="2-使用自签CA签发Etcd-HTTPS证书"><a href="#2-使用自签CA签发Etcd-HTTPS证书" class="headerlink" title="2. 使用自签CA签发Etcd HTTPS证书"></a>2. 使用自签CA签发Etcd HTTPS证书</h4><p>创建证书申请文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; server-csr.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;etcd&quot;,</span></span><br><span class="line"><span class="string">    &quot;hosts&quot;: [</span></span><br><span class="line"><span class="string">    &quot;192.168.31.71&quot;,</span></span><br><span class="line"><span class="string">    &quot;192.168.31.72&quot;,</span></span><br><span class="line"><span class="string">    &quot;192.168.31.73&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;BeiJing&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>注：上述文件hosts字段中IP为所有etcd节点的集群内部通信IP，一个都不能少！为了方便后期扩容可以多写几个预留的IP。</p>
<p>生成证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</span><br></pre></td></tr></table></figure>

<p>会生成server.pem和server-key.pem文件。</p>
<h3 id="2-3-从Github下载二进制文件"><a href="#2-3-从Github下载二进制文件" class="headerlink" title="2.3 从Github下载二进制文件"></a>2.3 从Github下载二进制文件</h3><p>下载地址：<a href="https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz">https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz</a></p>
<h3 id="2-4-部署Etcd集群"><a href="#2-4-部署Etcd集群" class="headerlink" title="2.4 部署Etcd集群"></a>2.4 部署Etcd集群</h3><p>以下在节点1上操作，为简化操作，待会将节点1生成的所有文件拷贝到节点2和节点3.</p>
<h4 id="1-创建工作目录并解压二进制包"><a href="#1-创建工作目录并解压二进制包" class="headerlink" title="1. 创建工作目录并解压二进制包"></a>1. 创建工作目录并解压二进制包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/etcd/&#123;bin,cfg,ssl&#125; -p</span><br><span class="line">tar zxvf etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> etcd-v3.4.9-linux-amd64/&#123;etcd,etcdctl&#125; /opt/etcd/bin/</span><br></pre></td></tr></table></figure>

<h4 id="2-创建etcd配置文件"><a href="#2-创建etcd配置文件" class="headerlink" title="2. 创建etcd配置文件"></a>2. 创建etcd配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /opt/etcd/cfg/etcd.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">#[Member]</span></span><br><span class="line"><span class="string">ETCD_NAME=&quot;etcd-1&quot;</span></span><br><span class="line"><span class="string">ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line"><span class="string">ETCD_LISTEN_PEER_URLS=&quot;https://192.168.31.71:2380&quot;</span></span><br><span class="line"><span class="string">ETCD_LISTEN_CLIENT_URLS=&quot;https://192.168.31.71:2379&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#[Clustering]</span></span><br><span class="line"><span class="string">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://192.168.31.71:2380&quot;</span></span><br><span class="line"><span class="string">ETCD_ADVERTISE_CLIENT_URLS=&quot;https://192.168.31.71:2379&quot;</span></span><br><span class="line"><span class="string">ETCD_INITIAL_CLUSTER=&quot;etcd-1=https://192.168.31.71:2380,etcd-2=https://192.168.31.72:2380,etcd-3=https://192.168.31.73:2380&quot;</span></span><br><span class="line"><span class="string">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span></span><br><span class="line"><span class="string">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>•   ETCD_NAME：节点名称，集群中唯一</p>
<p>•   ETCD_DATA_DIR：数据目录</p>
<p>•   ETCD_LISTEN_PEER_URLS：集群通信监听地址</p>
<p>•   ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址</p>
<p>•   ETCD_INITIAL_ADVERTISE_PEERURLS：集群通告地址</p>
<p>•   ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址</p>
<p>•   ETCD_INITIAL_CLUSTER：集群节点地址</p>
<p>•   ETCD_INITIALCLUSTER_TOKEN：集群Token</p>
<p>•   ETCD_INITIALCLUSTER_STATE：加入集群的当前状态，new是新集群，existing表示加入已有集群</p>
<h4 id="3-systemd管理etcd"><a href="#3-systemd管理etcd" class="headerlink" title="3. systemd管理etcd"></a>3. systemd管理etcd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/etcd.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Etcd Server</span></span><br><span class="line"><span class="string">After=network.target</span></span><br><span class="line"><span class="string">After=network-online.target</span></span><br><span class="line"><span class="string">Wants=network-online.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=notify</span></span><br><span class="line"><span class="string">EnvironmentFile=/opt/etcd/cfg/etcd.conf</span></span><br><span class="line"><span class="string">ExecStart=/opt/etcd/bin/etcd \</span></span><br><span class="line"><span class="string">--cert-file=/opt/etcd/ssl/server.pem \</span></span><br><span class="line"><span class="string">--key-file=/opt/etcd/ssl/server-key.pem \</span></span><br><span class="line"><span class="string">--peer-cert-file=/opt/etcd/ssl/server.pem \</span></span><br><span class="line"><span class="string">--peer-key-file=/opt/etcd/ssl/server-key.pem \</span></span><br><span class="line"><span class="string">--trusted-ca-file=/opt/etcd/ssl/ca.pem \</span></span><br><span class="line"><span class="string">--peer-trusted-ca-file=/opt/etcd/ssl/ca.pem \</span></span><br><span class="line"><span class="string">--logger=zap</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">LimitNOFILE=65536</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="4-拷贝刚才生成的证书"><a href="#4-拷贝刚才生成的证书" class="headerlink" title="4. 拷贝刚才生成的证书"></a>4. 拷贝刚才生成的证书</h4><p>把刚才生成的证书拷贝到配置文件中的路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/TLS/etcd/ca*pem ~/TLS/etcd/server*pem /opt/etcd/ssl/</span><br></pre></td></tr></table></figure>

<h4 id="5-启动并设置开机启动"><a href="#5-启动并设置开机启动" class="headerlink" title="5. 启动并设置开机启动"></a>5. 启动并设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl <span class="built_in">enable</span> etcd</span><br></pre></td></tr></table></figure>

<h4 id="6-将上面节点1所有生成的文件拷贝到节点2和节点3"><a href="#6-将上面节点1所有生成的文件拷贝到节点2和节点3" class="headerlink" title="6. 将上面节点1所有生成的文件拷贝到节点2和节点3"></a>6. 将上面节点1所有生成的文件拷贝到节点2和节点3</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /opt/etcd/ root@192.168.31.72:/opt/</span><br><span class="line">scp /usr/lib/systemd/system/etcd.service root@192.168.31.72:/usr/lib/systemd/system/</span><br><span class="line">scp -r /opt/etcd/ root@192.168.31.73:/opt/</span><br><span class="line">scp /usr/lib/systemd/system/etcd.service root@192.168.31.73:/usr/lib/systemd/system/</span><br></pre></td></tr></table></figure>

<p>然后在节点2和节点3分别修改etcd.conf配置文件中的节点名称和当前服务器IP：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /opt/etcd/cfg/etcd.conf</span><br><span class="line"><span class="comment">#[Member]</span></span><br><span class="line">ETCD_NAME=<span class="string">&quot;etcd-1&quot;</span>   <span class="comment"># 修改此处，节点2改为etcd-2，节点3改为etcd-3</span></span><br><span class="line">ETCD_DATA_DIR=<span class="string">&quot;/var/lib/etcd/default.etcd&quot;</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">&quot;https://192.168.31.71:2380&quot;</span>   <span class="comment"># 修改此处为当前服务器IP</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;https://192.168.31.71:2379&quot;</span> <span class="comment"># 修改此处为当前服务器IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">&quot;https://192.168.31.71:2380&quot;</span> <span class="comment"># 修改此处为当前服务器IP</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;https://192.168.31.71:2379&quot;</span> <span class="comment"># 修改此处为当前服务器IP</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">&quot;etcd-1=https://192.168.31.71:2380,etcd-2=https://192.168.31.72:2380,etcd-3=https://192.168.31.73:2380&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">&quot;etcd-cluster&quot;</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">&quot;new&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后启动etcd并设置开机启动，同上。</p>
<h4 id="7-查看集群状态"><a href="#7-查看集群状态" class="headerlink" title="7. 查看集群状态"></a>7. 查看集群状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 /opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints=<span class="string">&quot;https://192.168.31.71:2379,https://192.168.31.72:2379,https://192.168.31.73:2379&quot;</span> endpoint health --write-out=table</span><br><span class="line"></span><br><span class="line">+----------------------------+--------+-------------+-------+</span><br><span class="line">|          ENDPOINT    | HEALTH |    TOOK     | ERROR |</span><br><span class="line">+----------------------------+--------+-------------+-------+</span><br><span class="line">| https://192.168.31.71:2379 |   <span class="literal">true</span> | 10.301506ms |    |</span><br><span class="line">| https://192.168.31.73:2379 |   <span class="literal">true</span> | 12.87467ms |     |</span><br><span class="line">| https://192.168.31.72:2379 |   <span class="literal">true</span> | 13.225954ms |    |</span><br><span class="line">+----------------------------+--------+-------------+-------+</span><br></pre></td></tr></table></figure>

<p>如果输出上面信息，就说明集群部署成功。</p>
<p>如果有问题第一步先看日志：&#x2F;var&#x2F;log&#x2F;message 或 journalctl -u etcd</p>
<h2 id="三、安装Docker"><a href="#三、安装Docker" class="headerlink" title="三、安装Docker"></a>三、安装Docker</h2><p>这里使用Docker作为容器引擎，也可以换成别的，例如containerd</p>
<p>下载地址：<a href="https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz">https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz</a></p>
<p>以下在所有节点操作。这里采用二进制安装，用yum安装也一样。</p>
<h3 id="3-1-解压二进制包"><a href="#3-1-解压二进制包" class="headerlink" title="3.1 解压二进制包"></a>3.1 解压二进制包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf docker-19.03.9.tgz</span><br><span class="line"><span class="built_in">mv</span> docker/* /usr/bin</span><br></pre></td></tr></table></figure>

<h3 id="3-2-systemd管理docker"><a href="#3-2-systemd管理docker" class="headerlink" title="3.2 systemd管理docker"></a>3.2 systemd管理docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/docker.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Docker Application Container Engine</span></span><br><span class="line"><span class="string">Documentation=https://docs.docker.com</span></span><br><span class="line"><span class="string">After=network-online.target firewalld.service</span></span><br><span class="line"><span class="string">Wants=network-online.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=notify</span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/dockerd</span></span><br><span class="line"><span class="string">ExecReload=/bin/kill -s HUP $MAINPID</span></span><br><span class="line"><span class="string">LimitNOFILE=infinity</span></span><br><span class="line"><span class="string">LimitNPROC=infinity</span></span><br><span class="line"><span class="string">LimitCORE=infinity</span></span><br><span class="line"><span class="string">TimeoutStartSec=0</span></span><br><span class="line"><span class="string">Delegate=yes</span></span><br><span class="line"><span class="string">KillMode=process</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">StartLimitBurst=3</span></span><br><span class="line"><span class="string">StartLimitInterval=60s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-创建配置文件"><a href="#3-3-创建配置文件" class="headerlink" title="3.3 创建配置文件"></a>3.3 创建配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /etc/docker</span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>•   registry-mirrors 阿里云镜像加速器</p>
<h3 id="3-4-启动并设置开机启动"><a href="#3-4-启动并设置开机启动" class="headerlink" title="3.4 启动并设置开机启动"></a>3.4 启动并设置开机启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<h2 id="四、部署Master-Node"><a href="#四、部署Master-Node" class="headerlink" title="四、部署Master Node"></a>四、部署Master Node</h2><p>如果你在学习中遇到问题或者文档有误可联系阿良~ 微信: k8init</p>
<h3 id="4-1-生成kube-apiserver证书"><a href="#4-1-生成kube-apiserver证书" class="headerlink" title="4.1 生成kube-apiserver证书"></a>4.1 生成kube-apiserver证书</h3><h4 id="1-自签证书颁发机构（CA）-1"><a href="#1-自签证书颁发机构（CA）-1" class="headerlink" title="1. 自签证书颁发机构（CA）"></a>1. 自签证书颁发机构（CA）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/TLS/k8s</span><br><span class="line"><span class="built_in">cat</span> &gt; ca-config.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;87600h&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;: &#123;</span></span><br><span class="line"><span class="string">         &quot;expiry&quot;: &quot;87600h&quot;,</span></span><br><span class="line"><span class="string">         &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">cat</span> &gt; ca-csr.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;kubernetes&quot;,</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;Beijing&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;Beijing&quot;,</span></span><br><span class="line"><span class="string">            &quot;O&quot;: &quot;k8s&quot;,</span></span><br><span class="line"><span class="string">            &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>生成证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br></pre></td></tr></table></figure>

<p>会生成ca.pem和ca-key.pem文件。</p>
<h4 id="2-使用自签CA签发kube-apiserver-HTTPS证书"><a href="#2-使用自签CA签发kube-apiserver-HTTPS证书" class="headerlink" title="2. 使用自签CA签发kube-apiserver HTTPS证书"></a>2. 使用自签CA签发kube-apiserver HTTPS证书</h4><p>创建证书申请文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; server-csr.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;kubernetes&quot;,</span></span><br><span class="line"><span class="string">    &quot;hosts&quot;: [</span></span><br><span class="line"><span class="string">      &quot;10.0.0.1&quot;,</span></span><br><span class="line"><span class="string">      &quot;127.0.0.1&quot;,</span></span><br><span class="line"><span class="string">      &quot;192.168.31.71&quot;,</span></span><br><span class="line"><span class="string">      &quot;192.168.31.72&quot;,</span></span><br><span class="line"><span class="string">      &quot;192.168.31.73&quot;,</span></span><br><span class="line"><span class="string">&quot;192.168.31.74&quot;,</span></span><br><span class="line"><span class="string">      &quot;192.168.31.88&quot;,</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;,</span></span><br><span class="line"><span class="string">      &quot;kubernetes.default&quot;,</span></span><br><span class="line"><span class="string">      &quot;kubernetes.default.svc&quot;,</span></span><br><span class="line"><span class="string">      &quot;kubernetes.default.svc.cluster&quot;,</span></span><br><span class="line"><span class="string">      &quot;kubernetes.default.svc.cluster.local&quot;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">            &quot;O&quot;: &quot;k8s&quot;,</span></span><br><span class="line"><span class="string">            &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>注：上述文件hosts字段中IP为所有Master&#x2F;LB&#x2F;VIP IP，一个都不能少！为了方便后期扩容可以多写几个预留的IP。</p>
<p>生成证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server</span><br></pre></td></tr></table></figure>

<p>会生成server.pem和server-key.pem文件。</p>
<h3 id="4-2-从Github下载二进制文件"><a href="#4-2-从Github下载二进制文件" class="headerlink" title="4.2 从Github下载二进制文件"></a>4.2 从Github下载二进制文件</h3><p>下载地址： <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md">https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md</a></p>
<p>注：打开链接你会发现里面有很多包，下载一个server包就够了，包含了Master和Worker Node二进制文件。</p>
<h3 id="4-3-解压二进制包"><a href="#4-3-解压二进制包" class="headerlink" title="4.3 解压二进制包"></a>4.3 解压二进制包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125; </span><br><span class="line">tar zxvf kubernetes-server-linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> kubernetes/server/bin</span><br><span class="line"><span class="built_in">cp</span> kube-apiserver kube-scheduler kube-controller-manager /opt/kubernetes/bin</span><br><span class="line"><span class="built_in">cp</span> kubectl /usr/bin/</span><br></pre></td></tr></table></figure>

<h3 id="4-4-部署kube-apiserver"><a href="#4-4-部署kube-apiserver" class="headerlink" title="4.4 部署kube-apiserver"></a>4.4 部署kube-apiserver</h3><h4 id="1-创建配置文件"><a href="#1-创建配置文件" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /opt/kubernetes/cfg/kube-apiserver.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">KUBE_APISERVER_OPTS=&quot;--logtostderr=false \\</span></span><br><span class="line"><span class="string">--v=2 \\</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \\</span></span><br><span class="line"><span class="string">--etcd-servers=https://192.168.31.71:2379,https://192.168.31.72:2379,https://192.168.31.73:2379 \\</span></span><br><span class="line"><span class="string">--bind-address=192.168.31.71 \\</span></span><br><span class="line"><span class="string">--secure-port=6443 \\</span></span><br><span class="line"><span class="string">--advertise-address=192.168.31.71 \\</span></span><br><span class="line"><span class="string">--allow-privileged=true \\</span></span><br><span class="line"><span class="string">--service-cluster-ip-range=10.0.0.0/24 \\</span></span><br><span class="line"><span class="string">--enable-admission-plugins=NodeRestriction \\</span></span><br><span class="line"><span class="string">--authorization-mode=RBAC,Node \\</span></span><br><span class="line"><span class="string">--enable-bootstrap-token-auth=true \\</span></span><br><span class="line"><span class="string">--token-auth-file=/opt/kubernetes/cfg/token.csv \\</span></span><br><span class="line"><span class="string">--service-node-port-range=30000-32767 \\</span></span><br><span class="line"><span class="string">--kubelet-client-certificate=/opt/kubernetes/ssl/server.pem \\</span></span><br><span class="line"><span class="string">--kubelet-client-key=/opt/kubernetes/ssl/server-key.pem \\</span></span><br><span class="line"><span class="string">--tls-cert-file=/opt/kubernetes/ssl/server.pem  \\</span></span><br><span class="line"><span class="string">--tls-private-key-file=/opt/kubernetes/ssl/server-key.pem \\</span></span><br><span class="line"><span class="string">--client-ca-file=/opt/kubernetes/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">--service-account-key-file=/opt/kubernetes/ssl/ca-key.pem \\</span></span><br><span class="line"><span class="string">--service-account-issuer=api \\</span></span><br><span class="line"><span class="string">--service-account-signing-key-file=/opt/kubernetes/ssl/ca-key.pem \\</span></span><br><span class="line"><span class="string">--etcd-cafile=/opt/etcd/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">--etcd-certfile=/opt/etcd/ssl/server.pem \\</span></span><br><span class="line"><span class="string">--etcd-keyfile=/opt/etcd/ssl/server-key.pem \\</span></span><br><span class="line"><span class="string">--requestheader-client-ca-file=/opt/kubernetes/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">--proxy-client-cert-file=/opt/kubernetes/ssl/server.pem \\</span></span><br><span class="line"><span class="string">--proxy-client-key-file=/opt/kubernetes/ssl/server-key.pem \\</span></span><br><span class="line"><span class="string">--requestheader-allowed-names=kubernetes \\</span></span><br><span class="line"><span class="string">--requestheader-extra-headers-prefix=X-Remote-Extra- \\</span></span><br><span class="line"><span class="string">--requestheader-group-headers=X-Remote-Group \\</span></span><br><span class="line"><span class="string">--requestheader-username-headers=X-Remote-User \\</span></span><br><span class="line"><span class="string">--enable-aggregator-routing=true \\</span></span><br><span class="line"><span class="string">--audit-log-maxage=30 \\</span></span><br><span class="line"><span class="string">--audit-log-maxbackup=3 \\</span></span><br><span class="line"><span class="string">--audit-log-maxsize=100 \\</span></span><br><span class="line"><span class="string">--audit-log-path=/opt/kubernetes/logs/k8s-audit.log&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>注：上面两个\ \ 第一个是转义符，第二个是换行符，使用转义符是为了使用EOF保留换行符。</p>
<p>•   –logtostderr：启用日志</p>
<p>•   —v：日志等级</p>
<p>•   –log-dir：日志目录</p>
<p>•   –etcd-servers：etcd集群地址</p>
<p>•   –bind-address：监听地址</p>
<p>•   –secure-port：https安全端口</p>
<p>•   –advertise-address：集群通告地址</p>
<p>•   –allow-privileged：启用授权</p>
<p>•   –service-cluster-ip-range：Service虚拟IP地址段</p>
<p>•   –enable-admission-plugins：准入控制模块</p>
<p>•   –authorization-mode：认证授权，启用RBAC授权和节点自管理</p>
<p>•   –enable-bootstrap-token-auth：启用TLS bootstrap机制</p>
<p>•   –token-auth-file：bootstrap token文件</p>
<p>•   –service-node-port-range：Service nodeport类型默认分配端口范围</p>
<p>•   –kubelet-client-xxx：apiserver访问kubelet客户端证书</p>
<p>•   –tls-xxx-file：apiserver https证书</p>
<p>•   1.20版本必须加的参数：–service-account-issuer，–service-account-signing-key-file</p>
<p>•   –etcd-xxxfile：连接Etcd集群证书</p>
<p>•   –audit-log-xxx：审计日志</p>
<p>•   启动聚合层相关配置：–requestheader-client-ca-file，–proxy-client-cert-file，–proxy-client-key-file，–requestheader-allowed-names，–requestheader-extra-headers-prefix，–requestheader-group-headers，–requestheader-username-headers，–enable-aggregator-routing</p>
<h4 id="2-拷贝刚才生成的证书"><a href="#2-拷贝刚才生成的证书" class="headerlink" title="2. 拷贝刚才生成的证书"></a>2. 拷贝刚才生成的证书</h4><p>把刚才生成的证书拷贝到配置文件中的路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/TLS/k8s/ca*pem ~/TLS/k8s/server*pem /opt/kubernetes/ssl/</span><br></pre></td></tr></table></figure>

<h4 id="3-启用-TLS-Bootstrapping-机制"><a href="#3-启用-TLS-Bootstrapping-机制" class="headerlink" title="3. 启用 TLS Bootstrapping 机制"></a>3. 启用 TLS Bootstrapping 机制</h4><p>TLS Bootstraping：Master apiserver启用TLS认证后，Node节点kubelet和kube-proxy要与kube-apiserver进行通信，必须使用CA签发的有效证书才可以，当Node节点很多时，这种客户端证书颁发需要大量工作，同样也会增加集群扩展复杂度。为了简化流程，Kubernetes引入了TLS bootstraping机制来自动颁发客户端证书，kubelet会以一个低权限用户自动向apiserver申请证书，kubelet的证书由apiserver动态签署。所以强烈建议在Node上使用这种方式，目前主要用于kubelet，kube-proxy还是由我们统一颁发一个证书。</p>
<p>TLS bootstraping 工作流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202209051507161.png" alt="image-20220905150724039"></p>
<p>创建上述配置文件中token文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /opt/kubernetes/cfg/token.csv &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">c47ffb939f5ca36231d9e3121a252940,kubelet-bootstrap,10001,&quot;system:node-bootstrapper&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>格式：token，用户名，UID，用户组</p>
<p>token也可自行生成替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -c 16 /dev/urandom | <span class="built_in">od</span> -An -t x | <span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-systemd管理apiserver"><a href="#4-systemd管理apiserver" class="headerlink" title="4. systemd管理apiserver"></a>4. systemd管理apiserver</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Kubernetes API Server</span></span><br><span class="line"><span class="string">Documentation=https://github.com/kubernetes/kubernetes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">EnvironmentFile=/opt/kubernetes/cfg/kube-apiserver.conf</span></span><br><span class="line"><span class="string">ExecStart=/opt/kubernetes/bin/kube-apiserver \$KUBE_APISERVER_OPTS</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="5-启动并设置开机启动-1"><a href="#5-启动并设置开机启动-1" class="headerlink" title="5. 启动并设置开机启动"></a>5. 启动并设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-apiserver </span><br><span class="line">systemctl <span class="built_in">enable</span> kube-apiserver</span><br></pre></td></tr></table></figure>

<h3 id="4-5-部署kube-controller-manager"><a href="#4-5-部署kube-controller-manager" class="headerlink" title="4.5 部署kube-controller-manager"></a>4.5 部署kube-controller-manager</h3><h4 id="1-创建配置文件-1"><a href="#1-创建配置文件-1" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /opt/kubernetes/cfg/kube-controller-manager.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">KUBE_CONTROLLER_MANAGER_OPTS=&quot;--logtostderr=false \\</span></span><br><span class="line"><span class="string">--v=2 \\</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \\</span></span><br><span class="line"><span class="string">--leader-elect=true \\</span></span><br><span class="line"><span class="string">--kubeconfig=/opt/kubernetes/cfg/kube-controller-manager.kubeconfig \\</span></span><br><span class="line"><span class="string">--bind-address=127.0.0.1 \\</span></span><br><span class="line"><span class="string">--allocate-node-cidrs=true \\</span></span><br><span class="line"><span class="string">--cluster-cidr=10.244.0.0/16 \\</span></span><br><span class="line"><span class="string">--service-cluster-ip-range=10.0.0.0/24 \\</span></span><br><span class="line"><span class="string">--cluster-signing-cert-file=/opt/kubernetes/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">--cluster-signing-key-file=/opt/kubernetes/ssl/ca-key.pem  \\</span></span><br><span class="line"><span class="string">--root-ca-file=/opt/kubernetes/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">--service-account-private-key-file=/opt/kubernetes/ssl/ca-key.pem \\</span></span><br><span class="line"><span class="string">--cluster-signing-duration=87600h0m0s&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>•   –kubeconfig：连接apiserver配置文件</p>
<p>•   –leader-elect：当该组件启动多个时，自动选举（HA）</p>
<p>•   –cluster-signing-cert-file&#x2F;–cluster-signing-key-file：自动为kubelet颁发证书的CA，与apiserver保持一致</p>
<h4 id="2-生成kubeconfig文件"><a href="#2-生成kubeconfig文件" class="headerlink" title="2. 生成kubeconfig文件"></a>2. 生成kubeconfig文件</h4><p>生成kube-controller-manager证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/TLS/k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建证书请求文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; kube-controller-manager-csr.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;system:kube-controller-manager&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;, </span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;O&quot;: &quot;system:masters&quot;,</span></span><br><span class="line"><span class="string">      &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager</span><br></pre></td></tr></table></figure>

<p>生成kubeconfig文件（以下是shell命令，直接在终端执行）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KUBE_CONFIG=<span class="string">&quot;/opt/kubernetes/cfg/kube-controller-manager.kubeconfig&quot;</span></span><br><span class="line">KUBE_APISERVER=<span class="string">&quot;https://192.168.31.71:6443&quot;</span></span><br><span class="line"></span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-credentials kube-controller-manager \</span><br><span class="line">  --client-certificate=./kube-controller-manager.pem \</span><br><span class="line">  --client-key=./kube-controller-manager-key.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kube-controller-manager \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config use-context default --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-systemd管理controller-manager"><a href="#3-systemd管理controller-manager" class="headerlink" title="3. systemd管理controller-manager"></a>3. systemd管理controller-manager</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Kubernetes Controller Manager</span></span><br><span class="line"><span class="string">Documentation=https://github.com/kubernetes/kubernetes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">EnvironmentFile=/opt/kubernetes/cfg/kube-controller-manager.conf</span></span><br><span class="line"><span class="string">ExecStart=/opt/kubernetes/bin/kube-controller-manager \$KUBE_CONTROLLER_MANAGER_OPTS</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="4-启动并设置开机启动"><a href="#4-启动并设置开机启动" class="headerlink" title="4. 启动并设置开机启动"></a>4. 启动并设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-controller-manager</span><br><span class="line">systemctl <span class="built_in">enable</span> kube-controller-manager</span><br></pre></td></tr></table></figure>

<h3 id="4-6-部署kube-scheduler"><a href="#4-6-部署kube-scheduler" class="headerlink" title="4.6 部署kube-scheduler"></a>4.6 部署kube-scheduler</h3><h4 id="1-创建配置文件-2"><a href="#1-创建配置文件-2" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /opt/kubernetes/cfg/kube-scheduler.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">KUBE_SCHEDULER_OPTS=&quot;--logtostderr=false \\</span></span><br><span class="line"><span class="string">--v=2 \\</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \\</span></span><br><span class="line"><span class="string">--leader-elect \\</span></span><br><span class="line"><span class="string">--kubeconfig=/opt/kubernetes/cfg/kube-scheduler.kubeconfig \\</span></span><br><span class="line"><span class="string">--bind-address=127.0.0.1&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>•   –kubeconfig：连接apiserver配置文件</p>
<p>•   –leader-elect：当该组件启动多个时，自动选举（HA）</p>
<h4 id="2-生成kubeconfig文件-1"><a href="#2-生成kubeconfig文件-1" class="headerlink" title="2. 生成kubeconfig文件"></a>2. 生成kubeconfig文件</h4><p>生成kube-scheduler证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/TLS/k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建证书请求文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; kube-scheduler-csr.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;system:kube-scheduler&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;O&quot;: &quot;system:masters&quot;,</span></span><br><span class="line"><span class="string">      &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler</span><br></pre></td></tr></table></figure>

<p>生成kubeconfig文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KUBE_CONFIG=<span class="string">&quot;/opt/kubernetes/cfg/kube-scheduler.kubeconfig&quot;</span></span><br><span class="line">KUBE_APISERVER=<span class="string">&quot;https://192.168.31.71:6443&quot;</span></span><br><span class="line"></span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-credentials kube-scheduler \</span><br><span class="line">  --client-certificate=./kube-scheduler.pem \</span><br><span class="line">  --client-key=./kube-scheduler-key.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kube-scheduler \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config use-context default --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-systemd管理scheduler"><a href="#3-systemd管理scheduler" class="headerlink" title="3. systemd管理scheduler"></a>3. systemd管理scheduler</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Kubernetes Scheduler</span></span><br><span class="line"><span class="string">Documentation=https://github.com/kubernetes/kubernetes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">EnvironmentFile=/opt/kubernetes/cfg/kube-scheduler.conf</span></span><br><span class="line"><span class="string">ExecStart=/opt/kubernetes/bin/kube-scheduler \$KUBE_SCHEDULER_OPTS</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="4-启动并设置开机启动-1"><a href="#4-启动并设置开机启动-1" class="headerlink" title="4. 启动并设置开机启动"></a>4. 启动并设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl <span class="built_in">enable</span> kube-scheduler</span><br></pre></td></tr></table></figure>

<h4 id="5-查看集群状态"><a href="#5-查看集群状态" class="headerlink" title="5. 查看集群状态"></a>5. 查看集群状态</h4><p>生成kubectl连接集群的证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; admin-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;admin&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;O&quot;: &quot;system:masters&quot;,</span></span><br><span class="line"><span class="string">      &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin</span><br></pre></td></tr></table></figure>

<p>生成kubeconfig文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /root/.kube</span><br><span class="line">KUBE_CONFIG=<span class="string">&quot;/root/.kube/config&quot;</span></span><br><span class="line">KUBE_APISERVER=<span class="string">&quot;https://192.168.31.71:6443&quot;</span></span><br><span class="line"></span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-credentials cluster-admin \</span><br><span class="line">  --client-certificate=./admin.pem \</span><br><span class="line">  --client-key=./admin-key.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=cluster-admin \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config use-context default --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过kubectl工具查看当前集群组件状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get cs</span><br><span class="line">NAME                STATUS    MESSAGE             ERROR</span><br><span class="line">scheduler             Healthy   ok                  </span><br><span class="line">controller-manager       Healthy   ok                  </span><br><span class="line">etcd-2               Healthy   &#123;<span class="string">&quot;health&quot;</span>:<span class="string">&quot;true&quot;</span>&#125;   </span><br><span class="line">etcd-1               Healthy   &#123;<span class="string">&quot;health&quot;</span>:<span class="string">&quot;true&quot;</span>&#125;   </span><br><span class="line">etcd-0               Healthy   &#123;<span class="string">&quot;health&quot;</span>:<span class="string">&quot;true&quot;</span>&#125;  </span><br></pre></td></tr></table></figure>

<p>如上输出说明Master节点组件运行正常。</p>
<h4 id="6-授权kubelet-bootstrap用户允许请求证书"><a href="#6-授权kubelet-bootstrap用户允许请求证书" class="headerlink" title="6. 授权kubelet-bootstrap用户允许请求证书"></a>6. 授权kubelet-bootstrap用户允许请求证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">--clusterrole=system:node-bootstrapper \</span><br><span class="line">--user=kubelet-bootstrap</span><br></pre></td></tr></table></figure>

<h2 id="五、部署Worker-Node"><a href="#五、部署Worker-Node" class="headerlink" title="五、部署Worker Node"></a>五、部署Worker Node</h2><p>如果你在学习中遇到问题或者文档有误可联系阿良~ 微信: k8init</p>
<p><strong>下面还是在Master Node上操作，即同时作为Worker Node</strong></p>
<h3 id="5-1-创建工作目录并拷贝二进制文件"><a href="#5-1-创建工作目录并拷贝二进制文件" class="headerlink" title="5.1 创建工作目录并拷贝二进制文件"></a>5.1 创建工作目录并拷贝二进制文件</h3><p>在所有worker node创建工作目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125; </span><br></pre></td></tr></table></figure>

<p>从master节点拷贝：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> kubernetes/server/bin</span><br><span class="line"><span class="built_in">cp</span> kubelet kube-proxy /opt/kubernetes/bin   <span class="comment"># 本地拷贝</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-部署kubelet"><a href="#5-2-部署kubelet" class="headerlink" title="5.2 部署kubelet"></a>5.2 部署kubelet</h3><h4 id="1-创建配置文件-3"><a href="#1-创建配置文件-3" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /opt/kubernetes/cfg/kubelet.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">KUBELET_OPTS=&quot;--logtostderr=false \\</span></span><br><span class="line"><span class="string">--v=2 \\</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \\</span></span><br><span class="line"><span class="string">--hostname-override=k8s-master1 \\</span></span><br><span class="line"><span class="string">--network-plugin=cni \\</span></span><br><span class="line"><span class="string">--kubeconfig=/opt/kubernetes/cfg/kubelet.kubeconfig \\</span></span><br><span class="line"><span class="string">--bootstrap-kubeconfig=/opt/kubernetes/cfg/bootstrap.kubeconfig \\</span></span><br><span class="line"><span class="string">--config=/opt/kubernetes/cfg/kubelet-config.yml \\</span></span><br><span class="line"><span class="string">--cert-dir=/opt/kubernetes/ssl \\</span></span><br><span class="line"><span class="string">--pod-infra-container-image=lizhenliang/pause-amd64:3.0&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>•   –hostname-override：显示名称，集群中唯一</p>
<p>•   –network-plugin：启用CNI</p>
<p>•   –kubeconfig：空路径，会自动生成，后面用于连接apiserver</p>
<p>•   –bootstrap-kubeconfig：首次启动向apiserver申请证书</p>
<p>•   –config：配置参数文件</p>
<p>•   –cert-dir：kubelet证书生成目录</p>
<p>•   –pod-infra-container-image：管理Pod网络容器的镜像</p>
<h4 id="2-配置参数文件"><a href="#2-配置参数文件" class="headerlink" title="2. 配置参数文件"></a>2. 配置参数文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /opt/kubernetes/cfg/kubelet-config.yml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: KubeletConfiguration</span></span><br><span class="line"><span class="string">apiVersion: kubelet.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="string">address: 0.0.0.0</span></span><br><span class="line"><span class="string">port: 10250</span></span><br><span class="line"><span class="string">readOnlyPort: 10255</span></span><br><span class="line"><span class="string">cgroupDriver: cgroupfs</span></span><br><span class="line"><span class="string">clusterDNS:</span></span><br><span class="line"><span class="string">- 10.0.0.2</span></span><br><span class="line"><span class="string">clusterDomain: cluster.local </span></span><br><span class="line"><span class="string">failSwapOn: false</span></span><br><span class="line"><span class="string">authentication:</span></span><br><span class="line"><span class="string">  anonymous:</span></span><br><span class="line"><span class="string">    enabled: false</span></span><br><span class="line"><span class="string">  webhook:</span></span><br><span class="line"><span class="string">    cacheTTL: 2m0s</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  x509:</span></span><br><span class="line"><span class="string">    clientCAFile: /opt/kubernetes/ssl/ca.pem </span></span><br><span class="line"><span class="string">authorization:</span></span><br><span class="line"><span class="string">  mode: Webhook</span></span><br><span class="line"><span class="string">  webhook:</span></span><br><span class="line"><span class="string">    cacheAuthorizedTTL: 5m0s</span></span><br><span class="line"><span class="string">    cacheUnauthorizedTTL: 30s</span></span><br><span class="line"><span class="string">evictionHard:</span></span><br><span class="line"><span class="string">  imagefs.available: 15%</span></span><br><span class="line"><span class="string">  memory.available: 100Mi</span></span><br><span class="line"><span class="string">  nodefs.available: 10%</span></span><br><span class="line"><span class="string">  nodefs.inodesFree: 5%</span></span><br><span class="line"><span class="string">maxOpenFiles: 1000000</span></span><br><span class="line"><span class="string">maxPods: 110</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="3-生成kubelet初次加入集群引导kubeconfig文件"><a href="#3-生成kubelet初次加入集群引导kubeconfig文件" class="headerlink" title="3. 生成kubelet初次加入集群引导kubeconfig文件"></a>3. 生成kubelet初次加入集群引导kubeconfig文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KUBE_CONFIG=<span class="string">&quot;/opt/kubernetes/cfg/bootstrap.kubeconfig&quot;</span></span><br><span class="line">KUBE_APISERVER=<span class="string">&quot;https://192.168.31.71:6443&quot;</span> <span class="comment"># apiserver IP:PORT</span></span><br><span class="line">TOKEN=<span class="string">&quot;c47ffb939f5ca36231d9e3121a252940&quot;</span> <span class="comment"># 与token.csv里保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 kubelet bootstrap kubeconfig 配置文件</span></span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-credentials <span class="string">&quot;kubelet-bootstrap&quot;</span> \</span><br><span class="line">  --token=<span class="variable">$&#123;TOKEN&#125;</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=<span class="string">&quot;kubelet-bootstrap&quot;</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config use-context default --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-systemd管理kubelet"><a href="#4-systemd管理kubelet" class="headerlink" title="4. systemd管理kubelet"></a>4. systemd管理kubelet</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Kubernetes Kubelet</span></span><br><span class="line"><span class="string">After=docker.service</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">EnvironmentFile=/opt/kubernetes/cfg/kubelet.conf</span></span><br><span class="line"><span class="string">ExecStart=/opt/kubernetes/bin/kubelet \$KUBELET_OPTS</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">LimitNOFILE=65536</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="5-启动并设置开机启动-2"><a href="#5-启动并设置开机启动-2" class="headerlink" title="5. 启动并设置开机启动"></a>5. 启动并设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure>

<h3 id="5-3-批准kubelet证书申请并加入集群"><a href="#5-3-批准kubelet证书申请并加入集群" class="headerlink" title="5.3 批准kubelet证书申请并加入集群"></a>5.3 批准kubelet证书申请并加入集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看kubelet证书请求</span></span><br><span class="line">kubectl get csr</span><br><span class="line">NAME                                                   AGE    SIGNERNAME                                    REQUESTOR           CONDITION</span><br><span class="line">node-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ--K6M4G7bjhk8A   6m3s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批准申请</span></span><br><span class="line">kubectl certificate approve node-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ--K6M4G7bjhk8A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点</span></span><br><span class="line">kubectl get node</span><br><span class="line">NAME         STATUS     ROLES    AGE   VERSION</span><br><span class="line">k8s-master1   NotReady   &lt;none&gt;   7s    v1.18.3</span><br></pre></td></tr></table></figure>

<p>注：由于网络插件还没有部署，节点会没有准备就绪 NotReady</p>
<h3 id="5-4-部署kube-proxy"><a href="#5-4-部署kube-proxy" class="headerlink" title="5.4 部署kube-proxy"></a>5.4 部署kube-proxy</h3><h4 id="1-创建配置文件-4"><a href="#1-创建配置文件-4" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /opt/kubernetes/cfg/kube-proxy.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">KUBE_PROXY_OPTS=&quot;--logtostderr=false \\</span></span><br><span class="line"><span class="string">--v=2 \\</span></span><br><span class="line"><span class="string">--log-dir=/opt/kubernetes/logs \\</span></span><br><span class="line"><span class="string">--config=/opt/kubernetes/cfg/kube-proxy-config.yml&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="2-配置参数文件-1"><a href="#2-配置参数文件-1" class="headerlink" title="2. 配置参数文件"></a>2. 配置参数文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /opt/kubernetes/cfg/kube-proxy-config.yml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">kind: KubeProxyConfiguration</span></span><br><span class="line"><span class="string">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span></span><br><span class="line"><span class="string">bindAddress: 0.0.0.0</span></span><br><span class="line"><span class="string">metricsBindAddress: 0.0.0.0:10249</span></span><br><span class="line"><span class="string">clientConnection:</span></span><br><span class="line"><span class="string">  kubeconfig: /opt/kubernetes/cfg/kube-proxy.kubeconfig</span></span><br><span class="line"><span class="string">hostnameOverride: k8s-master1</span></span><br><span class="line"><span class="string">clusterCIDR: 10.244.0.0/16</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="3-生成kube-proxy-kubeconfig文件"><a href="#3-生成kube-proxy-kubeconfig文件" class="headerlink" title="3. 生成kube-proxy.kubeconfig文件"></a>3. 生成kube-proxy.kubeconfig文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/TLS/k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建证书请求文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; kube-proxy-csr.json &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;system:kube-proxy&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;BeiJing&quot;,</span></span><br><span class="line"><span class="string">      &quot;O&quot;: &quot;k8s&quot;,</span></span><br><span class="line"><span class="string">      &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line">生成kubeconfig文件：</span><br><span class="line">KUBE_CONFIG=<span class="string">&quot;/opt/kubernetes/cfg/kube-proxy.kubeconfig&quot;</span></span><br><span class="line">KUBE_APISERVER=<span class="string">&quot;https://192.168.31.71:6443&quot;</span></span><br><span class="line"></span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-credentials kube-proxy \</span><br><span class="line">  --client-certificate=./kube-proxy.pem \</span><br><span class="line">  --client-key=./kube-proxy-key.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config set-context default \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kube-proxy \</span><br><span class="line">  --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br><span class="line">kubectl config use-context default --kubeconfig=<span class="variable">$&#123;KUBE_CONFIG&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-systemd管理kube-proxy"><a href="#4-systemd管理kube-proxy" class="headerlink" title="4. systemd管理kube-proxy"></a>4. systemd管理kube-proxy</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Kubernetes Proxy</span></span><br><span class="line"><span class="string">After=network.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">EnvironmentFile=/opt/kubernetes/cfg/kube-proxy.conf</span></span><br><span class="line"><span class="string">ExecStart=/opt/kubernetes/bin/kube-proxy \$KUBE_PROXY_OPTS</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">LimitNOFILE=65536</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="5-启动并设置开机启动-3"><a href="#5-启动并设置开机启动-3" class="headerlink" title="5. 启动并设置开机启动"></a>5. 启动并设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-proxy</span><br><span class="line">systemctl <span class="built_in">enable</span> kube-proxy</span><br></pre></td></tr></table></figure>

<h3 id="5-5-部署网络组件"><a href="#5-5-部署网络组件" class="headerlink" title="5.5 部署网络组件"></a>5.5 部署网络组件</h3><p>Calico是一个纯三层的数据中心网络方案，是目前Kubernetes主流的网络方案。</p>
<p>部署Calico：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f calico.yaml</span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>

<p>等Calico Pod都Running，节点也会准备就绪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready    &lt;none&gt;   37m   v1.22.4</span><br></pre></td></tr></table></figure>

<h3 id="5-6-授权apiserver访问kubelet"><a href="#5-6-授权apiserver访问kubelet" class="headerlink" title="5.6 授权apiserver访问kubelet"></a>5.6 授权apiserver访问kubelet</h3><p>应用场景：例如kubectl logs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; apiserver-to-kubelet-rbac.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: ClusterRole</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  annotations:</span></span><br><span class="line"><span class="string">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span></span><br><span class="line"><span class="string">  labels:</span></span><br><span class="line"><span class="string">    kubernetes.io/bootstrapping: rbac-defaults</span></span><br><span class="line"><span class="string">  name: system:kube-apiserver-to-kubelet</span></span><br><span class="line"><span class="string">rules:</span></span><br><span class="line"><span class="string">  - apiGroups:</span></span><br><span class="line"><span class="string">      - &quot;&quot;</span></span><br><span class="line"><span class="string">    resources:</span></span><br><span class="line"><span class="string">      - nodes/proxy</span></span><br><span class="line"><span class="string">      - nodes/stats</span></span><br><span class="line"><span class="string">      - nodes/log</span></span><br><span class="line"><span class="string">      - nodes/spec</span></span><br><span class="line"><span class="string">      - nodes/metrics</span></span><br><span class="line"><span class="string">      - pods/log</span></span><br><span class="line"><span class="string">    verbs:</span></span><br><span class="line"><span class="string">      - &quot;*&quot;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="string">kind: ClusterRoleBinding</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: system:kube-apiserver</span></span><br><span class="line"><span class="string">  namespace: &quot;&quot;</span></span><br><span class="line"><span class="string">roleRef:</span></span><br><span class="line"><span class="string">  apiGroup: rbac.authorization.k8s.io</span></span><br><span class="line"><span class="string">  kind: ClusterRole</span></span><br><span class="line"><span class="string">  name: system:kube-apiserver-to-kubelet</span></span><br><span class="line"><span class="string">subjects:</span></span><br><span class="line"><span class="string">  - apiGroup: rbac.authorization.k8s.io</span></span><br><span class="line"><span class="string">    kind: User</span></span><br><span class="line"><span class="string">    name: kubernetes</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f apiserver-to-kubelet-rbac.yaml</span><br></pre></td></tr></table></figure>

<h3 id="5-7-新增加Worker-Node"><a href="#5-7-新增加Worker-Node" class="headerlink" title="5.7 新增加Worker Node"></a>5.7 新增加Worker Node</h3><h4 id="1-拷贝已部署好的Node相关文件到新节点"><a href="#1-拷贝已部署好的Node相关文件到新节点" class="headerlink" title="1. 拷贝已部署好的Node相关文件到新节点"></a>1. 拷贝已部署好的Node相关文件到新节点</h4><p>在Master节点将Worker Node涉及文件拷贝到新节点192.168.31.72&#x2F;73</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /opt/kubernetes root@192.168.31.72:/opt/</span><br><span class="line"></span><br><span class="line">scp -r /usr/lib/systemd/system/&#123;kubelet,kube-proxy&#125;.service root@192.168.31.72:/usr/lib/systemd/system</span><br><span class="line"></span><br><span class="line">scp /opt/kubernetes/ssl/ca.pem root@192.168.31.72:/opt/kubernetes/ssl</span><br></pre></td></tr></table></figure>

<h4 id="2-删除kubelet证书和kubeconfig文件"><a href="#2-删除kubelet证书和kubeconfig文件" class="headerlink" title="2. 删除kubelet证书和kubeconfig文件"></a>2. 删除kubelet证书和kubeconfig文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /opt/kubernetes/cfg/kubelet.kubeconfig </span><br><span class="line"><span class="built_in">rm</span> -f /opt/kubernetes/ssl/kubelet*</span><br></pre></td></tr></table></figure>

<p>注：这几个文件是证书申请审批后自动生成的，每个Node不同，必须删除</p>
<h4 id="3-修改主机名"><a href="#3-修改主机名" class="headerlink" title="3. 修改主机名"></a>3. 修改主机名</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /opt/kubernetes/cfg/kubelet.conf</span><br><span class="line">--hostname-override=k8s-node1</span><br><span class="line"></span><br><span class="line">vi /opt/kubernetes/cfg/kube-proxy-config.yml</span><br><span class="line">hostnameOverride: k8s-node1</span><br></pre></td></tr></table></figure>

<h4 id="4-启动并设置开机启动-2"><a href="#4-启动并设置开机启动-2" class="headerlink" title="4. 启动并设置开机启动"></a>4. 启动并设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kubelet kube-proxy</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet kube-proxy</span><br></pre></td></tr></table></figure>

<h4 id="5-在Master上批准新Node-kubelet证书申请"><a href="#5-在Master上批准新Node-kubelet证书申请" class="headerlink" title="5. 在Master上批准新Node kubelet证书申请"></a>5. 在Master上批准新Node kubelet证书申请</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看证书请求</span></span><br><span class="line">kubectl get csr</span><br><span class="line">NAME           AGE   SIGNERNAME                    REQUESTOR           CONDITION</span><br><span class="line">node-csr-4zTjsaVSrhuyhIGqsefxzVoZDCNKei-aE2jyTP81Uro   89s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权请求</span></span><br><span class="line">kubectl certificate approve node-csr-4zTjsaVSrhuyhIGqsefxzVoZDCNKei-aE2jyTP81Uro</span><br></pre></td></tr></table></figure>

<h4 id="6-查看Node状态"><a href="#6-查看Node状态" class="headerlink" title="6. 查看Node状态"></a>6. 查看Node状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node</span><br><span class="line">NAME       STATUS   ROLES    AGE     VERSION</span><br><span class="line">k8s-master1   Ready    &lt;none&gt;   47m     v1.22.4</span><br><span class="line">k8s-node1    Ready    &lt;none&gt;   6m49s   v1.22.4</span><br></pre></td></tr></table></figure>

<p>Node2（192.168.31.73 ）节点同上。记得修改主机名！</p>
<h2 id="六、部署Dashboard和CoreDNS"><a href="#六、部署Dashboard和CoreDNS" class="headerlink" title="六、部署Dashboard和CoreDNS"></a>六、部署Dashboard和CoreDNS</h2><h3 id="6-1-部署Dashboard"><a href="#6-1-部署Dashboard" class="headerlink" title="6.1 部署Dashboard"></a>6.1 部署Dashboard</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f kubernetes-dashboard.yaml</span><br><span class="line"><span class="comment"># 查看部署</span></span><br><span class="line">kubectl get pods,svc -n kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>访问地址：<a href="https://nodeip:30001/">https://NodeIP:30001</a></p>
<p>创建service account并绑定默认cluster-admin管理员集群角色：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount dashboard-admin -n kube-system</span><br><span class="line">kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line">kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk <span class="string">&#x27;/dashboard-admin/&#123;print $1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用输出的token登录Dashboard。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202209051508149.png" alt="image-20220905150833928"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202209051508947.png" alt="image-20220905150845743"></p>
<h3 id="6-2-部署CoreDNS"><a href="#6-2-部署CoreDNS" class="headerlink" title="6.2 部署CoreDNS"></a>6.2 部署CoreDNS</h3><p>CoreDNS用于集群内部Service名称解析。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f coredns.yaml </span><br><span class="line"> </span><br><span class="line">kubectl get pods -n kube-system  </span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE </span><br><span class="line">coredns-5ffbfd976d-j6shb      1/1     Running   0          32s</span><br></pre></td></tr></table></figure>

<p>DNS解析测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl run -it --<span class="built_in">rm</span> dns-test --image=busybox:1.28.4 sh </span><br><span class="line">If you don<span class="string">&#x27;t see a command prompt, try pressing enter. </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/ # nslookup kubernetes </span></span><br><span class="line"><span class="string">Server:    10.0.0.2 </span></span><br><span class="line"><span class="string">Address 1: 10.0.0.2 kube-dns.kube-system.svc.cluster.local </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">Name:      kubernetes </span></span><br><span class="line"><span class="string">Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local</span></span><br></pre></td></tr></table></figure>

<p>解析没问题。</p>
<p>至此一个单Master集群就搭建完成了！这个环境就足以满足学习实验了，如果你的服务器配置较高，可继续扩容多Master集群！</p>
<h2 id="七、扩容多Master（高可用架构）"><a href="#七、扩容多Master（高可用架构）" class="headerlink" title="七、扩容多Master（高可用架构）"></a>七、扩容多Master（高可用架构）</h2><p>Kubernetes作为容器集群系统，通过健康检查+重启策略实现了Pod故障自我修复能力，通过调度算法实现将Pod分布式部署，并保持预期副本数，根据Node失效状态自动在其他Node拉起Pod，实现了应用层的高可用性。</p>
<p>针对Kubernetes集群，高可用性还应包含以下两个层面的考虑：Etcd数据库的高可用性和Kubernetes Master组件的高可用性。 而Etcd我们已经采用3个节点组建集群实现高可用，本节将对Master节点高可用进行说明和实施。</p>
<p>Master节点扮演着总控中心的角色，通过不断与工作节点上的Kubelet和kube-proxy进行通信来维护整个集群的健康工作状态。如果Master节点故障，将无法使用kubectl工具或者API做任何集群管理。</p>
<p>Master节点主要有三个服务kube-apiserver、kube-controller-manager和kube-scheduler，其中kube-controller-manager和kube-scheduler组件自身通过选择机制已经实现了高可用，所以Master高可用主要针对kube-apiserver组件，而该组件是以HTTP API提供服务，因此对他高可用与Web服务器类似，增加负载均衡器对其负载均衡即可，并且可水平扩容。</p>
<p>多Master架构图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202209051509415.png" alt="image-20220905150900095"></p>
<h3 id="7-1-部署Master2-Node"><a href="#7-1-部署Master2-Node" class="headerlink" title="7.1 部署Master2 Node"></a>7.1 部署Master2 Node</h3><p>现在需要再增加一台新服务器，作为Master2 Node，IP是192.168.31.74。</p>
<p>为了节省资源你也可以将之前部署好的Worker Node1复用为Master2 Node角色（即部署Master组件）</p>
<p>Master2 与已部署的Master1所有操作一致。所以我们只需将Master1所有K8s文件拷贝过来，再修改下服务器IP和主机名启动即可。</p>
<h4 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1. 安装Docker"></a>1. 安装Docker</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /usr/bin/docker* root@192.168.31.74:/usr/bin</span><br><span class="line">scp /usr/bin/runc root@192.168.31.74:/usr/bin</span><br><span class="line">scp /usr/bin/containerd* root@192.168.31.74:/usr/bin</span><br><span class="line">scp /usr/lib/systemd/system/docker.service root@192.168.31.74:/usr/lib/systemd/system</span><br><span class="line">scp -r /etc/docker root@192.168.31.74:/etc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Master2启动Docker</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<h4 id="2-创建etcd证书目录"><a href="#2-创建etcd证书目录" class="headerlink" title="2. 创建etcd证书目录"></a>2. 创建etcd证书目录</h4><p>在Master2创建etcd证书目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /opt/etcd/ssl</span><br></pre></td></tr></table></figure>

<h4 id="3-拷贝文件（Master1操作）"><a href="#3-拷贝文件（Master1操作）" class="headerlink" title="3. 拷贝文件（Master1操作）"></a>3. 拷贝文件（Master1操作）</h4><p>拷贝Master1上所有K8s文件和etcd证书到Master2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /opt/kubernetes root@192.168.31.74:/opt</span><br><span class="line">scp -r /opt/etcd/ssl root@192.168.31.74:/opt/etcd</span><br><span class="line">scp /usr/lib/systemd/system/kube* root@192.168.31.74:/usr/lib/systemd/system</span><br><span class="line">scp /usr/bin/kubectl  root@192.168.31.74:/usr/bin</span><br><span class="line">scp -r ~/.kube root@192.168.31.74:~</span><br></pre></td></tr></table></figure>

<h4 id="4-删除证书文件"><a href="#4-删除证书文件" class="headerlink" title="4. 删除证书文件"></a>4. 删除证书文件</h4><p>删除kubelet证书和kubeconfig文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /opt/kubernetes/cfg/kubelet.kubeconfig </span><br><span class="line"><span class="built_in">rm</span> -f /opt/kubernetes/ssl/kubelet*</span><br></pre></td></tr></table></figure>

<h4 id="5-修改配置文件IP和主机名"><a href="#5-修改配置文件IP和主机名" class="headerlink" title="5. 修改配置文件IP和主机名"></a>5. 修改配置文件IP和主机名</h4><p>修改apiserver、kubelet和kube-proxy配置文件为本地IP：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /opt/kubernetes/cfg/kube-apiserver.conf </span><br><span class="line">...</span><br><span class="line">--bind-address=192.168.31.74 \</span><br><span class="line">--advertise-address=192.168.31.74 \</span><br><span class="line">...</span><br><span class="line">vi /opt/kubernetes/cfg/kube-controller-manager.kubeconfig</span><br><span class="line">server: https://192.168.31.74:6443</span><br><span class="line"> </span><br><span class="line">vi /opt/kubernetes/cfg/kube-scheduler.kubeconfig</span><br><span class="line">server: https://192.168.31.74:6443</span><br><span class="line">vi /opt/kubernetes/cfg/kubelet.conf</span><br><span class="line">--hostname-override=k8s-master2</span><br><span class="line"></span><br><span class="line">vi /opt/kubernetes/cfg/kube-proxy-config.yml</span><br><span class="line">hostnameOverride: k8s-master2</span><br><span class="line"> </span><br><span class="line">vi ~/.kube/config</span><br><span class="line">...</span><br><span class="line">server: https://192.168.31.74:6443</span><br></pre></td></tr></table></figure>

<h4 id="6-启动设置开机启动"><a href="#6-启动设置开机启动" class="headerlink" title="6. 启动设置开机启动"></a>6. 启动设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-apiserver kube-controller-manager kube-scheduler kubelet kube-proxy</span><br><span class="line">systemctl <span class="built_in">enable</span> kube-apiserver kube-controller-manager kube-scheduler kubelet kube-proxy</span><br></pre></td></tr></table></figure>

<h4 id="7-查看集群状态-1"><a href="#7-查看集群状态-1" class="headerlink" title="7. 查看集群状态"></a>7. 查看集群状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get cs</span><br><span class="line">NAME                STATUS    MESSAGE             ERROR</span><br><span class="line">scheduler             Healthy   ok                  </span><br><span class="line">controller-manager       Healthy   ok                  </span><br><span class="line">etcd-1               Healthy   &#123;<span class="string">&quot;health&quot;</span>:<span class="string">&quot;true&quot;</span>&#125;   </span><br><span class="line">etcd-2               Healthy   &#123;<span class="string">&quot;health&quot;</span>:<span class="string">&quot;true&quot;</span>&#125;   </span><br><span class="line">etcd-0               Healthy   &#123;<span class="string">&quot;health&quot;</span>:<span class="string">&quot;true&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-批准kubelet证书申请"><a href="#8-批准kubelet证书申请" class="headerlink" title="8. 批准kubelet证书申请"></a>8. 批准kubelet证书申请</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看证书请求</span></span><br><span class="line">kubectl get csr</span><br><span class="line">NAME                      AGE          SIGNERNAME          REQUESTOR           CONDITION</span><br><span class="line">node-csr-JYNknakEa_YpHz797oKaN-ZTk43nD51Zc9CJkBLcASU   85m   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending</span><br><span class="line"><span class="comment"># 授权请求</span></span><br><span class="line">kubectl certificate approve node-csr-JYNknakEa_YpHz797oKaN-ZTk43nD51Zc9CJkBLcASU</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Node</span></span><br><span class="line">kubectl get node</span><br><span class="line">NAME        STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master1    Ready    &lt;none&gt;   34h   v1.22.4</span><br><span class="line">k8s-master2    Ready    &lt;none&gt;   2m   v1.22.4</span><br><span class="line">k8s-node1     Ready    &lt;none&gt;   33h   v1.22.4</span><br><span class="line">k8s-node2     Ready    &lt;none&gt;   33h   v1.22.4</span><br></pre></td></tr></table></figure>

<p>如果你在学习中遇到问题或者文档有误可联系阿良~ 微信: k8init</p>
<h3 id="7-2-部署Nginx-Keepalived高可用负载均衡器"><a href="#7-2-部署Nginx-Keepalived高可用负载均衡器" class="headerlink" title="7.2 部署Nginx+Keepalived高可用负载均衡器"></a>7.2 部署Nginx+Keepalived高可用负载均衡器</h3><p>kube-apiserver高可用架构图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/202209051509281.png" alt="image-20220905150918121"></p>
<p>•   Nginx是一个主流Web服务和反向代理服务器，这里用四层实现对apiserver实现负载均衡。</p>
<p>•   Keepalived是一个主流高可用软件，基于VIP绑定实现服务器双机热备，在上述拓扑中，Keepalived主要根据Nginx运行状态判断是否需要故障转移（漂移VIP），例如当Nginx主节点挂掉，VIP会自动绑定在Nginx备节点，从而保证VIP一直可用，实现Nginx高可用。</p>
<p>注1：为了节省机器，这里与K8s Master节点机器复用。也可以独立于k8s集群之外部署，只要nginx与apiserver能通信就行。</p>
<p>注2：如果你是在公有云上，一般都不支持keepalived，那么你可以直接用它们的负载均衡器产品，直接负载均衡多台Master kube-apiserver，架构与上面一样。</p>
<p>在两台Master节点操作。</p>
<h4 id="1-安装软件包（主-x2F-备）"><a href="#1-安装软件包（主-x2F-备）" class="headerlink" title="1. 安装软件包（主&#x2F;备）"></a>1. 安装软件包（主&#x2F;备）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install nginx keepalived -y</span><br></pre></td></tr></table></figure>

<h4 id="2-Nginx配置文件（主-x2F-备一样）"><a href="#2-Nginx配置文件（主-x2F-备一样）" class="headerlink" title="2. Nginx配置文件（主&#x2F;备一样）"></a>2. Nginx配置文件（主&#x2F;备一样）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/nginx/nginx.conf &lt;&lt; <span class="string">&quot;EOF&quot;</span></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 四层负载均衡，为两台Master apiserver组件提供负载均衡</span></span><br><span class="line">stream &#123;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr $upstream_addr - [$time_local] $status $upstream_bytes_sent&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/k8s-access.log  main;</span><br><span class="line"></span><br><span class="line">    upstream k8s-apiserver &#123;</span><br><span class="line">       server 192.168.31.71:6443;   <span class="comment"># Master1 APISERVER IP:PORT</span></span><br><span class="line">       server 192.168.31.74:6443;   <span class="comment"># Master2 APISERVER IP:PORT</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">       listen 16443; <span class="comment"># 由于nginx与master节点复用，这个监听端口不能是6443，否则会冲突</span></span><br><span class="line">       proxy_pass k8s-apiserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h4 id="3-keepalived配置文件（Nginx-Master）"><a href="#3-keepalived配置文件（Nginx-Master）" class="headerlink" title="3. keepalived配置文件（Nginx Master）"></a>3. keepalived配置文件（Nginx Master）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/keepalived/keepalived.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">global_defs &#123; </span></span><br><span class="line"><span class="string">   notification_email &#123; </span></span><br><span class="line"><span class="string">     acassen@firewall.loc </span></span><br><span class="line"><span class="string">     failover@firewall.loc </span></span><br><span class="line"><span class="string">     sysadmin@firewall.loc </span></span><br><span class="line"><span class="string">   &#125; </span></span><br><span class="line"><span class="string">   notification_email_from Alexandre.Cassen@firewall.loc  </span></span><br><span class="line"><span class="string">   smtp_server 127.0.0.1 </span></span><br><span class="line"><span class="string">   smtp_connect_timeout 30 </span></span><br><span class="line"><span class="string">   router_id NGINX_MASTER</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">vrrp_script check_nginx &#123;</span></span><br><span class="line"><span class="string">    script &quot;/etc/keepalived/check_nginx.sh&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">vrrp_instance VI_1 &#123; </span></span><br><span class="line"><span class="string">    state MASTER </span></span><br><span class="line"><span class="string">    interface ens33  # 修改为实际网卡名</span></span><br><span class="line"><span class="string">    virtual_router_id 51 # VRRP 路由 ID实例，每个实例是唯一的 </span></span><br><span class="line"><span class="string">    priority 100    # 优先级，备服务器设置 90 </span></span><br><span class="line"><span class="string">    advert_int 1    # 指定VRRP 心跳包通告间隔时间，默认1秒 </span></span><br><span class="line"><span class="string">    authentication &#123; </span></span><br><span class="line"><span class="string">        auth_type PASS      </span></span><br><span class="line"><span class="string">        auth_pass 1111 </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">    # 虚拟IP</span></span><br><span class="line"><span class="string">    virtual_ipaddress &#123; </span></span><br><span class="line"><span class="string">        192.168.31.88/24</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">    track_script &#123;</span></span><br><span class="line"><span class="string">        check_nginx</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>•   vrrp_script：指定检查nginx工作状态脚本（根据nginx状态判断是否故障转移）</p>
<p>•   virtual_ipaddress：虚拟IP（VIP）</p>
<p>准备上述配置文件中检查nginx运行状态的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/keepalived/check_nginx.sh  &lt;&lt; <span class="string">&quot;EOF&quot;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">count=$(ss -antp |grep 16443 |egrep -cv <span class="string">&quot;grep|$$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$count</span>&quot;</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">chmod</span> +x /etc/keepalived/check_nginx.sh</span><br></pre></td></tr></table></figure>

<h4 id="4-keepalived配置文件（Nginx-Backup）"><a href="#4-keepalived配置文件（Nginx-Backup）" class="headerlink" title="4. keepalived配置文件（Nginx Backup）"></a>4. keepalived配置文件（Nginx Backup）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/keepalived/keepalived.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">global_defs &#123; </span></span><br><span class="line"><span class="string">   notification_email &#123; </span></span><br><span class="line"><span class="string">     acassen@firewall.loc </span></span><br><span class="line"><span class="string">     failover@firewall.loc </span></span><br><span class="line"><span class="string">     sysadmin@firewall.loc </span></span><br><span class="line"><span class="string">   &#125; </span></span><br><span class="line"><span class="string">   notification_email_from Alexandre.Cassen@firewall.loc  </span></span><br><span class="line"><span class="string">   smtp_server 127.0.0.1 </span></span><br><span class="line"><span class="string">   smtp_connect_timeout 30 </span></span><br><span class="line"><span class="string">   router_id NGINX_BACKUP</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">vrrp_script check_nginx &#123;</span></span><br><span class="line"><span class="string">    script &quot;/etc/keepalived/check_nginx.sh&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">vrrp_instance VI_1 &#123; </span></span><br><span class="line"><span class="string">    state BACKUP </span></span><br><span class="line"><span class="string">    interface ens33</span></span><br><span class="line"><span class="string">    virtual_router_id 51 # VRRP 路由 ID实例，每个实例是唯一的 </span></span><br><span class="line"><span class="string">    priority 90</span></span><br><span class="line"><span class="string">    advert_int 1</span></span><br><span class="line"><span class="string">    authentication &#123; </span></span><br><span class="line"><span class="string">        auth_type PASS      </span></span><br><span class="line"><span class="string">        auth_pass 1111 </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">    virtual_ipaddress &#123; </span></span><br><span class="line"><span class="string">        192.168.31.88/24</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">    track_script &#123;</span></span><br><span class="line"><span class="string">        check_nginx</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>准备上述配置文件中检查nginx运行状态的脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/keepalived/check_nginx.sh  &lt;&lt; <span class="string">&quot;EOF&quot;</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">count=$(ss -antp |grep 16443 |egrep -cv <span class="string">&quot;grep|$$&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$count</span>&quot;</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">chmod</span> +x /etc/keepalived/check_nginx.sh</span><br></pre></td></tr></table></figure>

<p>注：keepalived根据脚本返回状态码（0为工作正常，非0不正常）判断是否故障转移。</p>
<h4 id="5-启动并设置开机启动-4"><a href="#5-启动并设置开机启动-4" class="headerlink" title="5. 启动并设置开机启动"></a>5. 启动并设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start nginx keepalived</span><br><span class="line">systemctl <span class="built_in">enable</span> nginx keepalived</span><br></pre></td></tr></table></figure>

<h4 id="6-查看keepalived工作状态"><a href="#6-查看keepalived工作状态" class="headerlink" title="6. 查看keepalived工作状态"></a>6. 查看keepalived工作状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:04:f7:2c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.31.80/24 brd 192.168.31.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 192.168.31.88/24 scope global secondary ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fe04:f72c/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>可以看到，在ens33网卡绑定了192.168.31.88 虚拟IP，说明工作正常。</p>
<h4 id="7-Nginx-Keepalived高可用测试"><a href="#7-Nginx-Keepalived高可用测试" class="headerlink" title="7. Nginx+Keepalived高可用测试"></a>7. Nginx+Keepalived高可用测试</h4><p>关闭主节点Nginx，测试VIP是否漂移到备节点服务器。</p>
<p>在Nginx Master执行 pkill nginx;<br>在Nginx Backup，ip addr命令查看已成功绑定VIP。</p>
<h4 id="8-访问负载均衡器测试"><a href="#8-访问负载均衡器测试" class="headerlink" title="8. 访问负载均衡器测试"></a>8. 访问负载均衡器测试</h4><p>找K8s集群中任意一个节点，使用curl查看K8s版本测试，使用VIP访问：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k https://192.168.31.88:16443/version</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;major&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;minor&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">  <span class="string">&quot;gitVersion&quot;</span>: <span class="string">&quot;v1.22.4&quot;</span>,</span><br><span class="line">  <span class="string">&quot;gitCommit&quot;</span>: <span class="string">&quot;e87da0bd6e03ec3fea7933c4b5263d151aafd07c&quot;</span>,</span><br><span class="line">  <span class="string">&quot;gitTreeState&quot;</span>: <span class="string">&quot;clean&quot;</span>,</span><br><span class="line">  <span class="string">&quot;buildDate&quot;</span>: <span class="string">&quot;2021-02-18T16:03:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;goVersion&quot;</span>: <span class="string">&quot;go1.15.8&quot;</span>,</span><br><span class="line">  <span class="string">&quot;compiler&quot;</span>: <span class="string">&quot;gc&quot;</span>,</span><br><span class="line">  <span class="string">&quot;platform&quot;</span>: <span class="string">&quot;linux/amd64&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以正确获取到K8s版本信息，说明负载均衡器搭建正常。该请求数据流程：curl -&gt; vip(nginx) -&gt; apiserver</p>
<p>通过查看Nginx日志也可以看到转发apiserver IP：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> /var/log/nginx/k8s-access.log -f</span><br><span class="line">192.168.31.71 192.168.31.71:6443 - [02/Apr/2021:19:17:57 +0800] 200 423</span><br><span class="line">192.168.31.71 192.168.31.72:6443 - [02/Apr/2021:19:18:50 +0800] 200 423</span><br></pre></td></tr></table></figure>

<p>到此还没结束，还有下面最关键的一步。</p>
<h3 id="7-3-修改所有Worker-Node连接LB-VIP"><a href="#7-3-修改所有Worker-Node连接LB-VIP" class="headerlink" title="7.3 修改所有Worker Node连接LB VIP"></a>7.3 修改所有Worker Node连接LB VIP</h3><p>试想下，虽然我们增加了Master2 Node和负载均衡器，但是我们是从单Master架构扩容的，也就是说目前所有的Worker Node组件连接都还是Master1 Node，如果不改为连接VIP走负载均衡器，那么Master还是单点故障。</p>
<p>因此接下来就是要改所有Worker Node（kubectl get node命令查看到的节点）组件配置文件，由原来192.168.31.71修改为192.168.31.88（VIP）。</p>
<p>在所有Worker Node执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s#192.168.31.71:6443#192.168.31.88:16443#&#x27;</span> /opt/kubernetes/cfg/*</span><br><span class="line">systemctl restart kubelet kube-proxy</span><br></pre></td></tr></table></figure>

<p>检查节点状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get node </span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION </span><br><span class="line">k8s-master1   Ready    &lt;none&gt;   32d   v1.22.4 </span><br><span class="line">k8s-master2   Ready    &lt;none&gt;   10m   v1.22.4 </span><br><span class="line">k8s-node1    Ready    &lt;none&gt;   31d   v1.22.4 </span><br><span class="line">k8s-node2    Ready    &lt;none&gt;   31d   v1.22.4</span><br></pre></td></tr></table></figure>

<p>至此，一套完整的 Kubernetes 高可用集群就部署完成了！</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes入门教程</title>
    <url>/2022/12/29/k8s%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第一章-kubernetes介绍"><a href="#第一章-kubernetes介绍" class="headerlink" title="第一章 kubernetes介绍"></a>第一章 kubernetes介绍</h1><p>本章节主要介绍应用程序在服务器上部署方式演变以及kubernetes的概念、组件和工作原理。</p>
<h2 id="应用部署方式演变"><a href="#应用部署方式演变" class="headerlink" title="应用部署方式演变"></a>应用部署方式演变</h2><p>在部署应用程序的方式上，主要经历了三个时代：</p>
<ul>
<li><p><strong>传统部署</strong>：互联网早期，会直接将应用程序部署在物理机上</p>
<blockquote>
<p>优点：简单，不需要其它技术的参与</p>
<p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p>
</blockquote>
</li>
<li><p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p>
<blockquote>
<p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p>
<p>缺点：增加了操作系统，浪费了部分资源</p>
</blockquote>
</li>
<li><p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p>
<blockquote>
<p>优点：</p>
<p>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p>
<p>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p>
<p>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200505183738289.png" alt="image-20200505183738289"></p>
<p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p>
<ul>
<li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li>
<li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li>
</ul>
<p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p>
<ul>
<li><strong>Swarm</strong>：Docker自己的容器编排工具</li>
<li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li>
<li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200524150339551.png" alt="image-20200524150339551" style />

<h2 id="kubernetes简介"><a href="#kubernetes简介" class="headerlink" title="kubernetes简介"></a>kubernetes简介</h2><p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200406232838722.png" alt="image-20200406232838722"></p>
<p>​</p>
<pre><code>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器----Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。

kubernetes的本质是**一组服务器集群**，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：
</code></pre>
<ul>
<li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li>
<li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li>
<li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li>
<li><strong>负载均衡</strong>：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li>
<li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li>
<li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200526203726071.png" alt="image-20200526203726071"></p>
<h2 id="kubernetes组件"><a href="#kubernetes组件" class="headerlink" title="kubernetes组件"></a>kubernetes组件</h2><p>一个kubernetes集群主要是由**控制节点(master)**、**工作节点(node)**构成，每个节点上都会安装不同的组件。</p>
<p><strong>master：集群的控制平面，负责集群的决策  (  管理  )</strong></p>
<blockquote>
<p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p>
<p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p>
<p><strong>ControllerManager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p>
<p>**Etcd **：负责存储集群中各种资源对象的信息</p>
</blockquote>
<p>**node：集群的数据平面，负责为容器提供运行环境 ( 干活 ) **</p>
<blockquote>
<p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p>
<p><strong>KubeProxy</strong> : 负责提供集群内部的服务发现和负载均衡</p>
<p><strong>Docker</strong> : 负责节点上容器的各种操作</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200406184656917.png" alt="image-20200406184656917"></p>
<p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p>
<ol>
<li><p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</p>
</li>
<li><p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</p>
</li>
<li><p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上</p>
<p>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</p>
</li>
<li><p>apiServer调用controller-manager去调度Node节点安装nginx服务</p>
</li>
<li><p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod</p>
<p>pod是kubernetes的最小操作单元，容器必须跑在pod中至此，</p>
</li>
<li><p>一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理</p>
<pre><code>这样，外界用户就可以访问集群中的nginx服务了
</code></pre>
</li>
</ol>
<h2 id="kubernetes概念"><a href="#kubernetes概念" class="headerlink" title="kubernetes概念"></a>kubernetes概念</h2><p><strong>Master</strong>：集群控制节点，每个集群需要至少一个master节点负责集群的管控</p>
<p><strong>Node</strong>：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p>
<p><strong>Pod</strong>：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p>
<p><strong>Controller</strong>：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p>
<p><strong>Service</strong>：pod对外服务的统一入口，下面可以维护者同一类的多个pod</p>
<p><strong>Label</strong>：标签，用于对pod进行分类，同一类pod会拥有相同的标签</p>
<p><strong>NameSpace</strong>：命名空间，用来隔离pod的运行环境</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200403224313355.png" alt="image-20200403224313355"></p>
<h1 id="第二章-集群环境搭建"><a href="#第二章-集群环境搭建" class="headerlink" title="第二章 集群环境搭建"></a>第二章 集群环境搭建</h1><p>本章节主要介绍如何搭建kubernetes的集群环境</p>
<h2 id="环境规划"><a href="#环境规划" class="headerlink" title="环境规划"></a>环境规划</h2><h3 id="集群类型"><a href="#集群类型" class="headerlink" title="集群类型"></a>集群类型</h3><p>kubernetes集群大体上分为两类：<strong>一主多从</strong>和<strong>多主多从</strong>。</p>
<ul>
<li>一主多从：一台Master节点和多台Node节点，搭建简单，但是有单机故障风险，适合用于测试环境</li>
<li>多主多从：多台Master节点和多台Node节点，搭建麻烦，安全性高，适合用于生产环境</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200404094800622.png" alt="image-20200404094800622"></p>
<blockquote>
<p><code>说明：为了测试简单，本次搭建的是  一主两从   类型的集群</code></p>
</blockquote>
<h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>kubernetes有多种部署方式，目前主流的方式有kubeadm、minikube、二进制包</p>
<ul>
<li>minikube：一个用于快速搭建单节点kubernetes的工具</li>
<li>kubeadm：一个用于快速搭建kubernetes集群的工具</li>
<li>二进制包 ：从官网下载每个组件的二进制包，依次去安装，此方式对于理解kubernetes组件更加有效</li>
</ul>
<blockquote>
<p><code>说明：现在需要安装kubernetes的集群环境，但是又不想过于麻烦，所以选择使用kubeadm方式</code></p>
</blockquote>
<h3 id="主机规划"><a href="#主机规划" class="headerlink" title="主机规划"></a>主机规划</h3><table>
<thead>
<tr>
<th>作用</th>
<th>IP地址</th>
<th>操作系统</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>Master</td>
<td>192.168.109.101</td>
<td>Centos7.5    基础设施服务器</td>
<td>2颗CPU  2G内存   50G硬盘</td>
</tr>
<tr>
<td>Node1</td>
<td>192.168.109.102</td>
<td>Centos7.5    基础设施服务器</td>
<td>2颗CPU  2G内存   50G硬盘</td>
</tr>
<tr>
<td>Node2</td>
<td>192.168.109.103</td>
<td>Centos7.5    基础设施服务器</td>
<td>2颗CPU  2G内存   50G硬盘</td>
</tr>
</tbody></table>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><pre><code>本次环境搭建需要安装三台Centos服务器（一主二从），然后在每台服务器中分别安装docker（18.06.3），kubeadm（1.17.4）、kubelet（1.17.4）、kubectl（1.17.4）程序。
</code></pre>
<h3 id="主机安装"><a href="#主机安装" class="headerlink" title="主机安装"></a>主机安装</h3><p>安装虚拟机过程中注意下面选项的设置：</p>
<ul>
<li><p>操作系统环境：CPU（2C）    内存（2G）   硬盘（50G）</p>
</li>
<li><p>语言选择：中文简体</p>
</li>
<li><p>软件选择：基础设施服务器</p>
</li>
<li><p>分区选择：自动分区</p>
</li>
<li><p>网络配置：按照下面配置网路地址信息</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">网络地址：192.168.109.100  （每台主机都不一样  分别为100、101、102）</span><br><span class="line">子网掩码：255.255.255.0</span><br><span class="line">默认网关：192.168.109.2</span><br><span class="line">DNS：    223.5.5.5</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200505213817934.png" alt="image-20200505213817934"></p>
</li>
<li><p>主机名设置：按照下面信息设置主机名</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">master节点： master</span><br><span class="line">node节点：   node1</span><br><span class="line">node节点：   node2</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200505214156148.png" alt="image-20200505214156148"></p>
</li>
</ul>
<h3 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h3><ol>
<li>检查操作系统的版本</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此方式下安装kubernetes集群要求Centos版本要在7.5或之上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">CentOS Linux release <span class="number">7.5</span>.<span class="number">1804</span> (Core)</span><br></pre></td></tr></table></figure>

<p>2） 主机名解析</p>
<p>为了方便后面集群节点间的直接调用，在这配置一下主机名解析，企业中推荐使用内部DNS服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机名成解析 编辑三台服务器的/etc/hosts文件，添加下面内容</span></span><br><span class="line"><span class="number">192.168</span>.<span class="number">109.100</span>  master</span><br><span class="line"><span class="number">192.168</span>.<span class="number">109.101</span>  node1</span><br><span class="line"><span class="number">192.168</span>.<span class="number">109.102</span>  node2</span><br></pre></td></tr></table></figure>

<p>3） 时间同步</p>
<p>kubernetes要求集群中的节点时间必须精确一致，这里直接使用chronyd服务从网络同步时间。</p>
<p>企业中建议配置内部的时间同步服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动chronyd服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl start chronyd</span></span><br><span class="line"><span class="comment"># 设置chronyd服务开机自启</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable chronyd</span></span><br><span class="line"><span class="comment"># chronyd服务启动稍等几秒钟，就可以使用date命令验证时间了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># date</span></span><br></pre></td></tr></table></figure>

<p>4） 禁用iptables和firewalld服务</p>
<p>kubernetes和docker在运行中会产生大量的iptables规则，为了不让系统规则跟它们混淆，直接关闭系统的规则</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 关闭firewalld服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line"><span class="comment"># 2 关闭iptables服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl stop iptables</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl disable iptables</span></span><br></pre></td></tr></table></figure>

<p>5） 禁用selinux</p>
<p>selinux是linux系统下的一个安全服务，如果不关闭它，在安装集群中会产生各种各样的奇葩问题</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 /etc/selinux/config 文件，修改SELINUX的值为disabled</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<p>6） 禁用swap分区</p>
<p>swap分区指的是虚拟内存分区，它的作用是在物理内存使用完之后，将磁盘空间虚拟成内存来使用</p>
<p>启用swap设备会对系统的性能产生非常负面的影响，因此kubernetes要求每个节点都要禁用swap设备</p>
<p>但是如果因为某些原因确实不能关闭swap分区，就需要在集群安装过程中通过明确的参数进行配置说明</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑分区配置文件/etc/fstab，注释掉swap分区一行</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line"> UUID=<span class="number">455</span>cc753<span class="literal">-7a60-4c17-a424-7741728c44a1</span> /boot    xfs     defaults        <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> /dev/mapper/centos<span class="literal">-home</span> /home                      xfs     defaults        <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># /dev/mapper/centos-swap swap                      swap    defaults        0 0</span></span><br></pre></td></tr></table></figure>

<p>7）修改linux的内核参数</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改linux的内核参数，添加网桥过滤和地址转发功能</span></span><br><span class="line"><span class="comment"># 编辑/etc/sysctl.d/kubernetes.conf文件，添加如下配置:</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf-call-ip6tables</span> = <span class="number">1</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf-call-iptables</span> = <span class="number">1</span></span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sysctl -p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载网桥过滤模块</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># modprobe br_netfilter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网桥过滤模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># lsmod | grep br_netfilter</span></span><br></pre></td></tr></table></figure>

<p>8）配置ipvs功能</p>
<p>在kubernetes中service有两种代理模型，一种是基于iptables的，一种是基于ipvs的</p>
<p>两者比较的话，ipvs的性能明显要高一些，但是如果要使用它，需要手动载入ipvs模块</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 安装ipset和ipvsadm</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install ipset ipvsadmin -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 添加需要加载的模块写入脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat &lt;&lt;EOF &gt;  /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">modprobe <span class="literal">--</span> ip_vs</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_rr</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_wrr</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_sh</span><br><span class="line">modprobe <span class="literal">--</span> nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 为脚本文件添加执行权限</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># chmod +x /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 执行脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># /bin/bash /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 查看对应的模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span></span><br></pre></td></tr></table></figure>

<p>9） 重启服务器</p>
<p>上面步骤完成之后，需要重新启动linux系统</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure>

<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 切换镜像源</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 查看当前镜像源中支持的docker版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum list docker-ce --showduplicates</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 安装特定版本的docker-ce</span></span><br><span class="line"><span class="comment"># 必须指定--setopt=obsoletes=0，否则yum会自动安装更高版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 添加一个配置文件</span></span><br><span class="line"><span class="comment"># Docker在默认情况下使用的Cgroup Driver为cgroupfs，而kubernetes推荐使用systemd来代替cgroupfs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir /etc/docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat &lt;&lt;EOF &gt;  /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 启动docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable docker</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 检查docker状态和版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># docker version</span></span><br></pre></td></tr></table></figure>

<h3 id="安装kubernetes组件"><a href="#安装kubernetes组件" class="headerlink" title="安装kubernetes组件"></a>安装kubernetes组件</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于kubernetes的镜像源在国外，速度比较慢，这里切换成国内的镜像源</span></span><br><span class="line"><span class="comment"># 编辑/etc/yum.repos.d/kubernetes.repo，添加下面的配置 </span></span><br><span class="line">[<span class="type">kubernetes</span>]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes<span class="literal">-el7-x86_64</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">0</span></span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum<span class="literal">-key</span>.gpg</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm<span class="literal">-package-key</span>.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装kubeadm、kubelet和kubectl</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 kubeadm-1.17.4-0 kubelet-1.17.4-0 kubectl-1.17.4-0 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置kubelet的cgroup</span></span><br><span class="line"><span class="comment"># 编辑/etc/sysconfig/kubelet，添加下面的配置</span></span><br><span class="line">KUBELET_CGROUP_ARGS=<span class="string">&quot;--cgroup-driver=systemd&quot;</span></span><br><span class="line">KUBE_PROXY_MODE=<span class="string">&quot;ipvs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 设置kubelet开机自启</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable kubelet</span></span><br></pre></td></tr></table></figure>

<h3 id="准备集群镜像"><a href="#准备集群镜像" class="headerlink" title="准备集群镜像"></a>准备集群镜像</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在安装kubernetes集群之前，必须要提前准备好集群需要的镜像，所需镜像可以通过下面命令查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm config images list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line"><span class="comment"># 此镜像在kubernetes的仓库中,由于网络原因,无法连接，下面提供了一种替代方案</span></span><br><span class="line">images=(</span><br><span class="line">    kube<span class="literal">-apiserver</span>:v1.<span class="number">17.4</span></span><br><span class="line">    kube<span class="literal">-controller-manager</span>:v1.<span class="number">17.4</span></span><br><span class="line">    kube<span class="literal">-scheduler</span>:v1.<span class="number">17.4</span></span><br><span class="line">    kube<span class="literal">-proxy</span>:v1.<span class="number">17.4</span></span><br><span class="line">    pause:<span class="number">3.1</span></span><br><span class="line">    etcd:<span class="number">3.4</span>.<span class="number">3</span><span class="literal">-0</span></span><br><span class="line">    coredns:<span class="number">1.6</span>.<span class="number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$</span>&#123;images[<span class="selector-tag">@</span>]&#125; ; <span class="keyword">do</span></span><br><span class="line">	docker pull registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">	docker tag registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span> 		k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line">	docker rmi registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="集群初始化"><a href="#集群初始化" class="headerlink" title="集群初始化"></a>集群初始化</h3><p>下面开始对集群进行初始化，并将node节点加入到集群中</p>
<blockquote>
<p>下面的操作只需要在<code>master</code>节点上执行即可</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建集群</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm init \</span></span><br><span class="line">	<span class="literal">--kubernetes-version</span>=v1.<span class="number">17.4</span> \</span><br><span class="line">    <span class="literal">--pod-network-cidr</span>=<span class="number">10.244</span>.<span class="number">0.0</span>/<span class="number">16</span> \</span><br><span class="line">    <span class="literal">--service-cidr</span>=<span class="number">10.96</span>.<span class="number">0.0</span>/<span class="number">12</span> \</span><br><span class="line">    <span class="literal">--apiserver-advertise-address</span>=<span class="number">192.168</span>.<span class="number">109.100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建必要文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir -p $HOME/.kube</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sudo chown $(id -u):$(id -g) $HOME/.kube/config</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面的操作只需要在<code>node</code>节点上执行即可</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将node节点加入集群</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm join 192.168.109.100:6443 \ </span></span><br><span class="line">	<span class="literal">--token</span> <span class="number">8507</span>uc.o0knircuri8etnw2 \</span><br><span class="line">	<span class="literal">--discovery-token-ca-cert-hash</span> \</span><br><span class="line">	sha256:acc37967fb5b0acf39d7598f8a439cc7dc88f439a3f4d0c9cae88e7901b9d3f</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 查看集群状态 此时的集群状态为NotReady，这是因为还没有配置网络插件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME     STATUS     ROLES    AGE     VERSION</span><br><span class="line">master   NotReady   master   <span class="number">6</span>m43s   v1.<span class="number">17.4</span></span><br><span class="line">node1    NotReady   &lt;none&gt;   <span class="number">22</span>s     v1.<span class="number">17.4</span></span><br><span class="line">node2    NotReady   &lt;none&gt;   <span class="number">19</span>s     v1.<span class="number">17.4</span></span><br></pre></td></tr></table></figure>

<h3 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h3><p>kubernetes支持多种网络插件，比如flannel、calico、canal等等，任选一种使用即可，本次选择flannel</p>
<blockquote>
<p>下面操作依旧只在<code>master</code>节点执行即可，插件使用的是DaemonSet的控制器，它会在每个节点上都运行</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取fannel的配置文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件中quay.io仓库为quay-mirror.qiniu.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置文件启动fannel</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl apply -f kube-flannel.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 稍等片刻，再次查看集群节点的状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME     STATUS   ROLES    AGE     VERSION</span><br><span class="line">master   Ready    master   <span class="number">15</span>m     v1.<span class="number">17.4</span></span><br><span class="line">node1    Ready    &lt;none&gt;   <span class="number">8</span>m53s   v1.<span class="number">17.4</span></span><br><span class="line">node2    Ready    &lt;none&gt;   <span class="number">8</span>m50s   v1.<span class="number">17.4</span></span><br></pre></td></tr></table></figure>

<p>至此，kubernetes的集群环境搭建完成</p>
<h2 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h2><p>接下来在kubernetes集群中部署一个nginx程序，测试下集群是否在正常工作。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create deployment nginx --image=nginx:1.14-alpine</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl expose deployment nginx --port=80 --type=NodePort</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods,service</span></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx<span class="literal">-86c57db685-fdc2k</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span>m</span><br><span class="line"></span><br><span class="line">NAME                 <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>      EXTERNAL<span class="literal">-IP</span>   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   <span class="number">10.96</span>.<span class="number">0.1</span>       &lt;none&gt;        <span class="number">443</span>/TCP        <span class="number">82</span>m</span><br><span class="line">service/nginx        NodePort    <span class="number">10.104</span>.<span class="number">121.45</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">30073</span>/TCP   <span class="number">17</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 最后在电脑上访问下部署的nginx服务</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200405142656921.png" alt="image-20200405142656921"></p>
<h1 id="第三章-资源管理"><a href="#第三章-资源管理" class="headerlink" title="第三章 资源管理"></a>第三章 资源管理</h1><p>本章节主要介绍yaml语法和kubernetes的资源管理方式</p>
<h2 id="资源管理介绍"><a href="#资源管理介绍" class="headerlink" title="资源管理介绍"></a>资源管理介绍</h2><p>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。</p>
<blockquote>
<p>kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</p>
<p>kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在<code>Pod</code>中，而kubernetes一般也不会直接管理Pod，而是通过<code>Pod控制器</code>来管理Pod的。</p>
<p>Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了<code>Service</code>资源实现这个功能。</p>
<p>当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种<code>存储</code>系统。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200406225334627.png" alt="image-20200406225334627"></p>
<blockquote>
<p>学习kubernetes的核心，就是学习如何对集群上的<code>Pod、Pod控制器、Service、存储</code>等各种资源进行操作</p>
</blockquote>
<h2 id="YAML语言介绍"><a href="#YAML语言介绍" class="headerlink" title="YAML语言介绍"></a>YAML语言介绍</h2><pre><code>YAML是一个类似 XML、JSON 的标记性语言。它强调以**数据**为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称&quot;一种人性化的数据格式语言&quot;。
</code></pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">heima</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">age</span>&gt;</span>15<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span>Beijing<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">heima</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">heima:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">Beijing</span></span><br></pre></td></tr></table></figure>

<p>YAML的语法比较简单，主要有下面几个：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格( 低版本限制 )</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
</ul>
<p>YAML支持以下几种数据类型：</p>
<ul>
<li>纯量：单个的、不可再分的值</li>
<li>对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hash） &#x2F; 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期</span></span><br><span class="line"><span class="comment"># 1 布尔类型</span></span><br><span class="line"><span class="attr">c1:</span> <span class="literal">true</span> <span class="string">(或者True)</span></span><br><span class="line"><span class="comment"># 2 整型</span></span><br><span class="line"><span class="attr">c2:</span> <span class="number">234</span></span><br><span class="line"><span class="comment"># 3 浮点型</span></span><br><span class="line"><span class="attr">c3:</span> <span class="number">3.14</span></span><br><span class="line"><span class="comment"># 4 null类型 </span></span><br><span class="line"><span class="attr">c4:</span> <span class="string">~</span>  <span class="comment"># 使用~表示null</span></span><br><span class="line"><span class="comment"># 5 日期类型</span></span><br><span class="line"><span class="attr">c5:</span> <span class="number">2018-02-17</span>    <span class="comment"># 日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line"><span class="comment"># 6 时间类型</span></span><br><span class="line"><span class="attr">c6:</span> <span class="number">2018-02-17T15:02:31+08:00</span>  <span class="comment"># 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br><span class="line"><span class="comment"># 7 字符串类型</span></span><br><span class="line"><span class="attr">c7:</span> <span class="string">heima</span>     <span class="comment"># 简单写法，直接写值 , 如果字符串中间有特殊字符，必须使用双引号或者单引号包裹 </span></span><br><span class="line"><span class="attr">c8:</span> <span class="string">line1</span></span><br><span class="line">    <span class="string">line2</span>     <span class="comment"># 字符串过多的情况可以拆成多行，每一行会被转化成一个空格</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="comment"># 形式一(推荐):</span></span><br><span class="line"><span class="attr">heima:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">Beijing</span></span><br><span class="line"><span class="comment"># 形式二(了解):</span></span><br><span class="line"><span class="attr">heima:</span> &#123;<span class="attr">age:</span> <span class="number">15</span>,<span class="attr">address:</span> <span class="string">Beijing</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="comment"># 形式一(推荐):</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">顺义</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">昌平</span>	</span><br><span class="line"><span class="comment"># 形式二(了解):</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">顺义</span>,<span class="string">昌平</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小提示：</p>
<p>1  书写yaml切记<code>:</code> 后面要加一个空格</p>
<p>2  如果需要将多段yaml配置放在一个文件中，中间要使用<code>---</code>分隔</p>
<p>3 下面是一个yaml转json的网站，可以通过它验证yaml是否书写正确</p>
<p><a href="https://www.json2yaml.com/convert-yaml-to-json">https://www.json2yaml.com/convert-yaml-to-json</a></p>
</blockquote>
<h2 id="资源管理方式"><a href="#资源管理方式" class="headerlink" title="资源管理方式"></a>资源管理方式</h2><ul>
<li><p>命令式对象管理：直接使用命令去操作kubernetes资源</p>
<p><code>kubectl run nginx-pod --image=nginx:1.17.1 --port=80</code></p>
</li>
<li><p>命令式对象配置：通过命令配置和配置文件去操作kubernetes资源</p>
<p><code>kubectl create/patch -f nginx-pod.yaml</code></p>
</li>
<li><p>声明式对象配置：通过apply命令和配置文件去操作kubernetes资源</p>
<p><code>kubectl apply -f nginx-pod.yaml</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>操作对象</th>
<th>适用环境</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>命令式对象管理</td>
<td>对象</td>
<td>测试</td>
<td>简单</td>
<td>只能操作活动对象，无法审计、跟踪</td>
</tr>
<tr>
<td>命令式对象配置</td>
<td>文件</td>
<td>开发</td>
<td>可以审计、跟踪</td>
<td>项目大时，配置文件多，操作麻烦</td>
</tr>
<tr>
<td>声明式对象配置</td>
<td>目录</td>
<td>开发</td>
<td>支持目录操作</td>
<td>意外情况下难以调试</td>
</tr>
</tbody></table>
<h3 id="命令式对象管理"><a href="#命令式对象管理" class="headerlink" title="命令式对象管理"></a>命令式对象管理</h3><p><strong>kubectl命令</strong></p>
<p><code>kubectl</code>是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">kubectl [command] [type] [name] [flags]</span><br></pre></td></tr></table></figure>

<p><strong>comand</strong>：指定要对资源执行的操作，例如create、get、delete</p>
<p><strong>type</strong>：指定资源类型，比如deployment、pod、service</p>
<p><strong>name</strong>：指定资源的名称，名称大小写敏感</p>
<p><strong>flags</strong>：指定额外的可选参数</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有pod</span></span><br><span class="line">kubectl get pod </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个pod</span></span><br><span class="line">kubectl get pod pod_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个pod,以yaml格式展示结果</span></span><br><span class="line">kubectl get pod pod_name <span class="literal">-o</span> yaml</span><br></pre></td></tr></table></figure>

<p><strong>资源类型</strong></p>
<p><code>kubernetes</code>中所有的内容都抽象为资源，可以通过下面的命令进行查看:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl api<span class="literal">-resources</span></span><br></pre></td></tr></table></figure>

<p>经常使用的资源有下面这些：</p>
<table>
    <tr>
        <th>资源分类</th>
        <th>资源名称</th>
        <th>缩写</th>
        <th>资源作用</th>
    </tr>
    <tr>
        <td rowspan="2">集群级别资源</td>
        <td>nodes</td>
        <td>no</td>
        <td>集群组成部分</td>
    </tr>
    <tr>
        <td>namespaces</td>
        <td>ns</td>
        <td>隔离Pod</td>
    </tr>
    <tr>
        <td>pod资源</td>
        <td>pods</td>
        <td>po</td>
        <td>装载容器</td>
    </tr>
    <tr>
        <td rowspan="8">pod资源控制器</td>
        <td>replicationcontrollers</td>
        <td>rc</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td>replicasets</td>
        <td>rs</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td>deployments</td>
        <td>deploy</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td>daemonsets</td>
        <td>ds</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td>jobs</td>
        <td></td>
        <td>控制pod资源</td>
    </tr>	
    <tr>
        <td>cronjobs</td>
        <td>cj</td>
        <td>控制pod资源</td>
    </tr>	
    <tr>
        <td>horizontalpodautoscalers</td>
        <td>hpa</td>
        <td>控制pod资源</td>
    </tr>	
    <tr>
        <td>statefulsets</td>
        <td>sts</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td rowspan="2">服务发现资源</td>
        <td>services</td>
        <td>svc</td>
        <td>统一pod对外接口</td>
    </tr>
    <tr>
        <td>ingress</td>
        <td>ing</td>
        <td>统一pod对外接口</td>
    </tr>
    <tr>
        <td rowspan="3">存储资源</td>
        <td>volumeattachments</td>
        <td></td>
        <td>存储</td>
    </tr>
    <tr>
        <td>persistentvolumes</td>
        <td>pv</td>
        <td>存储</td>
    </tr>
    <tr>
        <td>persistentvolumeclaims</td>
        <td>pvc</td>
        <td>存储</td>
    </tr>
    <tr>
        <td rowspan="2">配置资源</td>
        <td>configmaps</td>
        <td>cm</td>
        <td>配置</td>
    </tr>
    <tr>
        <td>secrets</td>
        <td></td>
        <td>配置</td>
    </tr>
</table>

<p><strong>操作</strong></p>
<p><code>kubernetes</code>允许对资源进行多种操作，可以通过<code>--help</code>查看详细的操作命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl <span class="literal">--help</span></span><br></pre></td></tr></table></figure>

<p>经常使用的操作有下面这些：</p>
<table>
    <tr>
        <th>命令分类</th>
        <th>命令</th>
        <th>翻译</th>
        <th>命令作用</th>
    </tr>
    <tr>
        <td rowspan="6">基本命令</td>
        <td>create</td>
        <td>创建</td>
        <td>创建一个资源</td>
    </tr>
    <tr>
        <td>edit</td>
        <td>编辑</td>
        <td>编辑一个资源</td>
    </tr>
    <tr>
        <td>get</td>
        <td>获取</td>
        <td>获取一个资源</td>
    </tr>
   <tr>
        <td>patch</td>
        <td>更新</td>
        <td>更新一个资源</td>
    </tr>
    <tr>
        <td>delete</td>
        <td>删除</td>
        <td>删除一个资源</td>
    </tr>
    <tr>
        <td>explain</td>
        <td>解释</td>
        <td>展示资源文档</td>
    </tr>
    <tr>
        <td rowspan="10">运行和调试</td>
        <td>run</td>
        <td>运行</td>
        <td>在集群中运行一个指定的镜像</td>
    </tr>
    <tr>
        <td>expose</td>
        <td>暴露</td>
        <td>暴露资源为Service</td>
    </tr>
    <tr>
        <td>describe</td>
        <td>描述</td>
        <td>显示资源内部信息</td>
    </tr>
    <tr>
        <td>logs</td>
        <td>日志</td>
        <td>输出容器在 pod 中的日志</td>
    </tr>	
    <tr>
        <td>attach</td>
        <td>缠绕</td>
        <td>进入运行中的容器</td>
    </tr>	
    <tr>
        <td>exec</td>
        <td>执行</td>
        <td>执行容器中的一个命令</td>
    </tr>	
    <tr>
        <td>cp</td>
        <td>复制</td>
        <td>在Pod内外复制文件</td>
    </tr>
        <tr>
        <td>rollout</td>
        <td>首次展示</td>
        <td>管理资源的发布</td>
    </tr>
    <tr>
        <td>scale</td>
        <td>规模</td>
        <td>扩(缩)容Pod的数量</td>
    </tr>
    <tr>
        <td>autoscale</td>
        <td>自动调整</td>
        <td>自动调整Pod的数量</td>
    </tr>
    <tr>
        <td rowspan="2">高级命令</td>
        <td>apply</td>
        <td>rc</td>
        <td>通过文件对资源进行配置</td>
    </tr>
    <tr>
        <td>label</td>
        <td>标签</td>
        <td>更新资源上的标签</td>
    </tr>
    <tr>
        <td rowspan="2">其他命令</td>
        <td>cluster-info</td>
        <td>集群信息</td>
        <td>显示集群信息</td>
    </tr>
    <tr>
        <td>version</td>
        <td>版本</td>
        <td>显示当前Server和Client的版本</td>
    </tr>
</table>

<p>下面以一个namespace &#x2F; pod的创建和删除简单演示下命令的使用：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create namespace dev</span></span><br><span class="line">namespace/dev created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   <span class="number">21</span><span class="built_in">h</span></span><br><span class="line">dev               Active   <span class="number">21</span>s</span><br><span class="line">kube<span class="literal">-node-lease</span>   Active   <span class="number">21</span><span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-public</span>       Active   <span class="number">21</span><span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>       Active   <span class="number">21</span><span class="built_in">h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在此namespace下创建并运行一个nginx的Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run pod --image=nginx -n dev</span></span><br><span class="line">kubectl run <span class="literal">--generator</span>=deployment/apps.v1 is DEPRECATED and will be removed <span class="keyword">in</span> a future version. Use kubectl run <span class="literal">--generator</span>=run<span class="literal">-pod</span>/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/pod created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新创建的pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev</span></span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-864f9875b9-pcw7x</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">21</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete pod pod-864f9875b9-pcw7x</span></span><br><span class="line">pod <span class="string">&quot;pod-864f9875b9-pcw7x&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete ns dev</span></span><br><span class="line">namespace <span class="string">&quot;dev&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h3 id="命令式对象配置"><a href="#命令式对象配置" class="headerlink" title="命令式对象配置"></a>命令式对象配置</h3><p>命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源。</p>
<p>1） 创建一个nginxpod.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginxpod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-containers</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<p>2）执行create命令，创建资源：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f nginxpod.yaml</span></span><br><span class="line">namespace/dev created</span><br><span class="line">pod/nginxpod created</span><br></pre></td></tr></table></figure>

<p>此时发现创建了两个资源对象，分别是namespace和pod</p>
<p>3）执行get命令，查看资源：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get -f nginxpod.yaml</span></span><br><span class="line">NAME            STATUS   AGE</span><br><span class="line">namespace/dev   Active   <span class="number">18</span>s</span><br><span class="line"></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginxpod    <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">17</span>s</span><br></pre></td></tr></table></figure>

<p>这样就显示了两个资源对象的信息</p>
<p>4）执行delete命令，删除资源：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f nginxpod.yaml</span></span><br><span class="line">namespace <span class="string">&quot;dev&quot;</span> deleted</span><br><span class="line">pod <span class="string">&quot;nginxpod&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p>此时发现两个资源对象被删除了</p>
<p>总结:<br>命令式对象配置的方式操作资源，可以简单的认为：命令  +  <code>yaml</code>配置文件（里面是命令需要的各种参数）</p>
<h3 id="声明式对象配置"><a href="#声明式对象配置" class="headerlink" title="声明式对象配置"></a>声明式对象配置</h3><p>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先执行一次kubectl apply -f yaml文件，发现创建了资源</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl apply -f nginxpod.yaml</span></span><br><span class="line">namespace/dev created</span><br><span class="line">pod/nginxpod created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次执行一次kubectl apply -f yaml文件，发现说资源没有变动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl apply -f nginxpod.yaml</span></span><br><span class="line">namespace/dev unchanged</span><br><span class="line">pod/nginxpod unchanged</span><br></pre></td></tr></table></figure>

<p>总结:<br>其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态）<br>使用apply操作资源：<br>如果资源不存在，就创建，相当于 <code>kubectl create</code><br>如果资源已存在，就更新，相当于 <code>kubectl patch</code></p>
<blockquote>
<p>扩展：kubectl可以在node节点上运行吗 ?</p>
</blockquote>
<p><code>kubectl</code>的运行是需要进行配置的，它的配置文件是<code>\$HOME/.kube</code>，如果想要在<code>node</code>节点运行此命令，需要将<code>master</code>上的<code>.kube</code>文件复制到<code>node</code>节点上，即在<code>master</code>节点上执行下面操作：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scp  <span class="literal">-r</span>  HOME/.kube   node1: HOME/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用推荐:  三种方式应该怎么用 ?</p>
<p>创建&#x2F;更新资源      使用声明式对象配置 kubectl apply -f  XXX.yaml</p>
<p>删除资源              使用命令式对象配置 kubectl delete -f  XXX.yaml</p>
<p>查询资源              使用命令式对象管理 kubectl get(describe) 资源名称</p>
</blockquote>
<h1 id="第四章-实战入门"><a href="#第四章-实战入门" class="headerlink" title="第四章 实战入门"></a>第四章 实战入门</h1><p>本章节将介绍如何在<code>kubernetes</code>集群中部署一个<code>nginx</code>服务，并且能够对其进行访问。</p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现<strong>多套环境的资源隔离</strong>或者<strong>多租户的资源隔离</strong>。</p>
<p>默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的”组”，以方便不同的组的资源进行隔离使用和管理。</p>
<p>可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200407100850484.png" alt="image-20200407100850484"></p>
<p>kubernetes在集群启动之后，会默认创建几个namespace</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  get namespace</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   <span class="number">45</span><span class="built_in">h</span>     <span class="comment">#  所有未指定Namespace的对象都会被分配在default命名空间</span></span><br><span class="line">kube<span class="literal">-node-lease</span>   Active   <span class="number">45</span><span class="built_in">h</span>     <span class="comment">#  集群节点之间的心跳维护，v1.13开始引入</span></span><br><span class="line">kube<span class="literal">-public</span>       Active   <span class="number">45</span><span class="built_in">h</span>     <span class="comment">#  此命名空间下的资源可以被所有人访问（包括未认证用户）</span></span><br><span class="line">kube<span class="literal">-system</span>       Active   <span class="number">45</span><span class="built_in">h</span>     <span class="comment">#  所有由Kubernetes系统创建的资源都处于这个命名空间</span></span><br></pre></td></tr></table></figure>

<p>下面来看namespace资源的具体操作：</p>
<p><strong>查看</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 查看所有的ns  命令：kubectl get ns</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   <span class="number">45</span><span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-node-lease</span>   Active   <span class="number">45</span><span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-public</span>       Active   <span class="number">45</span><span class="built_in">h</span>     </span><br><span class="line">kube<span class="literal">-system</span>       Active   <span class="number">45</span><span class="built_in">h</span>     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 查看指定的ns   命令：kubectl get ns ns名称</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ns default</span></span><br><span class="line">NAME      STATUS   AGE</span><br><span class="line">default   Active   <span class="number">45</span><span class="built_in">h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 指定输出格式  命令：kubectl get ns ns名称  -o 格式参数</span></span><br><span class="line"><span class="comment"># kubernetes支持的格式有很多，比较常见的是wide、json、yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ns default -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2020-04-05T04:44:16Z&quot;</span></span><br><span class="line">  name: default</span><br><span class="line">  resourceVersion: <span class="string">&quot;151&quot;</span></span><br><span class="line">  selfLink: /api/v1/namespaces/default</span><br><span class="line">  uid: <span class="number">7405</span>f73a<span class="literal">-e486-43d4-9db6-145f1409f090</span></span><br><span class="line">spec:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">status:</span><br><span class="line">  phase: Active</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 4 查看ns详情  命令：kubectl describe ns ns名称</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe ns default</span></span><br><span class="line">Name:         default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active  <span class="comment"># Active 命名空间正在使用中  Terminating 正在删除命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ResourceQuota 针对namespace做的资源限制</span></span><br><span class="line"><span class="comment"># LimitRange针对namespace中的每个组件做的资源限制</span></span><br><span class="line">No resource quota.</span><br><span class="line">No LimitRange resource.</span><br></pre></td></tr></table></figure>

<p><strong>创建</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create ns dev</span></span><br><span class="line">namespace/dev created</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete ns dev</span></span><br><span class="line">namespace <span class="string">&quot;dev&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p><strong>配置方式</strong></p>
<p>首先准备一个yaml文件：ns-dev.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：<code>kubectl  create  -f  ns-dev.yaml</code></p>
<p>删除：<code>kubectl  delete  -f  ns-dev.yaml</code></p>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。</p>
<p>Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200407121501907.png" alt="image-20200407121501907"></p>
<p>kubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行的。可以通过下面命令查看：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n kube-system</span></span><br><span class="line">NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube<span class="literal">-system</span>   coredns<span class="literal">-6955765f44-68g6v</span>         <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>   coredns<span class="literal">-6955765f44-cs5r8</span>         <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>   etcd<span class="literal">-master</span>                      <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>   kube<span class="literal">-apiserver-master</span>            <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>   kube<span class="literal">-controller-manager-master</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>   kube<span class="literal">-flannel-ds-amd64-47r25</span>      <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>   kube<span class="literal">-flannel-ds-amd64-ls5lh</span>      <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>   kube<span class="literal">-proxy-685tk</span>                 <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>   kube<span class="literal">-proxy-87spt</span>                 <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>   kube<span class="literal">-scheduler-master</span>            <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>d1<span class="built_in">h</span></span><br></pre></td></tr></table></figure>

<p><strong>创建并运行</strong></p>
<p>kubernetes没有提供单独运行Pod的命令，都是通过Pod控制器来实现的</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式： kubectl run (pod控制器名称) [参数] </span></span><br><span class="line"><span class="comment"># --image  指定Pod的镜像</span></span><br><span class="line"><span class="comment"># --port   指定端口</span></span><br><span class="line"><span class="comment"># --namespace  指定namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run nginx --image=nginx:1.17.1 --port=80 --namespace dev </span></span><br><span class="line">deployment.apps/nginx created</span><br></pre></td></tr></table></figure>

<p><strong>查看pod信息</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看Pod基本信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx<span class="literal">-5ff7956ff6-fg2db</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">43</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod的详细信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pod nginx-5ff7956ff6-fg2db -n dev</span></span><br><span class="line">Name:         nginx<span class="literal">-5ff7956ff6-fg2db</span></span><br><span class="line">Namespace:    dev</span><br><span class="line">Priority:     <span class="number">0</span></span><br><span class="line">Node:         node1/<span class="number">192.168</span>.<span class="number">109.101</span></span><br><span class="line"><span class="built_in">Start</span> Time:   Wed, <span class="number">08</span> Apr <span class="number">2020</span> <span class="number">09</span>:<span class="number">29</span>:<span class="number">24</span> +<span class="number">0800</span></span><br><span class="line">Labels:       pod<span class="literal">-template-hash</span>=<span class="number">5</span>ff7956ff6</span><br><span class="line">              run=nginx</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           <span class="number">10.244</span>.<span class="number">1.23</span></span><br><span class="line">IPs:</span><br><span class="line">  IP:           <span class="number">10.244</span>.<span class="number">1.23</span></span><br><span class="line">Controlled By:  ReplicaSet/nginx<span class="literal">-5ff7956ff6</span></span><br><span class="line">Containers:</span><br><span class="line">  nginx:</span><br><span class="line">    Container ID:   docker://<span class="number">4</span>c62b8c0648d2512380f4ffa5da2c99d16e05634979973449c98e9b829f6253c</span><br><span class="line">    Image:          nginx:<span class="number">1.17</span>.<span class="number">1</span></span><br><span class="line">    Image ID:       docker<span class="literal">-pullable</span>://nginx@sha256:<span class="number">485</span>b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7</span><br><span class="line">    Port:           <span class="number">80</span>/TCP</span><br><span class="line">    Host Port:      <span class="number">0</span>/TCP</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Wed, <span class="number">08</span> Apr <span class="number">2020</span> <span class="number">09</span>:<span class="number">30</span>:<span class="number">01</span> +<span class="number">0800</span></span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  <span class="number">0</span></span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default<span class="literal">-token-hwvvw</span> (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  <span class="built_in">Type</span>              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  default<span class="literal">-token-hwvvw</span>:</span><br><span class="line">    <span class="built_in">Type</span>:        Secret (a volume populated by a Secret)</span><br><span class="line">    SecretName:  default<span class="literal">-token-hwvvw</span></span><br><span class="line">    Optional:    false</span><br><span class="line">QoS <span class="class"><span class="keyword">Class</span>:       <span class="title">BestEffort</span></span></span><br><span class="line"><span class="class"><span class="title">Node</span>-<span class="title">Selectors</span>:  &lt;<span class="title">none</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Tolerations</span>:     <span class="title">node</span>.<span class="title">kubernetes</span>.<span class="title">io</span>/<span class="title">not</span>-<span class="title">ready</span>:<span class="title">NoExecute</span> <span class="title">for</span> 300<span class="title">s</span></span></span><br><span class="line"><span class="class">                 <span class="title">node</span>.<span class="title">kubernetes</span>.<span class="title">io</span>/<span class="title">unreachable</span>:<span class="title">NoExecute</span> <span class="title">for</span> 300<span class="title">s</span></span></span><br><span class="line"><span class="class"><span class="title">Events</span>:</span></span><br><span class="line"><span class="class">  <span class="title">Type</span>    <span class="title">Reason</span>     <span class="title">Age</span>        <span class="title">From</span>               <span class="title">Message</span></span></span><br><span class="line"><span class="class">  ----    ------     ----       ----               -------</span></span><br><span class="line"><span class="class">  <span class="title">Normal</span>  <span class="title">Scheduled</span>  &lt;<span class="title">unknown</span>&gt;  <span class="title">default</span>-<span class="title">scheduler</span>  <span class="title">Successfully</span> <span class="title">assigned</span> <span class="title">dev</span>/<span class="title">nginx</span>-5<span class="title">ff7956ff6</span>-<span class="title">fg2db</span> <span class="title">to</span> <span class="title">node1</span></span></span><br><span class="line"><span class="class">  <span class="title">Normal</span>  <span class="title">Pulling</span>    4<span class="title">m11s</span>      <span class="title">kubelet</span>, <span class="title">node1</span>     <span class="title">Pulling</span> <span class="title">image</span> &quot;<span class="title">nginx</span>:1.17.1&quot;</span></span><br><span class="line"><span class="class">  <span class="title">Normal</span>  <span class="title">Pulled</span>     3<span class="title">m36s</span>      <span class="title">kubelet</span>, <span class="title">node1</span>     <span class="title">Successfully</span> <span class="title">pulled</span> <span class="title">image</span> &quot;<span class="title">nginx</span>:1.17.1&quot;</span></span><br><span class="line"><span class="class">  <span class="title">Normal</span>  <span class="title">Created</span>    3<span class="title">m36s</span>      <span class="title">kubelet</span>, <span class="title">node1</span>     <span class="title">Created</span> <span class="title">container</span> <span class="title">nginx</span></span></span><br><span class="line"><span class="class">  <span class="title">Normal</span>  <span class="title">Started</span>    3<span class="title">m36s</span>      <span class="title">kubelet</span>, <span class="title">node1</span>     <span class="title">Started</span> <span class="title">container</span> <span class="title">nginx</span></span></span><br></pre></td></tr></table></figure>

<p><strong>访问Pod</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取podIP</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE    IP             NODE    ... </span><br><span class="line">nginx<span class="literal">-5ff7956ff6-fg2db</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">190</span>s   <span class="number">10.244</span>.<span class="number">1.23</span>   node1   ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问POD</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl http://10.244.1.23:80</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> <span class="keyword">using</span> nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>删除指定Pod</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除指定Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete pod nginx-5ff7956ff6-fg2db -n dev</span></span><br><span class="line">pod <span class="string">&quot;nginx-5ff7956ff6-fg2db&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，显示删除Pod成功，但是再查询，发现又新产生了一个 </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx<span class="literal">-5ff7956ff6-jj4ng</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">21</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建</span></span><br><span class="line"><span class="comment"># 此时要想删除Pod，必须删除Pod控制器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先来查询一下当前namespace下的Pod控制器</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy -n  dev</span></span><br><span class="line">NAME    READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">9</span>m7s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，删除此PodPod控制器</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete deploy nginx -n dev</span></span><br><span class="line">deployment.apps <span class="string">&quot;nginx&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 稍等片刻，再查询Pod，发现Pod被删除了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">No resources found <span class="keyword">in</span> dev namespace.</span><br></pre></td></tr></table></figure>

<p><strong>配置操作</strong></p>
<p>创建一个pod-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：<code>kubectl  create  -f  pod-nginx.yaml</code></p>
<p>删除：<code>kubectl  delete  -f  pod-nginx.yaml</code></p>
<h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>Label是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</p>
<p>Label的特点：</p>
<ul>
<li>一个Label会以key&#x2F;value键值对的形式附加到各种对象上，如Node、Pod、Service等等</li>
<li>一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去</li>
<li>Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除</li>
</ul>
<p>可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。</p>
<blockquote>
<p>一些常用的Label 示例如下：</p>
<ul>
<li>版本标签：”version”:”release”, “version”:”stable”……</li>
<li>环境标签：”environment”:”dev”，”environment”:”test”，”environment”:”pro”</li>
<li>架构标签：”tier”:”frontend”，”tier”:”backend”</li>
</ul>
</blockquote>
<p>标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，即：</p>
<p>Label用于给某个资源对象定义标识</p>
<p>Label Selector用于查询和筛选拥有某些标签的资源对象</p>
<p>当前有两种Label Selector：</p>
<ul>
<li><p>基于等式的Label Selector</p>
<p>name &#x3D; slave: 选择所有包含Label中key&#x3D;”name”且value&#x3D;”slave”的对象</p>
<p>env !&#x3D; production: 选择所有包括Label中的key&#x3D;”env”且value不等于”production”的对象</p>
</li>
<li><p>基于集合的Label Selector</p>
<p>name in (master, slave): 选择所有包含Label中的key&#x3D;”name”且value&#x3D;”master”或”slave”的对象</p>
<p>name not in (frontend): 选择所有包含Label中的key&#x3D;”name”且value不等于”frontend”的对象</p>
</li>
</ul>
<p>标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号”,”进行分隔即可。例如：</p>
<p><code>name=slave</code>，<code>env!=production</code></p>
<p><code>name not in (frontend)</code>，<code>env!=production</code></p>
<p><strong>命令方式</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为pod资源打标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label pod nginx-pod version=1.0 -n dev</span></span><br><span class="line">pod/nginx<span class="literal">-pod</span> labeled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为pod资源更新标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label pod nginx-pod version=2.0 -n dev --overwrite</span></span><br><span class="line">pod/nginx<span class="literal">-pod</span> labeled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod nginx-pod  -n dev --show-labels</span></span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx<span class="literal">-pod</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">10</span>m   version=<span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev -l version=2.0  --show-labels</span></span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx<span class="literal">-pod</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">17</span>m   version=<span class="number">2.0</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev -l version!=2.0 --show-labels</span></span><br><span class="line">No resources found <span class="keyword">in</span> dev namespace.</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label pod nginx-pod version- -n dev</span></span><br><span class="line">pod/nginx<span class="literal">-pod</span> labeled</span><br></pre></td></tr></table></figure>

<p><strong>配置方式</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span> </span><br><span class="line">    <span class="attr">env:</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的更新命令了：kubectl  apply  -f  pod-nginx.yaml</p>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。</p>
<p>在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：<code>Deployment</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200408193950807.png" alt="image-20200408193950807"></p>
<p><strong>命令操作</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式: kubectl run deployment名称  [参数] </span></span><br><span class="line"><span class="comment"># --image  指定pod的镜像</span></span><br><span class="line"><span class="comment"># --port   指定端口</span></span><br><span class="line"><span class="comment"># --replicas  指定创建pod数量</span></span><br><span class="line"><span class="comment"># --namespace  指定namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run nginx --image=nginx:1.17.1 --port=80 --replicas=3 -n dev</span></span><br><span class="line">deployment.apps/nginx created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建的Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx<span class="literal">-5ff7956ff6-6k8cb</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">19</span>s</span><br><span class="line">nginx<span class="literal">-5ff7956ff6-jxfjt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">19</span>s</span><br><span class="line">nginx<span class="literal">-5ff7956ff6-v6jqw</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">19</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看deployment的信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy -n dev</span></span><br><span class="line">NAME    READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">nginx   <span class="number">3</span>/<span class="number">3</span>     <span class="number">3</span>            <span class="number">3</span>           <span class="number">2</span>m42s</span><br><span class="line"></span><br><span class="line"><span class="comment"># UP-TO-DATE：成功升级的副本数量</span></span><br><span class="line"><span class="comment"># AVAILABLE：可用副本的数量</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy -n dev -o wide</span></span><br><span class="line">NAME    READY UP<span class="literal">-TO-DATE</span>  AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTOR</span><br><span class="line">nginx   <span class="number">3</span>/<span class="number">3</span>     <span class="number">3</span>         <span class="number">3</span>           <span class="number">2</span>m51s   nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>        run=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看deployment的详细信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe deploy nginx -n dev</span></span><br><span class="line">Name:                   nginx</span><br><span class="line">Namespace:              dev</span><br><span class="line">CreationTimestamp:      Wed, <span class="number">08</span> Apr <span class="number">2020</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">14</span> +<span class="number">0800</span></span><br><span class="line">Labels:                 run=nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: <span class="number">1</span></span><br><span class="line">Selector:               run=nginx</span><br><span class="line">Replicas:               <span class="number">3</span> desired | <span class="number">3</span> updated | <span class="number">3</span> total | <span class="number">3</span> available | <span class="number">0</span> unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        <span class="number">0</span></span><br><span class="line">RollingUpdateStrategy:  <span class="number">25</span>% max unavailable, <span class="number">25</span>% max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  run=nginx</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:        nginx:<span class="number">1.17</span>.<span class="number">1</span></span><br><span class="line">    Port:         <span class="number">80</span>/TCP</span><br><span class="line">    Host Port:    <span class="number">0</span>/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  <span class="built_in">Type</span>           Status  Reason</span><br><span class="line">  <span class="literal">----</span>           <span class="literal">------</span>  <span class="literal">------</span></span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">  Progressing    True    NewReplicaSetAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   nginx<span class="literal">-5ff7956ff6</span> (<span class="number">3</span>/<span class="number">3</span> replicas created)</span><br><span class="line">Events:</span><br><span class="line">  <span class="built_in">Type</span>    Reason             Age    From                   Message</span><br><span class="line">  <span class="literal">----</span>    <span class="literal">------</span>             <span class="literal">----</span>   <span class="literal">----</span>                   <span class="literal">-------</span></span><br><span class="line">  Normal  ScalingReplicaSet  <span class="number">5</span>m43s  deployment<span class="literal">-controller</span>  Scaled up replicaset nginx<span class="literal">-5ff7956ff6</span> to <span class="number">3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除 </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete deploy nginx -n dev</span></span><br><span class="line">deployment.apps <span class="string">&quot;nginx&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p><strong>配置操作</strong></p>
<p>创建一个deploy-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：<code>kubectl  create  -f  deploy-nginx.yaml</code></p>
<p>删除：<code>kubectl  delete  -f  deploy-nginx.yaml</code></p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>通过上节课的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。</p>
<p>虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：</p>
<ul>
<li>Pod IP 会随着Pod的重建产生变化</li>
<li>Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问</li>
</ul>
<p>这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。</p>
<p>Service可以看作是一组同类Pod<strong>对外的访问接口</strong>。借助Service，应用可以方便地实现服务发现和负载均衡。<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200408194716912.png" alt="image-20200408194716912"></p>
<p><strong>操作一：创建集群内部可访问的Service</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴露Service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev</span></span><br><span class="line">service/svc<span class="literal">-nginx1</span> exposed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc svc-nginx -n dev -o wide</span></span><br><span class="line">NAME         <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>       EXTERNAL<span class="literal">-IP</span>   PORT(S)   AGE     SELECTOR</span><br><span class="line">svc<span class="literal">-nginx1</span>   ClusterIP   <span class="number">10.109</span>.<span class="number">179.231</span>   &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">3</span>m51s   run=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的</span></span><br><span class="line"><span class="comment"># 可以通过这个IP访问当前service对应的POD</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.109.179.231:80</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">.......</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>操作二：创建集群外部也可访问的Service</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面创建的Service的type类型为ClusterIP，这个ip地址只用集群内部可访问</span></span><br><span class="line"><span class="comment"># 如果需要创建外部也可以访问的Service，需要修改type为NodePort</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev</span></span><br><span class="line">service/svc<span class="literal">-nginx2</span> exposed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc  svc-nginx-1  -n dev -o wide</span></span><br><span class="line">NAME          <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>       EXTERNAL<span class="literal">-IP</span>   PORT(S)        AGE    SELECTOR</span><br><span class="line">svc<span class="literal">-nginx2</span>    NodePort    <span class="number">10.100</span>.<span class="number">94.0</span>      &lt;none&gt;        <span class="number">80</span>:<span class="number">31928</span>/TCP   <span class="number">9</span>s     run=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就可以通过集群外的主机访问 节点IP:31928访问服务了</span></span><br><span class="line"><span class="comment"># 例如在的电脑主机上通过浏览器访问下面的地址</span></span><br><span class="line">http://<span class="number">192.168</span>.<span class="number">109.100</span>:<span class="number">31928</span>/</span><br></pre></td></tr></table></figure>

<p><strong>删除Service</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete svc svc-nginx-1 -n dev                                   service &quot;svc-nginx-1&quot; deleted</span></span><br></pre></td></tr></table></figure>

<p><strong>配置方式</strong></p>
<p>创建一个svc-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">svc-nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.109</span><span class="number">.179</span><span class="number">.231</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<p>创建：<code>kubectl  create  -f  svc-nginx.yaml</code></p>
<p>删除：<code>kubectl  delete  -f  svc-nginx.yaml</code></p>
<blockquote>
<p><strong>小结</strong></p>
<p>至此，已经掌握了Namespace、Pod、Deployment、Service资源的基本操作，有了这些操作，就可以在kubernetes集群中实现一个服务的简单部署和访问了，但是如果想要更好的使用kubernetes，就需要深入学习这几种资源的细节和原理。</p>
</blockquote>
<h1 id="第五章-Pod详解"><a href="#第五章-Pod详解" class="headerlink" title="第五章 Pod详解"></a>第五章 Pod详解</h1><p>本章节将详细介绍Pod资源的各种配置（yaml）和原理。</p>
<h2 id="Pod介绍"><a href="#Pod介绍" class="headerlink" title="Pod介绍"></a>Pod介绍</h2><h3 id="Pod结构"><a href="#Pod结构" class="headerlink" title="Pod结构"></a>Pod结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200407121501907.png"></p>
<p>每个Pod中都可以包含一个或者多个容器，这些容器可以分为两类：</p>
<ul>
<li><p>用户程序所在的容器，数量可多可少</p>
</li>
<li><p>Pause容器，这是每个Pod都会有的一个<strong>根容器</strong>，它的作用有两个：</p>
<ul>
<li><p>可以以它为依据，评估整个Pod的健康状态</p>
</li>
<li><p>可以在根容器上设置Ip地址，其它容器都此Ip（Pod IP），以实现Pod内部的网路通信</p>
<p>这里是Pod内部的通讯，Pod的之间的通讯采用虚拟二层网络技术来实现，我们当前环境用的是Flannel</p>
</li>
</ul>
</li>
</ul>
<h3 id="Pod定义"><a href="#Pod定义" class="headerlink" title="Pod定义"></a>Pod定义</h3><p>下面是Pod的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>     <span class="comment">#必选，版本号，例如v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       　 <span class="comment">#必选，资源类型，例如 Pod</span></span><br><span class="line"><span class="attr">metadata:</span>       　 <span class="comment">#必选，元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#必选，Pod名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">string</span>  <span class="comment">#Pod所属的命名空间,默认为&quot;default&quot;</span></span><br><span class="line">  <span class="attr">labels:</span>       　　  <span class="comment">#自定义标签列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　          </span><br><span class="line"><span class="attr">spec:</span>  <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line">  <span class="attr">containers:</span>  <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>   <span class="comment">#必选，容器名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span>  <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> [ <span class="string">Always|Never|IfNotPresent</span> ]  <span class="comment">#获取镜像的策略 </span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">string</span>]   <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">string</span>]      <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">string</span>  <span class="comment">#容器的工作目录</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>       <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">string</span> <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="string">boolean</span> <span class="comment">#是否为只读模式</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>        <span class="comment">#端口的名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="string">int</span>  <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="string">int</span>       <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">string</span>    <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="attr">env:</span>   <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>  <span class="comment">#环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">string</span> <span class="comment">#环境变量的值</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment">#资源限制的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>     <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>  <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment">#资源请求的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span> <span class="comment">#内存请求,容器启动的初始可用数量</span></span><br><span class="line">    <span class="attr">lifecycle:</span> <span class="comment">#生命周期钩子</span></span><br><span class="line">		<span class="attr">postStart:</span> <span class="comment">#容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span></span><br><span class="line">		<span class="attr">preStop:</span> <span class="comment">#容器终止前执行此钩子,无论结果如何,容器都会终止</span></span><br><span class="line">    <span class="attr">livenessProbe:</span>  <span class="comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span></span><br><span class="line">      <span class="attr">exec:</span>       　 <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">string</span>]  <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line">      <span class="attr">httpGet:</span>       <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">HttpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">tcpSocket:</span>     <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line">         <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">       <span class="attr">initialDelaySeconds:</span> <span class="number">0</span>       <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line">       <span class="attr">timeoutSeconds:</span> <span class="number">0</span>    　　    <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line">       <span class="attr">periodSeconds:</span> <span class="number">0</span>     　　    <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line">       <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">securityContext:</span></span><br><span class="line">         <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">OnFailure</span>]  <span class="comment">#Pod的重启策略</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">&lt;string&gt;</span> <span class="comment">#设置NodeName表示将该Pod调度到指定到名称的node节点上</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="string">obeject</span> <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span> <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>   <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line">  <span class="attr">volumes:</span>   <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>    <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;       <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line">    <span class="attr">hostPath:</span> <span class="string">string</span>   <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">string</span>      　　        <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line">    <span class="attr">secret:</span>       　　　<span class="comment">#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span></span><br><span class="line">      <span class="attr">scretname:</span> <span class="string">string</span>  </span><br><span class="line">      <span class="attr">items:</span>     </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">configMap:</span>         <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#小提示：</span></span><br><span class="line"><span class="comment">#	在这里，可通过一个命令来查看每种资源的可配置项</span></span><br><span class="line"><span class="comment">#   kubectl explain 资源类型         查看某种资源可以配置的一级属性</span></span><br><span class="line"><span class="comment">#	kubectl explain 资源类型.属性     查看属性的子属性</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod</span></span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">FIELDS:</span><br><span class="line">   apiVersion   &lt;string&gt;</span><br><span class="line">   kind &lt;string&gt;</span><br><span class="line">   metadata     &lt;Object&gt;</span><br><span class="line">   spec &lt;Object&gt;</span><br><span class="line">   status       &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.metadata</span></span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: metadata &lt;Object&gt;</span><br><span class="line">FIELDS:</span><br><span class="line">   annotations  &lt;map[<span class="built_in">string</span>]string&gt;</span><br><span class="line">   clusterName  &lt;string&gt;</span><br><span class="line">   creationTimestamp    &lt;string&gt;</span><br><span class="line">   deletionGracePeriodSeconds   &lt;integer&gt;</span><br><span class="line">   deletionTimestamp    &lt;string&gt;</span><br><span class="line">   finalizers   &lt;[]string&gt;</span><br><span class="line">   generateName &lt;string&gt;</span><br><span class="line">   generation   &lt;integer&gt;</span><br><span class="line">   labels       &lt;map[<span class="built_in">string</span>]string&gt;</span><br><span class="line">   managedFields        &lt;[]Object&gt;</span><br><span class="line">   name &lt;string&gt;</span><br><span class="line">   namespace    &lt;string&gt;</span><br><span class="line">   ownerReferences      &lt;[]Object&gt;</span><br><span class="line">   resourceVersion      &lt;string&gt;</span><br><span class="line">   selfLink     &lt;string&gt;</span><br><span class="line">   uid  &lt;string&gt;</span><br></pre></td></tr></table></figure>

<p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p>
<ul>
<li><p>apiVersion   &lt;string&gt;     版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到</p>
</li>
<li><p>kind &lt;string&gt;                类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到</p>
</li>
<li><p>metadata   &lt;Object&gt;     元数据，主要是资源标识和说明，常用的有name、namespace、labels等</p>
</li>
<li><p>spec &lt;Object&gt;               描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</p>
</li>
<li><p>status  &lt;Object&gt;            状态信息，里面的内容不需要定义，由kubernetes自动生成</p>
</li>
</ul>
<p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:</p>
<ul>
<li>containers   &lt;[]Object&gt;       容器列表，用于定义容器的详细信息</li>
<li>nodeName &lt;String&gt;           根据nodeName的值将pod调度到指定的Node节点上</li>
<li>nodeSelector   &lt;map[]&gt;      根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上</li>
<li>hostNetwork  &lt;boolean&gt;    是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li>
<li>volumes      &lt;[]Object&gt;       存储卷，用于定义Pod上面挂在的存储信息</li>
<li>restartPolicy	&lt;string&gt;       重启策略，表示Pod在遇到故障的时候的处理策略</li>
</ul>
<h2 id="Pod配置"><a href="#Pod配置" class="headerlink" title="Pod配置"></a>Pod配置</h2><p>本小节主要来研究<code>pod.spec.containers</code>属性，这也是pod配置中最为关键的一项配置。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.spec.containers</span></span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: containers &lt;[]Object&gt;   <span class="comment"># 数组，代表可以有多个容器</span></span><br><span class="line">FIELDS:</span><br><span class="line">   name  &lt;string&gt;     <span class="comment"># 容器名称</span></span><br><span class="line">   image &lt;string&gt;     <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">   imagePullPolicy  &lt;string&gt; <span class="comment"># 镜像拉取策略 </span></span><br><span class="line">   command  &lt;[]string&gt; <span class="comment"># 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">   args     &lt;[]string&gt; <span class="comment"># 容器的启动命令需要的参数列表</span></span><br><span class="line">   env      &lt;[]Object&gt; <span class="comment"># 容器环境变量的配置</span></span><br><span class="line">   ports    &lt;[]Object&gt;     <span class="comment"># 容器需要暴露的端口号列表</span></span><br><span class="line">   resources &lt;Object&gt;      <span class="comment"># 资源限制和资源请求的设置</span></span><br></pre></td></tr></table></figure>

<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>创建pod-base.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-base</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">heima</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<p>上面定义了一个比较简单Pod的配置，里面有两个容器：</p>
<ul>
<li>nginx：用1.17.1版本的nginx镜像创建，（nginx是一个轻量级web容器）</li>
<li>busybox：用1.30版本的busybox镜像创建，（busybox是一个小巧的linux命令集合）</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl apply -f pod-base.yaml</span></span><br><span class="line">pod/pod<span class="literal">-base</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod状况</span></span><br><span class="line"><span class="comment"># READY 1/2 : 表示当前Pod中有2个容器，其中1个准备就绪，1个未就绪</span></span><br><span class="line"><span class="comment"># RESTARTS  : 重启次数，因为有1个容器故障了，Pod一直在重启试图恢复它</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl get pod -n dev</span></span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-base</span>   <span class="number">1</span>/<span class="number">2</span>     Running   <span class="number">4</span>          <span class="number">95</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过describe查看内部的详情</span></span><br><span class="line"><span class="comment"># 此时已经运行起来了一个基本的Pod，虽然它暂时有问题</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl describe pod pod-base -n dev</span></span><br></pre></td></tr></table></figure>

<h3 id="镜像拉取"><a href="#镜像拉取" class="headerlink" title="镜像拉取"></a>镜像拉取</h3><p>创建pod-imagepullpolicy.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-imagepullpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span> <span class="comment"># 用于设置镜像拉取策略</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<p>imagePullPolicy，用于设置镜像拉取策略，kubernetes支持配置三种拉取策略：</p>
<ul>
<li>Always：总是从远程仓库拉取镜像（一直远程下载）</li>
<li>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地  本地没远程下载）</li>
<li>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错 （一直使用本地）</li>
</ul>
<blockquote>
<p>默认值说明：</p>
<p>如果镜像tag为具体版本号， 默认策略是：IfNotPresent</p>
<p>如果镜像tag为：latest（最终版本） ，默认策略是always</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl create -f pod-imagepullpolicy.yaml</span></span><br><span class="line">pod/pod<span class="literal">-imagepullpolicy</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详情</span></span><br><span class="line"><span class="comment"># 此时明显可以看到nginx镜像有一步Pulling image &quot;nginx:1.17.1&quot;的过程</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl describe pod pod-imagepullpolicy -n dev</span></span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  <span class="built_in">Type</span>     Reason     Age               From               Message</span><br><span class="line">  <span class="literal">----</span>     <span class="literal">------</span>     <span class="literal">----</span>              <span class="literal">----</span>               <span class="literal">-------</span></span><br><span class="line">  Normal   Scheduled  &lt;unknown&gt;         default<span class="literal">-scheduler</span>  Successfully assigned dev/pod<span class="literal">-imagePullPolicy</span> to node1</span><br><span class="line">  Normal   Pulling    <span class="number">32</span>s               kubelet, node1     Pulling image <span class="string">&quot;nginx:1.17.1&quot;</span></span><br><span class="line">  Normal   Pulled     <span class="number">26</span>s               kubelet, node1     Successfully pulled image <span class="string">&quot;nginx:1.17.1&quot;</span></span><br><span class="line">  Normal   Created    <span class="number">26</span>s               kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    <span class="number">25</span>s               kubelet, node1     Started container nginx</span><br><span class="line">  Normal   Pulled     <span class="number">7</span>s (x3 over <span class="number">25</span>s)  kubelet, node1     Container image <span class="string">&quot;busybox:1.30&quot;</span> already present on machine</span><br><span class="line">  Normal   Created    <span class="number">7</span>s (x3 over <span class="number">25</span>s)  kubelet, node1     Created container busybox</span><br><span class="line">  Normal   Started    <span class="number">7</span>s (x3 over <span class="number">25</span>s)  kubelet, node1     Started container busybox</span><br></pre></td></tr></table></figure>

<h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><p>在前面的案例中，一直有一个问题没有解决，就是的busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障呢？</p>
<p>原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command配置。</p>
<p>创建pod-command.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-command</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>command，用于在pod中的容器初始化完毕之后运行一个命令。</p>
<blockquote>
<p>稍微解释下上面命令的意思：</p>
<p>“&#x2F;bin&#x2F;sh”,”-c”,  使用sh执行命令</p>
<p>touch &#x2F;tmp&#x2F;hello.txt;   创建一个&#x2F;tmp&#x2F;hello.txt 文件</p>
<p>while true;do &#x2F;bin&#x2F;echo $(date +%T) &gt;&gt; &#x2F;tmp&#x2F;hello.txt; sleep 3; done;  每隔3秒向文件中写入当前时间</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl create  -f pod-command.yaml</span></span><br><span class="line">pod/pod<span class="literal">-command</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod状态</span></span><br><span class="line"><span class="comment"># 此时发现两个pod都正常运行了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl get pods pod-command -n dev</span></span><br><span class="line">NAME          READY   STATUS   RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-command</span>   <span class="number">2</span>/<span class="number">2</span>     Runing   <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入pod中的busybox容器，查看文件内容</span></span><br><span class="line"><span class="comment"># 补充一个命令: kubectl exec  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行命令</span></span><br><span class="line"><span class="comment"># 使用这个命令就可以进入某个容器的内部，然后进行相关操作了</span></span><br><span class="line"><span class="comment"># 比如，可以查看txt文件的内容</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl exec pod-command -n dev -it -c busybox /bin/sh</span></span><br><span class="line">/ <span class="comment"># tail -f /tmp/hello.txt</span></span><br><span class="line"><span class="number">13</span>:<span class="number">35</span>:<span class="number">35</span></span><br><span class="line"><span class="number">13</span>:<span class="number">35</span>:<span class="number">38</span></span><br><span class="line"><span class="number">13</span>:<span class="number">35</span>:<span class="number">41</span></span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">特别说明：</span><br><span class="line"><span class="code">    通过上面发现command已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个args选项，用于传递参数呢?这其实跟docker有点关系，kubernetes中的command、args两项其实是实现覆盖Dockerfile中ENTRYPOINT的功能。</span></span><br><span class="line"><span class="code"> 1 如果command和args均没有写，那么用Dockerfile的配置。</span></span><br><span class="line"><span class="code"> 2 如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command</span></span><br><span class="line"><span class="code"> 3 如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数</span></span><br><span class="line"><span class="code"> 4 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数</span></span><br></pre></td></tr></table></figure>

<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>创建pod-env.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do /bin/echo $(date +%T);sleep 60; done;&quot;</span>]</span><br><span class="line">    <span class="attr">env:</span> <span class="comment"># 设置环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<p>env，环境变量，用于在pod中的容器设置环境变量。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-env.yaml</span></span><br><span class="line">pod/pod<span class="literal">-env</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器，输出环境变量</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl exec pod-env -n dev -c busybox -it /bin/sh</span></span><br><span class="line">/ <span class="comment"># echo $username</span></span><br><span class="line">admin</span><br><span class="line">/ <span class="comment"># echo $password</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。</p>
<h3 id="端口设置"><a href="#端口设置" class="headerlink" title="端口设置"></a>端口设置</h3><p>本小节来介绍容器的端口设置，也就是containers的ports选项。</p>
<p>首先看下ports支持的子选项：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.spec.containers.ports</span></span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: ports &lt;[]Object&gt;</span><br><span class="line">FIELDS:</span><br><span class="line">   name         &lt;string&gt;  <span class="comment"># 端口名称，如果指定，必须保证name在pod中是唯一的		</span></span><br><span class="line">   containerPort&lt;integer&gt; <span class="comment"># 容器要监听的端口(0&lt;x&lt;65536)</span></span><br><span class="line">   hostPort     &lt;integer&gt; <span class="comment"># 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略) </span></span><br><span class="line">   hostIP       &lt;string&gt;  <span class="comment"># 要将外部端口绑定到的主机IP(一般省略)</span></span><br><span class="line">   protocol     &lt;string&gt;  <span class="comment"># 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。</span></span><br></pre></td></tr></table></figure>

<p>接下来，编写一个测试案例，创建pod-ports.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-ports</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 设置容器暴露的端口列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-ports.yaml</span></span><br><span class="line">pod/pod<span class="literal">-ports</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line"><span class="comment"># 在下面可以明显看到配置信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-ports -n dev -o yaml</span></span><br><span class="line">......</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:<span class="number">1.17</span>.<span class="number">1</span></span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: <span class="number">80</span></span><br><span class="line">      name: nginx<span class="literal">-port</span></span><br><span class="line">      protocol: TCP</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>访问容器中的程序需要使用的是<code>podIp:containerPort</code></p>
<h3 id="资源配额"><a href="#资源配额" class="headerlink" title="资源配额"></a>资源配额</h3><p>容器中的程序要运行，肯定是要占用一定资源的，比如cpu和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其它容器无法运行。针对这种情况，kubernetes提供了对内存和cpu的资源进行配额的机制，这种机制主要通过resources选项实现，他有两个子选项：</p>
<ul>
<li><p>limits：用于限制运行时容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启</p>
</li>
<li><p>requests ：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动</p>
</li>
</ul>
<p>可以通过上面两个选项设置资源的上下限。</p>
<p>接下来，编写一个测试案例，创建pod-resources.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-resources</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment"># 资源配额</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment"># 限制资源（上限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Gi&quot;</span> <span class="comment"># 内存限制</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment"># 请求资源（下限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Mi&quot;</span>  <span class="comment"># 内存限制</span></span><br></pre></td></tr></table></figure>

<p>在这对cpu和memory的单位做一个说明：</p>
<ul>
<li><p>cpu：core数，可以为整数或小数</p>
</li>
<li><p>memory： 内存大小，可以使用Gi、Mi、G、M等形式</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create  -f pod-resources.yaml</span></span><br><span class="line">pod/pod<span class="literal">-resources</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看发现pod运行正常</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-resources -n dev</span></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE  </span><br><span class="line">pod<span class="literal">-resources</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">39</span>s   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，停止Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete  -f pod-resources.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-resources&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑pod，修改resources.requests.memory的值为10Gi</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-resources.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次启动pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create  -f pod-resources.yaml</span></span><br><span class="line">pod/pod<span class="literal">-resources</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod状态，发现Pod启动失败</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-resources -n dev -o wide</span></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE          </span><br><span class="line">pod<span class="literal">-resources</span>   <span class="number">0</span>/<span class="number">2</span>     Pending   <span class="number">0</span>          <span class="number">20</span>s    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod详情会发现，如下提示</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pod pod-resources -n dev</span></span><br><span class="line">......</span><br><span class="line">Warning  FailedScheduling  &lt;unknown&gt;  default<span class="literal">-scheduler</span>  <span class="number">0</span>/<span class="number">2</span> nodes are available: <span class="number">2</span> Insufficient memory.(内存不足)</span><br></pre></td></tr></table></figure>

<h2 id="Pod生命周期"><a href="#Pod生命周期" class="headerlink" title="Pod生命周期"></a>Pod生命周期</h2><p>我们一般将pod对象从创建至终的这段时间范围称为pod的生命周期，它主要包含下面的过程：</p>
<ul>
<li><p>pod创建过程</p>
</li>
<li><p>运行初始化容器（init container）过程</p>
</li>
<li><p>运行主容器（main container）</p>
<ul>
<li><p>容器启动后钩子（post start）、容器终止前钩子（pre stop）</p>
</li>
<li><p>容器的存活性探测（liveness probe）、就绪性探测（readiness probe）</p>
</li>
</ul>
</li>
<li><p>pod终止过程</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200412111402706.png" alt="image-20200412111402706"></p>
<p>在整个生命周期中，Pod会出现5种<strong>状态</strong>（<strong>相位</strong>），分别如下：</p>
<ul>
<li>挂起（Pending）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li>
<li>运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li>
<li>成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启</li>
<li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li>
<li>未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li>
</ul>
<h3 id="创建和终止"><a href="#创建和终止" class="headerlink" title="创建和终止"></a>创建和终止</h3><p><strong>pod的创建过程</strong></p>
<ol>
<li><p>用户通过kubectl或其他api客户端提交需要创建的pod信息给apiServer</p>
</li>
<li><p>apiServer开始生成pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端</p>
</li>
<li><p>apiServer开始反映etcd中的pod对象的变化，其它组件使用watch机制来跟踪检查apiServer上的变动</p>
</li>
<li><p>scheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至apiServer</p>
</li>
<li><p>node节点上的kubelet发现有pod调度过来，尝试调用docker启动容器，并将结果回送至apiServer</p>
</li>
<li><p>apiServer将接收到的pod状态信息存入etcd中</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200406184656917.png"></p>
</li>
</ol>
<p><strong>pod的终止过程</strong></p>
<ol>
<li>用户向apiServer发送删除pod对象的命令</li>
<li>apiServcer中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead</li>
<li>将pod标记为terminating状态</li>
<li>kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程</li>
<li>端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除</li>
<li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行</li>
<li>pod对象中的容器进程收到停止信号</li>
<li>宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号</li>
<li>kubelet请求apiServer将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见</li>
</ol>
<h3 id="初始化容器"><a href="#初始化容器" class="headerlink" title="初始化容器"></a>初始化容器</h3><p>初始化容器是在pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：</p>
<ol>
<li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成</li>
<li>初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行</li>
</ol>
<p>初始化容器有很多的应用场景，下面列出的是最常见的几个：</p>
<ul>
<li>提供主容器镜像中不具备的工具程序或自定义代码</li>
<li>初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足</li>
</ul>
<p>接下来做一个案例，模拟下面这个需求：</p>
<p>假设要以主容器来运行nginx，但是要求在运行nginx之前先要能够连接上mysql和redis所在服务器</p>
<p>为了简化测试，事先规定好mysql<code>(192.168.109.201)</code>和redis<code>(192.168.109.202)</code>服务器的地址</p>
<p>创建pod-initcontainer.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-initcontainer</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until ping 192.168.109.201 -c 1 ; do echo waiting for mysql...; sleep 2; done;&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until ping 192.168.109.202 -c 1 ; do echo waiting for reids...; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-initcontainer.yaml</span></span><br><span class="line">pod/pod<span class="literal">-initcontainer</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状态</span></span><br><span class="line"><span class="comment"># 发现pod卡在启动第一个初始化容器过程中，后面的容器不会运行</span></span><br><span class="line">root@master ~]<span class="comment"># kubectl describe pod  pod-initcontainer -n dev</span></span><br><span class="line">........</span><br><span class="line">Events:</span><br><span class="line">  <span class="built_in">Type</span>    Reason     Age   From               Message</span><br><span class="line">  <span class="literal">----</span>    <span class="literal">------</span>     <span class="literal">----</span>  <span class="literal">----</span>               <span class="literal">-------</span></span><br><span class="line">  Normal  Scheduled  <span class="number">49</span>s   default<span class="literal">-scheduler</span>  Successfully assigned dev/pod<span class="literal">-initcontainer</span> to node1</span><br><span class="line">  Normal  Pulled     <span class="number">48</span>s   kubelet, node1     Container image <span class="string">&quot;busybox:1.30&quot;</span> already present on machine</span><br><span class="line">  Normal  Created    <span class="number">48</span>s   kubelet, node1     Created container <span class="built_in">test-mysql</span></span><br><span class="line">  Normal  Started    <span class="number">48</span>s   kubelet, node1     Started container <span class="built_in">test-mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-initcontainer -n dev -w</span></span><br><span class="line">NAME                             READY   STATUS     RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">0</span>/<span class="number">1</span>     Init:<span class="number">0</span>/<span class="number">2</span>   <span class="number">0</span>          <span class="number">15</span>s</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">0</span>/<span class="number">1</span>     Init:<span class="number">1</span>/<span class="number">2</span>   <span class="number">0</span>          <span class="number">52</span>s</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">0</span>/<span class="number">1</span>     Init:<span class="number">1</span>/<span class="number">2</span>   <span class="number">0</span>          <span class="number">53</span>s</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">0</span>/<span class="number">1</span>     PodInitializing   <span class="number">0</span>          <span class="number">89</span>s</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">1</span>/<span class="number">1</span>     Running           <span class="number">0</span>          <span class="number">90</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来新开一个shell，为当前服务器新增两个ip，观察pod的变化</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ifconfig ens33:1 192.168.109.201 netmask 255.255.255.0 up</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ifconfig ens33:2 192.168.109.202 netmask 255.255.255.0 up</span></span><br></pre></td></tr></table></figure>

<h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p>
<p>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p>
<ul>
<li>post start：容器创建之后执行，如果失败了会重启容器</li>
<li>pre stop  ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li>
</ul>
<p>钩子处理器支持使用下面三种方式定义动作：</p>
<ul>
<li><p>Exec命令：在容器内执行一次命令</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span> </span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TCPSocket：在当前容器尝试访问指定的socket</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span>      </span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPGet：在当前容器中向某url发起http请求</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">        <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span> <span class="comment">#主机地址</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>接下来，以exec方式为例，演示下钩子函数的使用，创建pod-hook-exec.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-hook-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span> </span><br><span class="line">        <span class="attr">exec:</span> <span class="comment"># 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo postStart... &gt; /usr/share/nginx/html/index.html&quot;</span>]</span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span> <span class="comment"># 在容器停止之前停止nginx服务</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-s&quot;</span>,<span class="string">&quot;quit&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-hook-exec.yaml</span></span><br><span class="line">pod/pod<span class="literal">-hook-exec</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods  pod-hook-exec -n dev -o wide</span></span><br><span class="line">NAME           READY   STATUS     RESTARTS   AGE    IP            NODE    </span><br><span class="line">pod<span class="literal">-hook-exec</span>  <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">0</span>          <span class="number">29</span>s    <span class="number">10.244</span>.<span class="number">2.48</span>   node2   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.2.48</span></span><br><span class="line">postStart...</span><br></pre></td></tr></table></figure>

<h3 id="容器探测"><a href="#容器探测" class="headerlink" title="容器探测"></a>容器探测</h3><p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例” 摘除 “，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p>
<ul>
<li><p>liveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器</p>
</li>
<li><p>readiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量</p>
</li>
</ul>
<blockquote>
<p>livenessProbe 决定是否重启容器，readinessProbe 决定是否将请求转发给容器。</p>
</blockquote>
<p>上面两种探针目前均支持三种探测方式：</p>
<ul>
<li><p>Exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span>      </span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">tcpSocket:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">httpGet:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#主机地址</span></span><br><span class="line">      <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面以liveness probes为例，做几个演示：</p>
<p><strong>方式一：Exec</strong></p>
<p>创建pod-liveness-exec.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/bin/cat&quot;</span>,<span class="string">&quot;/tmp/hello.txt&quot;</span>] <span class="comment"># 执行一个查看文件的命令</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-liveness-exec.yaml</span></span><br><span class="line">pod/pod<span class="literal">-liveness-exec</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pods pod-liveness-exec -n dev</span></span><br><span class="line">......</span><br><span class="line">  Normal   Created    <span class="number">20</span>s (x2 over <span class="number">50</span>s)  kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    <span class="number">20</span>s (x2 over <span class="number">50</span>s)  kubelet, node1     Started container nginx</span><br><span class="line">  Normal   Killing    <span class="number">20</span>s                kubelet, node1     Container nginx failed liveness probe, will be restarted</span><br><span class="line">  Warning  Unhealthy  <span class="number">0</span>s (x5 over <span class="number">40</span>s)   kubelet, node1     Liveness probe failed: <span class="built_in">cat</span>: can<span class="string">&#x27;t open &#x27;</span>/tmp/hello11.txt<span class="string">&#x27;: No such file or directory</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"># 观察上面的信息就会发现nginx容器启动之后就进行了健康检查</span></span><br><span class="line"><span class="string"># 检查失败之后，容器被kill掉，然后尝试进行重启（这是重启策略的作用，后面讲解）</span></span><br><span class="line"><span class="string"># 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line"><span class="string">[root@master ~]# kubectl get pods pod-liveness-exec -n dev</span></span><br><span class="line"><span class="string">NAME                READY   STATUS             RESTARTS   AGE</span></span><br><span class="line"><span class="string">pod-liveness-exec   0/1     CrashLoopBackOff   2          3m19s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 当然接下来，可以修改成一个存在的文件，比如/tmp/hello.txt，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p><strong>方式二：TCPSocket</strong></p>
<p>创建pod-liveness-tcpsocket.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-tcpsocket</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 尝试访问8080端口</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-liveness-tcpsocket.yaml</span></span><br><span class="line">pod/pod<span class="literal">-liveness-tcpsocket</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pods pod-liveness-tcpsocket -n dev</span></span><br><span class="line">......</span><br><span class="line">  Normal   Scheduled  <span class="number">31</span>s                            default<span class="literal">-scheduler</span>  Successfully assigned dev/pod<span class="literal">-liveness-tcpsocket</span> to node2</span><br><span class="line">  Normal   Pulled     &lt;invalid&gt;                      kubelet, node2     Container image <span class="string">&quot;nginx:1.17.1&quot;</span> already present on machine</span><br><span class="line">  Normal   Created    &lt;invalid&gt;                      kubelet, node2     Created container nginx</span><br><span class="line">  Normal   Started    &lt;invalid&gt;                      kubelet, node2     Started container nginx</span><br><span class="line">  Warning  Unhealthy  &lt;invalid&gt; (x2 over &lt;invalid&gt;)  kubelet, node2     Liveness probe failed: dial tcp <span class="number">10.244</span>.<span class="number">2.44</span>:<span class="number">8080</span>: connect: connection refused</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 观察上面的信息，发现尝试访问8080端口,但是失败了</span></span><br><span class="line"><span class="comment"># 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-liveness-tcpsocket  -n dev</span></span><br><span class="line">NAME                     READY   STATUS             RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-liveness-tcpsocket</span>   <span class="number">0</span>/<span class="number">1</span>     CrashLoopBackOff   <span class="number">2</span>          <span class="number">3</span>m19s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然接下来，可以修改成一个可以访问的端口，比如80，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p><strong>方式三：HTTPGet</strong></p>
<p>创建pod-liveness-httpget.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-httpget</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span>  <span class="comment"># 其实就是访问http://127.0.0.1:80/hello  </span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/hello</span> <span class="comment">#URI地址</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-liveness-httpget.yaml</span></span><br><span class="line">pod/pod<span class="literal">-liveness-httpget</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pod pod-liveness-httpget -n dev</span></span><br><span class="line">.......</span><br><span class="line">  Normal   Pulled     <span class="number">6</span>s (x3 over <span class="number">64</span>s)  kubelet, node1     Container image <span class="string">&quot;nginx:1.17.1&quot;</span> already present on machine</span><br><span class="line">  Normal   Created    <span class="number">6</span>s (x3 over <span class="number">64</span>s)  kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    <span class="number">6</span>s (x3 over <span class="number">63</span>s)  kubelet, node1     Started container nginx</span><br><span class="line">  Warning  Unhealthy  <span class="number">6</span>s (x6 over <span class="number">56</span>s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: <span class="number">404</span></span><br><span class="line">  Normal   Killing    <span class="number">6</span>s (x2 over <span class="number">36</span>s)  kubelet, node1     Container nginx failed liveness probe, will be restarted</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 观察上面信息，尝试访问路径，但是未找到,出现404错误</span></span><br><span class="line"><span class="comment"># 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-liveness-httpget -n dev</span></span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-liveness-httpget</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">5</span>          <span class="number">3</span>m17s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然接下来，可以修改成一个可以访问的路径path，比如/，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p>至此，已经使用liveness Probe演示了三种探测方式，但是查看livenessProbe的子属性，会发现除了这三种方式，还有一些其他的配置，在这里一并解释下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.spec.containers.livenessProbe</span></span><br><span class="line">FIELDS:</span><br><span class="line">   exec &lt;Object&gt;  </span><br><span class="line">   tcpSocket    &lt;Object&gt;</span><br><span class="line">   httpGet      &lt;Object&gt;</span><br><span class="line">   initialDelaySeconds  &lt;integer&gt;  <span class="comment"># 容器启动后等待多少秒执行第一次探测</span></span><br><span class="line">   timeoutSeconds       &lt;integer&gt;  <span class="comment"># 探测超时时间。默认1秒，最小1秒</span></span><br><span class="line">   periodSeconds        &lt;integer&gt;  <span class="comment"># 执行探测的频率。默认是10秒，最小1秒</span></span><br><span class="line">   failureThreshold     &lt;integer&gt;  <span class="comment"># 连续探测失败多少次才被认定为失败。默认是3。最小值是1</span></span><br><span class="line">   successThreshold     &lt;integer&gt;  <span class="comment"># 连续探测成功多少次才被认定为成功。默认是1</span></span><br></pre></td></tr></table></figure>

<p>下面稍微配置两个，演示下效果即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@master</span> <span class="string">~</span>]<span class="comment"># more pod-liveness-httpget.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-httpget</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">30</span> <span class="comment"># 容器启动后30s开始探测</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">5</span> <span class="comment"># 探测超时时间为5s</span></span><br></pre></td></tr></table></figure>

<h3 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h3><p>在上一节中，一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由pod的重启策略决定的，pod的重启策略有 3 种，分别如下：</p>
<ul>
<li><p>Always ：容器失效时，自动重启该容器，这也是默认值。</p>
</li>
<li><p>OnFailure ： 容器终止运行且退出码不为0时重启</p>
</li>
<li><p>Never ： 不论状态为何，都不重启该容器</p>
<p>重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p>
</li>
</ul>
<p>创建pod-restartpolicy.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-restartpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/hello</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 设置重启策略为Never</span></span><br></pre></td></tr></table></figure>

<p>运行Pod测试</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-restartpolicy.yaml</span></span><br><span class="line">pod/pod<span class="literal">-restartpolicy</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详情，发现nginx容器失败</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  describe pods pod-restartpolicy  -n dev</span></span><br><span class="line">......</span><br><span class="line">  Warning  Unhealthy  <span class="number">15</span>s (x3 over <span class="number">35</span>s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: <span class="number">404</span></span><br><span class="line">  Normal   Killing    <span class="number">15</span>s                kubelet, node1     Container nginx failed liveness probe</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 多等一会，再观察pod的重启次数，发现一直是0，并未重启   </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  get pods pod-restartpolicy -n dev</span></span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-restartpolicy</span>      <span class="number">0</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>min42s</span><br></pre></td></tr></table></figure>

<h2 id="Pod调度"><a href="#Pod调度" class="headerlink" title="Pod调度"></a>Pod调度</h2><p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做呢？这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式：</p>
<ul>
<li>自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出</li>
<li>定向调度：NodeName、NodeSelector</li>
<li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity</li>
<li>污点（容忍）调度：Taints、Toleration</li>
</ul>
<h3 id="定向调度"><a href="#定向调度" class="headerlink" title="定向调度"></a>定向调度</h3><p>定向调度，指的是利用在pod上声明nodeName或者nodeSelector，以此将Pod调度到期望的node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过pod运行失败而已。</p>
<p><strong>NodeName</strong></p>
<p>NodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。</p>
<p>接下来，实验一下：创建一个pod-nodename.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodename</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node1</span> <span class="comment"># 指定调度到node1节点上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodename.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodename</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pod调度到NODE属性，确实是调度到了node1节点上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodename -n dev -o wide</span></span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE   IP            NODE      ......</span><br><span class="line">pod<span class="literal">-nodename</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">56</span>s   <span class="number">10.244</span>.<span class="number">1.87</span>   node1     ......   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，删除pod，修改nodeName的值为node3（并没有node3节点）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pod-nodename.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-nodename&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-nodename.yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodename.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodename</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次查看，发现已经向Node3节点调度，但是由于不存在node3节点，所以pod无法正常运行</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodename -n dev -o wide</span></span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE   IP       NODE    ......</span><br><span class="line">pod<span class="literal">-nodename</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">6</span>s    &lt;none&gt;   node3   ......           </span><br></pre></td></tr></table></figure>

<p><strong>NodeSelector</strong></p>
<p>NodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现的，也就是说，在pod创建之前，会由scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将pod调度到目标节点，该匹配规则是强制约束。</p>
<p>接下来，实验一下：</p>
<p>1 首先分别为node节点添加标签</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label nodes node1 nodeenv=pro</span></span><br><span class="line">node/node2 labeled</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label nodes node2 nodeenv=test</span></span><br><span class="line">node/node2 labeled</span><br></pre></td></tr></table></figure>

<p>2 创建一个pod-nodeselector.yaml文件，并使用它创建Pod</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeselector</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> </span><br><span class="line">    <span class="attr">nodeenv:</span> <span class="string">pro</span> <span class="comment"># 指定调度到具有nodeenv=pro标签的节点上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeselector.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeselector</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pod调度到NODE属性，确实是调度到了node1节点上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodeselector -n dev -o wide</span></span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE     IP          NODE    ......</span><br><span class="line">pod<span class="literal">-nodeselector</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">47</span>s   <span class="number">10.244</span>.<span class="number">1.87</span>   node1   ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，删除pod，修改nodeSelector的值为nodeenv: xxxx（不存在打有此标签的节点）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pod-nodeselector.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-nodeselector&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-nodeselector.yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeselector.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeselector</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次查看，发现pod无法正常运行,Node的值为none</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE     IP       NODE    </span><br><span class="line">pod<span class="literal">-nodeselector</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">2</span>m20s   &lt;none&gt;   &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情,发现node selector匹配失败的提示</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pods pod-nodeselector -n dev</span></span><br><span class="line">.......</span><br><span class="line">Events:</span><br><span class="line">  <span class="built_in">Type</span>     Reason            Age        From               Message</span><br><span class="line">  <span class="literal">----</span>     <span class="literal">------</span>            <span class="literal">----</span>       <span class="literal">----</span>               <span class="literal">-------</span></span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default<span class="literal">-scheduler</span>  <span class="number">0</span>/<span class="number">3</span> nodes are available: <span class="number">3</span> node(s) didn<span class="string">&#x27;t match node selector.</span></span><br><span class="line"><span class="string">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;</span>t match node selector.</span><br></pre></td></tr></table></figure>

<h3 id="亲和性调度"><a href="#亲和性调度" class="headerlink" title="亲和性调度"></a>亲和性调度</h3><p>上一节，介绍了两种定向调度的方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用Node列表也不行，这就限制了它的使用场景。</p>
<p>基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。它在NodeSelector的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。</p>
<p>Affinity主要分为三类：</p>
<ul>
<li><p>nodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题</p>
</li>
<li><p>podAffinity(pod亲和性) :  以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题</p>
</li>
<li><p>podAntiAffinity(pod反亲和性) :  以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题</p>
</li>
</ul>
<blockquote>
<p>关于亲和性(反亲和性)使用场景的说明：</p>
<p><strong>亲和性</strong>：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。</p>
<p><strong>反亲和性</strong>：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用性。</p>
</blockquote>
<p><strong>NodeAffinity</strong></p>
<p>首先来看一下<code>NodeAffinity</code>的可配置项：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">pod.spec.affinity.nodeAffinity</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution  Node节点必须满足指定的所有规则才可以，相当于硬限制</span><br><span class="line"><span class="code">    nodeSelectorTerms  节点选择列表</span></span><br><span class="line"><span class="code">      matchFields   按节点字段列出的节点选择器要求列表</span></span><br><span class="line"><span class="code">      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持Exists, DoesNotExist, In, NotIn, Gt, Lt</span></span><br><span class="line"><span class="code">  preferredDuringSchedulingIgnoredDuringExecution 优先调度到满足指定的规则的Node，相当于软限制 (倾向)</span></span><br><span class="line"><span class="code">    preference   一个节点选择器项，与相应的权重相关联</span></span><br><span class="line"><span class="code">      matchFields   按节点字段列出的节点选择器要求列表</span></span><br><span class="line"><span class="code">      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持In, NotIn, Exists, DoesNotExist, Gt, Lt</span></span><br><span class="line"><span class="code">	weight 倾向权重，在范围1-100。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">关系符的使用说明:</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> matchExpressions:</span><br><span class="line"><span class="bullet">  -</span> key: nodeenv              # 匹配存在标签的key为nodeenv的节点</span><br><span class="line"><span class="code">    operator: Exists</span></span><br><span class="line"><span class="code">  - key: nodeenv              # 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span></span><br><span class="line"><span class="code">    operator: In</span></span><br><span class="line"><span class="code">    values: [&quot;xxx&quot;,&quot;yyy&quot;]</span></span><br><span class="line"><span class="code">  - key: nodeenv              # 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点</span></span><br><span class="line"><span class="code">    operator: Gt</span></span><br><span class="line"><span class="code">    values: &quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来首先演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建pod-nodeaffinity-required.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment">#设置node亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状态 （运行失败）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodeaffinity-required -n dev -o wide</span></span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP       NODE    ...... </span><br><span class="line">pod<span class="literal">-nodeaffinity-required</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">16</span>s   &lt;none&gt;   &lt;none&gt;  ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod的详情</span></span><br><span class="line"><span class="comment"># 发现调度失败，提示node选择失败</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pod pod-nodeaffinity-required -n dev</span></span><br><span class="line">......</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default<span class="literal">-scheduler</span>  <span class="number">0</span>/<span class="number">3</span> nodes are available: <span class="number">3</span> node(s) didn<span class="string">&#x27;t match node selector.</span></span><br><span class="line"><span class="string">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;</span>t match node selector.</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来，停止pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pod-nodeaffinity-required.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-nodeaffinity-required&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件，将values: [&quot;xxx&quot;,&quot;yyy&quot;]------&gt; [&quot;pro&quot;,&quot;yyy&quot;]</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-nodeaffinity-required.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次启动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时查看，发现调度成功，已经将pod调度到了node1上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodeaffinity-required -n dev -o wide</span></span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP            NODE  ...... </span><br><span class="line">pod<span class="literal">-nodeaffinity-required</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">11</span>s   <span class="number">10.244</span>.<span class="number">1.89</span>   node1 ......</span><br></pre></td></tr></table></figure>

<p>接下来再演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建pod-nodeaffinity-preferred.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-preferred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment">#设置node亲和性</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 软限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeaffinity-preferred.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeaffinity-preferred</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状态 （运行成功）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-nodeaffinity-preferred -n dev</span></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-nodeaffinity-preferred</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">40</span>s</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">NodeAffinity规则设置的注意事项：</span><br><span class="line"><span class="code">    1 如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都得到满足，Pod才能运行在指定的Node上</span></span><br><span class="line"><span class="code">    2 如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可</span></span><br><span class="line"><span class="code">    3 如果一个nodeSelectorTerms中有多个matchExpressions ，则一个节点必须满足所有的才能匹配成功</span></span><br><span class="line"><span class="code">    4 如果一个pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的节点亲和性需求，则系统将忽略此变化</span></span><br></pre></td></tr></table></figure>

<p><strong>PodAffinity</strong></p>
<p>PodAffinity主要实现以运行的Pod为参照，实现让新创建的Pod跟参照pod在一个区域的功能。</p>
<p>首先来看一下<code>PodAffinity</code>的可配置项：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">pod.spec.affinity.podAffinity</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution  硬限制</span><br><span class="line"><span class="code">    namespaces       指定参照pod的namespace</span></span><br><span class="line"><span class="code">    topologyKey      指定调度作用域</span></span><br><span class="line"><span class="code">    labelSelector    标签选择器</span></span><br><span class="line"><span class="code">      matchExpressions  按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持In, NotIn, Exists, DoesNotExist.</span></span><br><span class="line"><span class="code">      matchLabels    指多个matchExpressions映射的内容</span></span><br><span class="line"><span class="code">  preferredDuringSchedulingIgnoredDuringExecution 软限制</span></span><br><span class="line"><span class="code">    podAffinityTerm  选项</span></span><br><span class="line"><span class="code">      namespaces      </span></span><br><span class="line"><span class="code">      topologyKey</span></span><br><span class="line"><span class="code">      labelSelector</span></span><br><span class="line"><span class="code">        matchExpressions  </span></span><br><span class="line"><span class="code">          key    键</span></span><br><span class="line"><span class="code">          values 值</span></span><br><span class="line"><span class="code">          operator</span></span><br><span class="line"><span class="code">        matchLabels </span></span><br><span class="line"><span class="code">    weight 倾向权重，在范围1-100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">topologyKey用于指定调度时作用域,例如:</span><br><span class="line"><span class="code">    如果指定为kubernetes.io/hostname，那就是以Node节点为区分范围</span></span><br><span class="line"><span class="code">	如果指定为beta.kubernetes.io/os,则以Node节点的操作系统类型来区分</span></span><br></pre></td></tr></table></figure>

<p>接下来，演示下<code>requiredDuringSchedulingIgnoredDuringExecution</code>,</p>
<p>1）首先创建一个参照Pod，pod-podaffinity-target.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-target</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">podenv:</span> <span class="string">pro</span> <span class="comment">#设置标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node1</span> <span class="comment"># 将目标pod名确指定到node1上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动目标pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-podaffinity-target.yaml</span></span><br><span class="line">pod/pod<span class="literal">-podaffinity-target</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods  pod-podaffinity-target -n dev</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-podaffinity-target</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">4</span>s</span><br></pre></td></tr></table></figure>

<p>2）创建pod-podaffinity-required.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">podAffinity:</span> <span class="comment">#设置pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;xxx或者nodeenv&#x3D;yyy的pod在同一Node上，显然现在没有这样pod，接下来，运行测试一下。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-podaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-podaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状态，发现未运行</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-podaffinity-required -n dev</span></span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-podaffinity-required</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">9</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详细信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pods pod-podaffinity-required  -n dev</span></span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  <span class="built_in">Type</span>     Reason            Age        From               Message</span><br><span class="line">  <span class="literal">----</span>     <span class="literal">------</span>            <span class="literal">----</span>       <span class="literal">----</span>               <span class="literal">-------</span></span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default<span class="literal">-scheduler</span>  <span class="number">0</span>/<span class="number">3</span> nodes are available: <span class="number">2</span> node(s) didn<span class="string">&#x27;t match pod affinity rules, 1 node(s) had taints that the pod didn&#x27;</span>t tolerate.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来修改  values: [&quot;xxx&quot;,&quot;yyy&quot;]-----&gt;values:[&quot;pro&quot;,&quot;yyy&quot;]</span></span><br><span class="line"><span class="comment"># 意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-podaffinity-required.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后重新创建pod，查看效果</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f  pod-podaffinity-required.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-podaffinity-required&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-podaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-podaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现此时Pod运行正常</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-podaffinity-required -n dev</span></span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">pod<span class="literal">-podaffinity-required</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">6</span>s    &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>关于<code>PodAffinity</code>的 <code>preferredDuringSchedulingIgnoredDuringExecution</code>，这里不再演示。</p>
<p><strong>PodAntiAffinity</strong></p>
<p>PodAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod跟参照pod不在一个区域中的功能。</p>
<p>它的配置方式和选项跟PodAffinty是一样的，这里不再做详细解释，直接做一个测试案例。</p>
<p>1）继续使用上个案例中目标pod</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide --show-labels</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE    LABELS</span><br><span class="line">pod<span class="literal">-podaffinity-required</span> <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">3</span>m29s   <span class="number">10.244</span>.<span class="number">1.38</span>   node1   &lt;none&gt;     </span><br><span class="line">pod<span class="literal">-podaffinity-target</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">9</span>m25s   <span class="number">10.244</span>.<span class="number">1.37</span>   node1   podenv=pro</span><br></pre></td></tr></table></figure>

<p>2）创建pod-podantiaffinity-required.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podantiaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span> <span class="comment">#设置pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配podenv的值在[&quot;pro&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;pro&quot;</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;pro的pod不在同一Node上，运行测试一下。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-podantiaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-podantiaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line"><span class="comment"># 发现调度到了node2上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-podantiaffinity-required -n dev -o wide</span></span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE   IP            NODE   .. </span><br><span class="line">pod<span class="literal">-podantiaffinity-required</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">30</span>s   <span class="number">10.244</span>.<span class="number">1.96</span>   node2  ..</span><br></pre></td></tr></table></figure>

<h3 id="污点和容忍"><a href="#污点和容忍" class="headerlink" title="污点和容忍"></a>污点和容忍</h3><p><strong>污点（Taints）</strong></p>
<p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加<strong>污点</strong>属性，来决定是否允许Pod调度过来。</p>
<p>Node被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。</p>
<p>污点的格式为：<code>key=value:effect</code>, key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p>
<ul>
<li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li>
<li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li>
<li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200605021606508.png" alt="image-20200605021606508"></p>
<p>使用kubectl设置和去除污点的命令示例如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置污点</span></span><br><span class="line">kubectl taint nodes node1 key=value:effect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除污点</span></span><br><span class="line">kubectl taint nodes node1 key:effect-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除所有污点</span></span><br><span class="line">kubectl taint nodes node1 key-</span><br></pre></td></tr></table></figure>

<p>接下来，演示下污点的效果：</p>
<ol>
<li>准备节点node1（为了演示效果更加明显，暂时停止node2节点）</li>
<li>为node1节点设置一个污点: <code>tag=heima:PreferNoSchedule</code>；然后创建pod1( pod1 可以 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoSchedule</code>；然后创建pod2( pod1 正常  pod2 失败 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoExecute</code>；然后创建pod3 ( 3个pod都失败 )</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为node1设置污点(PreferNoSchedule)</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag=heima:PreferNoSchedule</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建pod1</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run taint1 --image=nginx:1.17.1 -n dev</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE     IP           NODE   </span><br><span class="line">taint1<span class="literal">-7665f7fd85-574h4</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>m24s   <span class="number">10.244</span>.<span class="number">1.59</span>   node1    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为node1设置污点(取消PreferNoSchedule，设置NoSchedule)</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag:PreferNoSchedule-</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag=heima:NoSchedule</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建pod2</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run taint2 --image=nginx:1.17.1 -n dev</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods taint2 -n dev -o wide</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE     IP            NODE</span><br><span class="line">taint1<span class="literal">-7665f7fd85-574h4</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>m24s   <span class="number">10.244</span>.<span class="number">1.59</span>   node1 </span><br><span class="line">taint2<span class="literal">-544694789-6zmlf</span>    <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">21</span>s     &lt;none&gt;        &lt;none&gt;   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为node1设置污点(取消NoSchedule，设置NoExecute)</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag:NoSchedule-</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag=heima:NoExecute</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建pod3</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run taint3 --image=nginx:1.17.1 -n dev</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED </span><br><span class="line">taint1<span class="literal">-7665f7fd85-htkmp</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">35</span>s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;    </span><br><span class="line">taint2<span class="literal">-544694789-bn7wb</span>    <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">35</span>s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     </span><br><span class="line">taint3<span class="literal">-6d78dbd749-tktkq</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">6</span>s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     </span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">小提示：</span><br><span class="line"><span class="code">    使用kubeadm搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上.</span></span><br></pre></td></tr></table></figure>

<p><strong>容忍（Toleration）</strong></p>
<p>上面介绍了污点的作用，我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到<strong>容忍</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200514095913741.png" alt="image-20200514095913741"></p>
<blockquote>
<p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝pod调度上去，Pod通过容忍忽略拒绝</p>
</blockquote>
<p>下面先通过一个案例看下效果：</p>
<ol>
<li>上一小节，已经在node1节点上打上了<code>NoExecute</code>的污点，此时pod是调度不上去的</li>
<li>本小节，可以通过给pod添加容忍，然后将其调度上去</li>
</ol>
<p>创建pod-toleration.yaml,内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-toleration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">tolerations:</span>      <span class="comment"># 添加容忍</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span>        <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span> <span class="comment"># 操作符</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;heima&quot;</span>    <span class="comment"># 容忍的污点的value</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">&quot;NoExecute&quot;</span>   <span class="comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加容忍之前的pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED </span><br><span class="line">pod<span class="literal">-toleration</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">3</span>s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加容忍之后的pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED</span><br><span class="line">pod<span class="literal">-toleration</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">3</span>s    <span class="number">10.244</span>.<span class="number">1.62</span>   node1   &lt;none&gt;        </span><br></pre></td></tr></table></figure>

<p>下面看一下容忍的详细配置:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.spec.tolerations</span></span><br><span class="line">......</span><br><span class="line">FIELDS:</span><br><span class="line">   key       <span class="comment"># 对应着要容忍的污点的键，空意味着匹配所有的键</span></span><br><span class="line">   value     <span class="comment"># 对应着要容忍的污点的值</span></span><br><span class="line">   operator  <span class="comment"># key-value的运算符，支持Equal和Exists（默认）</span></span><br><span class="line">   effect    <span class="comment"># 对应污点的effect，空意味着匹配所有影响</span></span><br><span class="line">   tolerationSeconds   <span class="comment"># 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间</span></span><br></pre></td></tr></table></figure>

<h1 id="第六章-Pod控制器详解"><a href="#第六章-Pod控制器详解" class="headerlink" title="第六章 Pod控制器详解"></a>第六章 Pod控制器详解</h1><p>本章节主要介绍各种Pod控制器的详细使用。</p>
<h2 id="Pod控制器介绍"><a href="#Pod控制器介绍" class="headerlink" title="Pod控制器介绍"></a>Pod控制器介绍</h2><p>Pod是kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：</p>
<ul>
<li><p>自主式pod：kubernetes直接创建出来的Pod，这种pod删除后就没有了，也不会重建</p>
</li>
<li><p>控制器创建的pod：kubernetes通过控制器创建的pod，这种pod删除了之后还会自动重建</p>
</li>
</ul>
<blockquote>
<p><strong><code>什么是Pod控制器</code></strong></p>
<p>Pod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。</p>
</blockquote>
<p>在kubernetes中，有很多类型的pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p>
<ul>
<li><p>ReplicationController：比较原始的pod控制器，已经被废弃，由ReplicaSet替代</p>
</li>
<li><p>ReplicaSet：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级</p>
</li>
<li><p>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本</p>
</li>
<li><p>Horizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷</p>
</li>
<li><p>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务</p>
</li>
<li><p>Job：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务</p>
</li>
<li><p>Cronjob：它创建的Pod负责周期性任务控制，不需要持续后台运行</p>
</li>
<li><p>StatefulSet：管理有状态应用</p>
</li>
</ul>
<h2 id="ReplicaSet-RS"><a href="#ReplicaSet-RS" class="headerlink" title="ReplicaSet(RS)"></a>ReplicaSet(RS)</h2><p>ReplicaSet的主要作用是<strong>保证一定数量的pod正常运行</strong>，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200612005334159.png"></p>
<p>ReplicaSet的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">rs</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>在这里面，需要新了解的配置项就是<code>spec</code>下面几个选项：</p>
<ul>
<li><p>replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</p>
</li>
<li><p>selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</p>
</li>
<li><p>template：模板，就是当前控制器创建pod所使用的模板板，里面其实就是前一章学过的pod的定义</p>
</li>
</ul>
<p><strong>创建ReplicaSet</strong></p>
<p>创建pc-replicaset.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span>   </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-replicaset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建rs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pc-replicaset.yaml</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看rs</span></span><br><span class="line"><span class="comment"># DESIRED:期望副本数量  </span></span><br><span class="line"><span class="comment"># CURRENT:当前副本数量  </span></span><br><span class="line"><span class="comment"># READY:已经准备好提供服务的副本数量</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs pc-replicaset -n dev -o wide</span></span><br><span class="line">NAME          DESIRED   CURRENT READY AGE   CONTAINERS   IMAGES             SELECTOR</span><br><span class="line">pc<span class="literal">-replicaset</span> <span class="number">3</span>         <span class="number">3</span>       <span class="number">3</span>     <span class="number">22</span>s   nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>       app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前控制器创建出来的pod</span></span><br><span class="line"><span class="comment"># 这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev</span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-6vmvt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">54</span>s</span><br><span class="line">pc<span class="literal">-replicaset-fmb8f</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">54</span>s</span><br><span class="line">pc<span class="literal">-replicaset-snrk2</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">54</span>s</span><br></pre></td></tr></table></figure>

<p><strong>扩缩容</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑rs的副本数量，修改spec:replicas: 6即可</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl edit rs pc-replicaset -n dev</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> edited</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-6vmvt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">114</span>m</span><br><span class="line">pc<span class="literal">-replicaset-cftnp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">10</span>s</span><br><span class="line">pc<span class="literal">-replicaset-fjlm6</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">10</span>s</span><br><span class="line">pc<span class="literal">-replicaset-fmb8f</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">114</span>m</span><br><span class="line">pc<span class="literal">-replicaset-s2whj</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">10</span>s</span><br><span class="line">pc<span class="literal">-replicaset-snrk2</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">114</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然也可以直接使用命令实现</span></span><br><span class="line"><span class="comment"># 使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl scale rs pc-replicaset --replicas=2 -n dev</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> scaled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令运行完毕，立即查看，发现已经有4个开始准备退出了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                       READY   STATUS        RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-6vmvt</span>   <span class="number">0</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">118</span>m</span><br><span class="line">pc<span class="literal">-replicaset-cftnp</span>   <span class="number">0</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">4</span>m17s</span><br><span class="line">pc<span class="literal">-replicaset-fjlm6</span>   <span class="number">0</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">4</span>m17s</span><br><span class="line">pc<span class="literal">-replicaset-fmb8f</span>   <span class="number">1</span>/<span class="number">1</span>     Running       <span class="number">0</span>          <span class="number">118</span>m</span><br><span class="line">pc<span class="literal">-replicaset-s2whj</span>   <span class="number">0</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">4</span>m17s</span><br><span class="line">pc<span class="literal">-replicaset-snrk2</span>   <span class="number">1</span>/<span class="number">1</span>     Running       <span class="number">0</span>          <span class="number">118</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment">#稍等片刻，就只剩下2个了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-fmb8f</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">119</span>m</span><br><span class="line">pc<span class="literal">-replicaset-snrk2</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">119</span>m</span><br></pre></td></tr></table></figure>

<p><strong>镜像升级</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑rs的容器镜像 - image: nginx:1.17.2</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl edit rs pc-replicaset -n dev</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> edited</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看，发现镜像版本已经变更了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev -o wide</span></span><br><span class="line">NAME                DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES        ...</span><br><span class="line">pc<span class="literal">-replicaset</span>       <span class="number">2</span>        <span class="number">2</span>         <span class="number">2</span>       <span class="number">140</span>m   nginx         nginx:<span class="number">1.17</span>.<span class="number">2</span>  ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样的道理，也可以使用命令完成这个工作</span></span><br><span class="line"><span class="comment"># kubectl set image rs rs名称 容器=镜像版本 -n namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl set image rs pc-replicaset nginx=nginx:1.17.1  -n dev</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> image updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看，发现镜像版本已经变更了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev -o wide</span></span><br><span class="line">NAME                 DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES            ...</span><br><span class="line">pc<span class="literal">-replicaset</span>        <span class="number">2</span>        <span class="number">2</span>         <span class="number">2</span>       <span class="number">145</span>m   nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span> ... </span><br></pre></td></tr></table></figure>

<p><strong>删除ReplicaSet</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用kubectl delete命令会删除此RS以及它管理的Pod</span></span><br><span class="line"><span class="comment"># 在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete rs pc-replicaset -n dev</span></span><br><span class="line">replicaset.apps <span class="string">&quot;pc-replicaset&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev -o wide</span></span><br><span class="line">No resources found <span class="keyword">in</span> dev namespace.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade=false选项（不推荐）。</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete rs pc-replicaset -n dev --cascade=false</span></span><br><span class="line">replicaset.apps <span class="string">&quot;pc-replicaset&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-cl82j</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">75</span>s</span><br><span class="line">pc<span class="literal">-replicaset-dslhb</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">75</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用yaml直接删除(推荐)</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pc-replicaset.yaml</span></span><br><span class="line">replicaset.apps <span class="string">&quot;pc-replicaset&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="Deployment-Deploy"><a href="#Deployment-Deploy" class="headerlink" title="Deployment(Deploy)"></a>Deployment(Deploy)</h2><p>为了更好的解决服务编排的问题，kubernetes在V1.2版本开始，引入了Deployment控制器。值得一提的是，这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment比ReplicaSet功能更加强大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200612005524778.png"></p>
<p>Deployment主要功能有下面几个：</p>
<ul>
<li>支持ReplicaSet的所有功能</li>
<li>支持发布的停止、继续</li>
<li>支持滚动升级和回滚版本</li>
</ul>
<p>Deployment的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">paused:</span> <span class="literal">false</span> <span class="comment"># 暂停部署，默认是false</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span> <span class="comment"># 部署超时时间（s），默认是600</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong>创建deployment</strong></p>
<p>创建pc-deployment.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建deployment</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pc-deployment.yaml --record=true</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看deployment</span></span><br><span class="line"><span class="comment"># UP-TO-DATE 最新版本的pod的数量</span></span><br><span class="line"><span class="comment"># AVAILABLE  当前可用的pod的数量</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy pc-deployment -n dev</span></span><br><span class="line">NAME            READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">pc<span class="literal">-deployment</span>   <span class="number">3</span>/<span class="number">3</span>     <span class="number">3</span>            <span class="number">3</span>           <span class="number">15</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看rs</span></span><br><span class="line"><span class="comment"># 发现rs的名称是在原来deployment的名字后面添加了一个10位数的随机串</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev</span></span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">23</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-d2c8n</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">107</span>s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-smpvp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">107</span>s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-wvjd8</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">107</span>s</span><br></pre></td></tr></table></figure>

<p><strong>扩缩容</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变更副本数量为5个</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl scale deploy pc-deployment --replicas=5  -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> scaled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看deployment</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy pc-deployment -n dev</span></span><br><span class="line">NAME            READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">pc<span class="literal">-deployment</span>   <span class="number">5</span>/<span class="number">5</span>     <span class="number">5</span>            <span class="number">5</span>           <span class="number">2</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-d2c8n</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">4</span>m19s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-jxmdq</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">94</span>s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-mktqv</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">93</span>s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-smpvp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">4</span>m19s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-wvjd8</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">4</span>m19s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑deployment的副本数量，修改spec:replicas: 4即可</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl edit deploy pc-deployment -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> edited</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-d2c8n</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m23s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-jxmdq</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>m38s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-smpvp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m23s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-wvjd8</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m23s</span><br></pre></td></tr></table></figure>

<p><strong>镜像更新</strong></p>
<p>deployment支持两种更新策略:<code>重建更新</code>和<code>滚动更新</code>,可以通过<code>strategy</code>指定策略类型,支持两个属性:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">strategy：指定新的Pod替换旧的Pod的策略， 支持两个属性：</span><br><span class="line">  type：指定策略类型，支持两种策略</span><br><span class="line"><span class="code">    Recreate：在创建出新的Pod之前会先杀掉所有已存在的Pod</span></span><br><span class="line"><span class="code">    RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本Pod</span></span><br><span class="line"><span class="code">  rollingUpdate：当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：</span></span><br><span class="line"><span class="code">    maxUnavailable：用来指定在升级过程中不可用Pod的最大数量，默认为25%。</span></span><br><span class="line"><span class="code">    maxSurge： 用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。</span></span><br></pre></td></tr></table></figure>

<p>重建更新</p>
<ol>
<li>编辑pc-deployment.yaml,在spec节点下添加更新策略</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span> <span class="comment"># 重建更新</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建deploy进行验证</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变更镜像</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl set image deployment pc-deployment nginx=nginx:1.17.2 -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> image updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观察升级过程</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get pods -n dev -w</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-65qcw</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-w5nzv</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-xpt7w</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>s</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-xpt7w</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">41</span>s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-65qcw</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">41</span>s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-w5nzv</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">41</span>s</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-grn8z</span>   <span class="number">0</span>/<span class="number">1</span>     Pending       <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-hbl4v</span>   <span class="number">0</span>/<span class="number">1</span>     Pending       <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-67nz2</span>   <span class="number">0</span>/<span class="number">1</span>     Pending       <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-grn8z</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-hbl4v</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-67nz2</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-grn8z</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">1</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-67nz2</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">1</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-hbl4v</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br></pre></td></tr></table></figure>

<p>滚动更新</p>
<ol>
<li>编辑pc-deployment.yaml,在spec节点下添加更新策略</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span> </span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建deploy进行验证</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变更镜像</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl set image deployment pc-deployment nginx=nginx:1.17.3 -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> image updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观察升级过程</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -w</span></span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-c848d767-8rbzt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>m</span><br><span class="line">pc<span class="literal">-deployment-c848d767-h4p68</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>m</span><br><span class="line">pc<span class="literal">-deployment-c848d767-hlmz4</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>m</span><br><span class="line">pc<span class="literal">-deployment-c848d767-rrqcn</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>m</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-226rx</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-226rx</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-226rx</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">1</span>s</span><br><span class="line">pc<span class="literal">-deployment-c848d767-h4p68</span>    <span class="number">0</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">34</span>m</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-cnd44</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-cnd44</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-cnd44</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line">pc<span class="literal">-deployment-c848d767-hlmz4</span>    <span class="number">0</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">34</span>m</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-px48p</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-px48p</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-px48p</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-c848d767-8rbzt</span>    <span class="number">0</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">34</span>m</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-dkmqp</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-dkmqp</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-dkmqp</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line">pc<span class="literal">-deployment-c848d767-rrqcn</span>    <span class="number">0</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">34</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 至此，新版本的pod创建完毕，就版本的pod销毁完毕</span></span><br><span class="line"><span class="comment"># 中间过程是滚动进行的，也就是边销毁边创建</span></span><br></pre></td></tr></table></figure>

<p>滚动更新的过程：</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200416140251491.png" style="border:1px solid;" />

<p>镜像更新中rs的变化:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看rs,发现原来的rs的依旧存在，只是pod数量变为了0，而后又新产生了一个rs，pod数量为4</span></span><br><span class="line"><span class="comment"># 其实这就是deployment能够进行版本回退的奥妙所在，后面会详细解释</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev</span></span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">7</span>m37s</span><br><span class="line">pc<span class="literal">-deployment-6696798b11</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">5</span>m37s</span><br><span class="line">pc<span class="literal">-deployment-c848d76789</span>   <span class="number">4</span>         <span class="number">4</span>         <span class="number">4</span>       <span class="number">72</span>s</span><br></pre></td></tr></table></figure>

<p><strong>版本回退</strong></p>
<p>deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.</p>
<p>kubectl rollout： 版本升级相关功能，支持下面的选项：</p>
<ul>
<li><p>status       显示当前升级状态</p>
</li>
<li><p>history     显示 升级历史记录</p>
</li>
<li><p>pause       暂停版本升级过程</p>
</li>
<li><p>resume    继续已经暂停的版本升级过程</p>
</li>
<li><p>restart      重启版本升级过程</p>
</li>
<li><p>undo        回滚到上一级版本（可以使用–to-revision回滚到指定版本）</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前升级版本的状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl rollout status deploy pc-deployment -n dev</span></span><br><span class="line">deployment <span class="string">&quot;pc-deployment&quot;</span> successfully rolled out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看升级历史记录</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl rollout history deploy pc-deployment -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span></span><br><span class="line">REVISION  CHANGE<span class="literal">-CAUSE</span></span><br><span class="line"><span class="number">1</span>         kubectl create <span class="literal">--filename</span>=pc<span class="literal">-deployment</span>.yaml <span class="literal">--record</span>=true</span><br><span class="line"><span class="number">2</span>         kubectl create <span class="literal">--filename</span>=pc<span class="literal">-deployment</span>.yaml <span class="literal">--record</span>=true</span><br><span class="line"><span class="number">3</span>         kubectl create <span class="literal">--filename</span>=pc<span class="literal">-deployment</span>.yaml <span class="literal">--record</span>=true</span><br><span class="line"><span class="comment"># 可以发现有三次版本记录，说明完成过两次升级</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本回滚</span></span><br><span class="line"><span class="comment"># 这里直接使用--to-revision=1回滚到了1版本， 如果省略这个选项，就是回退到上个版本，就是2版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl rollout undo deployment pc-deployment --to-revision=1 -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> rolled back</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看发现，通过nginx镜像版本可以发现到了第一版</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy -n dev -o wide</span></span><br><span class="line">NAME            READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE   CONTAINERS   IMAGES         </span><br><span class="line">pc<span class="literal">-deployment</span>   <span class="number">4</span>/<span class="number">4</span>     <span class="number">4</span>            <span class="number">4</span>           <span class="number">74</span>m   nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行</span></span><br><span class="line"><span class="comment"># 其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，</span></span><br><span class="line"><span class="comment"># 一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev</span></span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78</span>   <span class="number">4</span>         <span class="number">4</span>         <span class="number">4</span>       <span class="number">78</span>m</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44</span>    <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">37</span>m</span><br><span class="line">pc<span class="literal">-deployment-c848d767</span>     <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">71</span>m</span><br></pre></td></tr></table></figure>

<p><strong>金丝雀发布</strong></p>
<p>Deployment控制器支持控制更新过程中的控制，如“暂停(pause)”或“继续(resume)”更新操作。</p>
<p>比如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新deployment的版本，并配置暂停deployment</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl set image deploy pc-deployment nginx=nginx:1.17.4 -n dev &amp;&amp; kubectl rollout pause deployment pc-deployment  -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> image updated</span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> paused</span><br><span class="line"></span><br><span class="line"><span class="comment">#观察更新状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl rollout status deploy pc-deployment -n dev　</span></span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">&quot;pc-deployment&quot;</span> rollout to finish: <span class="number">2</span> out of <span class="number">4</span> new replicas have been updated...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令</span></span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev -o wide</span></span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         </span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">19</span>m     nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>   </span><br><span class="line">pc<span class="literal">-deployment-675d469f8b</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">14</span>m     nginx        nginx:<span class="number">1.17</span>.<span class="number">2</span>   </span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb</span>   <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>       <span class="number">3</span>m16s   nginx        nginx:<span class="number">1.17</span>.<span class="number">4</span>   </span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-rj8sq</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">7</span>m33s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-ttwgg</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">7</span>m35s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-v4wvc</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">7</span>m34s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-996rt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">3</span>m31s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-j2gtj</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">3</span>m31s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保更新的pod没问题了，继续更新</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl rollout resume deploy pc-deployment -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> resumed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最后的更新情况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev -o wide</span></span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         </span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">21</span>m     nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>   </span><br><span class="line">pc<span class="literal">-deployment-675d469f8b</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">16</span>m     nginx        nginx:<span class="number">1.17</span>.<span class="number">2</span>   </span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb</span>   <span class="number">4</span>         <span class="number">4</span>         <span class="number">4</span>       <span class="number">5</span>m11s   nginx        nginx:<span class="number">1.17</span>.<span class="number">4</span>   </span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-7bfwh</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">37</span>s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-996rt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m27s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-j2gtj</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m27s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-rf84v</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">37</span>s</span><br></pre></td></tr></table></figure>

<p><strong>删除Deployment</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除deployment，其下的rs和pod也将被删除</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pc-deployment.yaml</span></span><br><span class="line">deployment.apps <span class="string">&quot;pc-deployment&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="Horizontal-Pod-Autoscaler-HPA"><a href="#Horizontal-Pod-Autoscaler-HPA" class="headerlink" title="Horizontal Pod Autoscaler(HPA)"></a>Horizontal Pod Autoscaler(HPA)</h2><p>在前面的课程中，我们已经可以实现通过手工执行<code>kubectl scale</code>命令实现Pod扩容或缩容，但是这显然不符合Kubernetes的定位目标–自动化、智能化。 Kubernetes期望可以实现通过监测Pod的使用情况，实现pod数量的自动调整，于是就产生了Horizontal Pod Autoscaler（HPA）这种控制器。</p>
<p>HPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一种Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数，这是HPA的实现原理。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200608155858271.png" style="border:1px solid;" />

<p>接下来，我们来做一个实验</p>
<p><strong>1 安装metrics-server</strong></p>
<p>metrics-server可以用来收集集群中的资源使用情况</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install git -y</span></span><br><span class="line"><span class="comment"># 获取metrics-server, 注意使用的版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># git clone -b v0.3.6 https://github.com/kubernetes-incubator/metrics-server</span></span><br><span class="line"><span class="comment"># 修改deployment, 注意修改的是镜像和初始化参数</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cd /root/metrics-server/deploy/1.8+/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># vim metrics-server-deployment.yaml</span></span><br><span class="line">按图中添加下面选项</span><br><span class="line">hostNetwork: true</span><br><span class="line">image: registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/metrics<span class="literal">-server-amd64</span>:v0.<span class="number">3.6</span></span><br><span class="line">args:</span><br><span class="line">- <span class="literal">--kubelet-insecure-tls</span></span><br><span class="line">- <span class="literal">--kubelet-preferred-address-types</span>=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200608163326496.png" alt="image-20200608163326496"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装metrics-server</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl apply -f ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod运行情况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl get pod -n kube-system</span></span><br><span class="line">metrics<span class="literal">-server-6b976979db-2xwbj</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">90</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用kubectl top node 查看资源使用情况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl top node</span></span><br><span class="line">NAME     CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%</span><br><span class="line">master   <span class="number">98</span>m          <span class="number">4</span>%     <span class="number">1067</span><span class="built_in">Mi</span>          <span class="number">62</span>%</span><br><span class="line">node1    <span class="number">27</span>m          <span class="number">1</span>%     <span class="number">727</span><span class="built_in">Mi</span>           <span class="number">42</span>%</span><br><span class="line">node2    <span class="number">34</span>m          <span class="number">1</span>%     <span class="number">800</span><span class="built_in">Mi</span>           <span class="number">46</span>%</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl top pod -n kube-system</span></span><br><span class="line">NAME                              CPU(cores)   MEMORY(bytes)</span><br><span class="line">coredns<span class="literal">-6955765f44-7ptsb</span>          <span class="number">3</span>m           <span class="number">9</span><span class="built_in">Mi</span></span><br><span class="line">coredns<span class="literal">-6955765f44-vcwr5</span>          <span class="number">3</span>m           <span class="number">8</span><span class="built_in">Mi</span></span><br><span class="line">etcd<span class="literal">-master</span>                       <span class="number">14</span>m          <span class="number">145</span><span class="built_in">Mi</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 至此,metrics-server安装完成</span></span><br></pre></td></tr></table></figure>

<p><strong>2 准备deployment和servie</strong></p>
<p>为了操作简单,直接使用命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建deployment </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl run nginx --image=nginx:latest --requests=cpu=100m -n dev</span></span><br><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl expose deployment nginx --type=NodePort --port=80 -n dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl get deployment,pod,svc -n dev</span></span><br><span class="line">NAME                    READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">deployment.apps/nginx   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">47</span>s</span><br><span class="line"></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx<span class="literal">-7df9756ccc-bh8dr</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">47</span>s</span><br><span class="line"></span><br><span class="line">NAME            <span class="built_in">TYPE</span>       CLUSTER<span class="literal">-IP</span>      EXTERNAL<span class="literal">-IP</span>   PORT(S)        AGE</span><br><span class="line">service/nginx   NodePort   <span class="number">10.109</span>.<span class="number">57.248</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">31136</span>/TCP   <span class="number">35</span>s</span><br></pre></td></tr></table></figure>

<p><strong>3 部署HPA</strong></p>
<p>创建pc-hpa.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-hpa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span>  <span class="comment">#最小pod数量</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span> <span class="comment">#最大pod数量</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">3</span> <span class="comment"># CPU使用率指标</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>   <span class="comment"># 指定要控制的nginx信息</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建hpa</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl create -f pc-hpa.yaml</span></span><br><span class="line">horizontalpodautoscaler.autoscaling/pc<span class="literal">-hpa</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看hpa</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl get hpa -n dev</span></span><br><span class="line">NAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">62</span>s</span><br></pre></td></tr></table></figure>

<p><strong>4 测试</strong></p>
<p>使用压测工具对service地址<code>192.168.109.100:31136</code>进行压测，然后通过控制台查看hpa和pod的变化</p>
<p><code>hpa变化</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get hpa -n dev -w</span></span><br><span class="line">NAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">4</span>m11s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">5</span>m19s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">22</span>%/<span class="number">3</span>%    <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">6</span>m50s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">22</span>%/<span class="number">3</span>%    <span class="number">1</span>         <span class="number">10</span>        <span class="number">4</span>          <span class="number">7</span>m5s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">22</span>%/<span class="number">3</span>%    <span class="number">1</span>         <span class="number">10</span>        <span class="number">8</span>          <span class="number">7</span>m21s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">6</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">8</span>          <span class="number">7</span>m51s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">8</span>          <span class="number">9</span>m6s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">8</span>          <span class="number">13</span>m</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">14</span>m</span><br></pre></td></tr></table></figure>

<p><code>deployment变化</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deployment -n dev -w</span></span><br><span class="line">NAME    READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">11</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">4</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">13</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">4</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">13</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">4</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">13</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">4</span>     <span class="number">4</span>            <span class="number">1</span>           <span class="number">13</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">8</span>     <span class="number">4</span>            <span class="number">1</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">8</span>     <span class="number">4</span>            <span class="number">1</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">8</span>     <span class="number">4</span>            <span class="number">1</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">1</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">2</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">2</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">3</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">3</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">4</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">4</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">5</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">5</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">6</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">6</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">7</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">7</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">8</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">8</span>           <span class="number">15</span>m</span><br><span class="line">nginx   <span class="number">8</span>/<span class="number">1</span>     <span class="number">8</span>            <span class="number">8</span>           <span class="number">20</span>m</span><br><span class="line">nginx   <span class="number">8</span>/<span class="number">1</span>     <span class="number">8</span>            <span class="number">8</span>           <span class="number">20</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">20</span>m</span><br></pre></td></tr></table></figure>

<p><code>pod变化</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -w</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx<span class="literal">-7df9756ccc-bh8dr</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">11</span>m</span><br><span class="line">nginx<span class="literal">-7df9756ccc-cpgrv</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-8zhwk</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-rr9bn</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-cpgrv</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-8zhwk</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-rr9bn</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-m9gsj</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-g56qb</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-sl9c6</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-fgst7</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-g56qb</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-m9gsj</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-sl9c6</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-fgst7</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-8zhwk</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">19</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-rr9bn</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">30</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-m9gsj</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">21</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-cpgrv</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">47</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-sl9c6</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">33</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-g56qb</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">48</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-fgst7</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">66</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-fgst7</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">6</span>m50s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-8zhwk</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">7</span>m5s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-cpgrv</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">7</span>m5s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-g56qb</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">6</span>m50s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-rr9bn</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">7</span>m5s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-m9gsj</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">6</span>m50s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-sl9c6</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">6</span>m50s</span><br></pre></td></tr></table></figure>

<h2 id="DaemonSet-DS"><a href="#DaemonSet-DS" class="headerlink" title="DaemonSet(DS)"></a>DaemonSet(DS)</h2><p>DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200612010223537.png"></p>
<p>DaemonSet控制器的特点：</p>
<ul>
<li>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上</li>
<li>当节点从集群中移除时，Pod 也就被垃圾回收了</li>
</ul>
<p>下面先来看下DaemonSet的资源清单文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">daemonset</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">updateStrategy:</span> <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>创建pc-daemonset.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-daemonset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建daemonset</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f  pc-daemonset.yaml</span></span><br><span class="line">daemonset.apps/pc<span class="literal">-daemonset</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看daemonset</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get ds -n dev -o wide</span></span><br><span class="line">NAME        DESIRED  CURRENT  READY  UP<span class="literal">-TO-DATE</span>  AVAILABLE   AGE   CONTAINERS   IMAGES         </span><br><span class="line">pc<span class="literal">-daemonset</span>   <span class="number">2</span>        <span class="number">2</span>        <span class="number">2</span>      <span class="number">2</span>           <span class="number">2</span>        <span class="number">24</span>s   nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod,发现在每个Node上都运行一个pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME                 READY   STATUS    RESTARTS   AGE   IP            NODE    </span><br><span class="line">pc<span class="literal">-daemonset-9bck8</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">37</span>s   <span class="number">10.244</span>.<span class="number">1.43</span>   node1     </span><br><span class="line">pc<span class="literal">-daemonset-k224w</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">37</span>s   <span class="number">10.244</span>.<span class="number">2.74</span>   node2      </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除daemonset</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pc-daemonset.yaml</span></span><br><span class="line">daemonset.apps <span class="string">&quot;pc-daemonset&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>Job，主要用于负责**批量处理(一次要处理指定数量任务)<strong>短暂的</strong>一次性(每个任务仅运行一次就结束)**任务。Job特点如下：</p>
<ul>
<li>当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量</li>
<li>当成功结束的pod达到指定的数量时，Job将完成执行</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200618213054113.png" style />

<p>Job的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">job</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">1</span> <span class="comment"># 指定job需要成功运行Pods的次数。默认值: 1</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">1</span> <span class="comment"># 指定job在任一时刻应该并发运行Pods的数量。默认值: 1</span></span><br><span class="line">  <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span> <span class="comment"># 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">6</span> <span class="comment"># 指定job失败后进行重试的次数。默认是6</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span> <span class="comment"># 是否可以使用selector选择器选择pod，默认是false</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">counter-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略只能设置为Never或者OnFailure</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">关于重启策略设置的说明：</span><br><span class="line"><span class="code">    如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变</span></span><br><span class="line"><span class="code">    如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1</span></span><br><span class="line"><span class="code">    如果指定为Always的话，就意味着一直重启，意味着job任务会重复去执行了，当然不对，所以不能设置为Always</span></span><br></pre></td></tr></table></figure>

<p>创建pc-job.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-job</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建job</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pc-job.yaml</span></span><br><span class="line">job.batch/pc<span class="literal">-job</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看job</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get job -n dev -o wide  -w</span></span><br><span class="line">NAME     COMPLETIONS   DURATION   AGE   CONTAINERS   IMAGES         SELECTOR</span><br><span class="line">pc<span class="literal">-job</span>   <span class="number">0</span>/<span class="number">1</span>           <span class="number">21</span>s        <span class="number">21</span>s   counter      busybox:<span class="number">1.30</span>   app=counter<span class="literal">-pod</span></span><br><span class="line">pc<span class="literal">-job</span>   <span class="number">1</span>/<span class="number">1</span>           <span class="number">31</span>s        <span class="number">79</span>s   counter      busybox:<span class="number">1.30</span>   app=counter<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过观察pod状态可以看到，pod在运行完毕任务后，就会变成Completed状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -w</span></span><br><span class="line">NAME           READY   STATUS     RESTARTS      AGE</span><br><span class="line">pc<span class="literal">-job-rxg96</span>   <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>            <span class="number">29</span>s</span><br><span class="line">pc<span class="literal">-job-rxg96</span>   <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>            <span class="number">33</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，调整下pod运行的总数量和并行数量 即：在spec下设置下面两个选项</span></span><br><span class="line"><span class="comment">#  completions: 6 # 指定job需要成功运行Pods的次数为6</span></span><br><span class="line"><span class="comment">#  parallelism: 3 # 指定job并发运行Pods的数量为3</span></span><br><span class="line"><span class="comment">#  然后重新运行job，观察效果，此时会发现，job会每次运行3个pod，总共执行了6个pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -w</span></span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-job-684ft</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>s</span><br><span class="line">pc<span class="literal">-job-jhj49</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>s</span><br><span class="line">pc<span class="literal">-job-pfcvh</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>s</span><br><span class="line">pc<span class="literal">-job-684ft</span>   <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>          <span class="number">11</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">0</span>/<span class="number">1</span>     Pending     <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">0</span>/<span class="number">1</span>     Pending     <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-jhj49</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">11</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-pfcvh</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">11</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">3</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">12</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">12</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">12</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除job</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pc-job.yaml</span></span><br><span class="line">job.batch <span class="string">&quot;pc-job&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="CronJob-CJ"><a href="#CronJob-CJ" class="headerlink" title="CronJob(CJ)"></a>CronJob(CJ)</h2><p>CronJob控制器以Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行<strong>时间点</strong>及<strong>重复运行</strong>的方式。也就是说，<strong>CronJob可以在特定的时间点(反复的)去运行job任务</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200618213149531.png" style />

<p>CronJob的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="comment"># cron格式的作业调度运行时间点,用于控制任务在什么时间执行</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="comment"># 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业</span></span><br><span class="line">  <span class="attr">failedJobHistoryLimit:</span> <span class="comment"># 为失败的任务执行保留的历史记录数，默认为1</span></span><br><span class="line">  <span class="attr">successfulJobHistoryLimit:</span> <span class="comment"># 为成功的任务执行保留的历史记录数，默认为3</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="comment"># 启动作业错误的超时时长</span></span><br><span class="line">  <span class="attr">jobTemplate:</span> <span class="comment"># job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">completions:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">backoffLimit:</span> <span class="number">6</span></span><br><span class="line">      <span class="attr">manualSelector:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">matchExpressions:</span> <span class="string">规则</span></span><br><span class="line">          <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">counter-pod</span>]&#125;</span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">          <span class="attr">labels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span> </span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">需要重点解释的几个选项：</span><br><span class="line">schedule: cron表达式，用于指定任务的执行时间</span><br><span class="line"><span class="code">	*/1    *      *    *     *</span></span><br><span class="line"><span class="code">	&lt;分钟&gt; &lt;小时&gt; &lt;日&gt; &lt;月份&gt; &lt;星期&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    分钟 值从 0 到 59.</span></span><br><span class="line"><span class="code">    小时 值从 0 到 23.</span></span><br><span class="line"><span class="code">    日 值从 1 到 31.</span></span><br><span class="line"><span class="code">    月 值从 1 到 12.</span></span><br><span class="line"><span class="code">    星期 值从 0 到 6, 0 代表星期日</span></span><br><span class="line"><span class="code">    多个时间可以用逗号隔开； 范围可以用连字符给出；*可以作为通配符； /表示每...</span></span><br><span class="line"><span class="code">concurrencyPolicy:</span></span><br><span class="line"><span class="code">	Allow:   允许Jobs并发运行(默认)</span></span><br><span class="line"><span class="code">	Forbid:  禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行</span></span><br><span class="line"><span class="code">	Replace: 替换，取消当前正在运行的作业并用新作业替换它</span></span><br></pre></td></tr></table></figure>

<p>创建pc-cronjob.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-cronjob</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建cronjob</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pc-cronjob.yaml</span></span><br><span class="line">cronjob.batch/pc<span class="literal">-cronjob</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看cronjob</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get cronjobs -n dev</span></span><br><span class="line">NAME         SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">pc<span class="literal">-cronjob</span>   */<span class="number">1</span> * * * *   False     <span class="number">0</span>        &lt;none&gt;          <span class="number">6</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看job</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get jobs -n dev</span></span><br><span class="line">NAME                    COMPLETIONS   DURATION   AGE</span><br><span class="line">pc<span class="literal">-cronjob-1592587800</span>   <span class="number">1</span>/<span class="number">1</span>           <span class="number">28</span>s        <span class="number">3</span>m26s</span><br><span class="line">pc<span class="literal">-cronjob-1592587860</span>   <span class="number">1</span>/<span class="number">1</span>           <span class="number">28</span>s        <span class="number">2</span>m26s</span><br><span class="line">pc<span class="literal">-cronjob-1592587920</span>   <span class="number">1</span>/<span class="number">1</span>           <span class="number">28</span>s        <span class="number">86</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">pc<span class="literal">-cronjob-1592587800-x4tsm</span>   <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>          <span class="number">2</span>m24s</span><br><span class="line">pc<span class="literal">-cronjob-1592587860-r5gv4</span>   <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>          <span class="number">84</span>s</span><br><span class="line">pc<span class="literal">-cronjob-1592587920-9dxxq</span>   <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">24</span>s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除cronjob</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  delete -f pc-cronjob.yaml</span></span><br><span class="line">cronjob.batch <span class="string">&quot;pc-cronjob&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h1 id="第七章-Service详解"><a href="#第七章-Service详解" class="headerlink" title="第七章 Service详解"></a>第七章 Service详解</h1><p>本章节主要介绍kubernetes的流量负载组件：Service和Ingress。</p>
<h2 id="Service介绍"><a href="#Service介绍" class="headerlink" title="Service介绍"></a>Service介绍</h2><p>在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。</p>
<p>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200408194716912.png"></p>
<p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后<strong>它会将最新的Service信息转换成对应的访问规则</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509121254425.png"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 10.97.97.97:80 是service提供的访问入口</span></span><br><span class="line"><span class="comment"># 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，</span></span><br><span class="line"><span class="comment"># kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去</span></span><br><span class="line"><span class="comment"># 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">node1</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version <span class="number">1.2</span>.<span class="number">1</span> (size=<span class="number">4096</span>)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>kube-proxy目前支持三种工作模式:</p>
<p><strong>userspace 模式</strong></p>
<p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。<br>该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509151424280.png" style="border:1px solid;" />

<p><strong>iptables 模式</strong></p>
<p>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。<br>该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509152947714.png" style />

<p><strong>ipvs 模式</strong></p>
<p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509153731363.png" style />

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此模式必须安装ipvs内核模块，否则会降级为iptables</span></span><br><span class="line"><span class="comment"># 开启ipvs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl edit cm kube-proxy -n kube-system</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete pod -l k8s-app=kube-proxy -n kube-system</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">node1</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version <span class="number">1.2</span>.<span class="number">1</span> (size=<span class="number">4096</span>)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h2><p>Service的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 资源版本</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service</span> <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 描述</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 标签选择器，用于确定当前service代理哪些pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="comment"># Service类型，指定service的访问方式</span></span><br><span class="line">  <span class="attr">clusterIP:</span>  <span class="comment"># 虚拟服务的ip地址</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="comment"># session亲和性，支持ClientIP、None两个选项</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="comment"># 端口信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">      <span class="attr">port:</span> <span class="number">3017</span>  <span class="comment"># service端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5003</span> <span class="comment"># pod端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31122</span> <span class="comment"># 主机端口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问</li>
<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li>
<li>ExternalName： 把集群外部的服务引入集群内部，直接使用</li>
</ul>
<h2 id="Service使用"><a href="#Service使用" class="headerlink" title="Service使用"></a>Service使用</h2><h3 id="实验环境准备"><a href="#实验环境准备" class="headerlink" title="实验环境准备"></a>实验环境准备</h3><p>在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置<code>app=nginx-pod</code>的标签</p>
<p>创建deployment.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f deployment.yaml</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide --show-labels</span></span><br><span class="line">NAME                             READY   STATUS     IP            NODE     LABELS</span><br><span class="line">pc<span class="literal">-deployment-66cb59b984-8p84h</span>   <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">10.244</span>.<span class="number">1.40</span>   node1    app=nginx<span class="literal">-pod</span></span><br><span class="line">pc<span class="literal">-deployment-66cb59b984-vx8vx</span>   <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">10.244</span>.<span class="number">2.33</span>   node2    app=nginx<span class="literal">-pod</span></span><br><span class="line">pc<span class="literal">-deployment-66cb59b984-wnncx</span>   <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">10.244</span>.<span class="number">1.39</span>   node1    app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致）</span></span><br><span class="line"><span class="comment"># kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span></span><br><span class="line"><span class="comment"># echo &quot;10.244.1.40&quot; &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改完毕之后，访问测试</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.40</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.39</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.39</span></span><br></pre></td></tr></table></figure>

<h3 id="ClusterIP类型的Service"><a href="#ClusterIP类型的Service" class="headerlink" title="ClusterIP类型的Service"></a>ClusterIP类型的Service</h3><p>创建service-clusterip.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-clusterip</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.97</span><span class="number">.97</span><span class="number">.97</span> <span class="comment"># service的ip地址，如果不写，默认会生成一个</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># Service端口       </span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># pod端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f service-clusterip.yaml</span></span><br><span class="line">service/service<span class="literal">-clusterip</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc -n dev -o wide</span></span><br><span class="line">NAME                <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>    EXTERNAL<span class="literal">-IP</span>   PORT(S)   AGE   SELECTOR</span><br><span class="line">service<span class="literal">-clusterip</span>   ClusterIP   <span class="number">10.97</span>.<span class="number">97.97</span>   &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">13</span>s   app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service的详细信息</span></span><br><span class="line"><span class="comment"># 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe svc service-clusterip -n dev</span></span><br><span class="line">Name:              service<span class="literal">-clusterip</span></span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx<span class="literal">-pod</span></span><br><span class="line"><span class="built_in">Type</span>:              ClusterIP</span><br><span class="line">IP:                <span class="number">10.97</span>.<span class="number">97.97</span></span><br><span class="line">Port:              &lt;unset&gt;  <span class="number">80</span>/TCP</span><br><span class="line">TargetPort:        <span class="number">80</span>/TCP</span><br><span class="line">Endpoints:         <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span></span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ipvs的映射规则</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问10.97.97.97:80观察效果</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.97.97.97:80</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br></pre></td></tr></table></figure>

<p><strong>Endpoint</strong></p>
<p>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。</p>
<p>一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，<strong>Endpoints是实现实际服务的端点集合</strong>。换句话说，service和pod之间的联系是通过endpoints实现的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509191917069.png" alt="image-20200509191917069"></p>
<p><strong>负载分发策略</strong></p>
<p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：</p>
<ul>
<li><p>如果不定义，默认使用kube-proxy的策略，比如随机、轮询</p>
</li>
<li><p>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上</p>
<p>此模式可以使在spec中添加<code>sessionAffinity:ClientIP</code>选项</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看ipvs的映射规则【rr 轮询】</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环访问测试</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># while true;do curl 10.97.97.97:80; sleep 5; done;</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.39</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.39</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分发策略----sessionAffinity:ClientIP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ipvs规则【persistent 代表持久】</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr persistent <span class="number">10800</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环访问测试</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># while true;do curl 10.97.97.97; sleep 5; done;</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f service-clusterip.yaml</span></span><br><span class="line">service <span class="string">&quot;service-clusterip&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h3 id="HeadLiness类型的Service"><a href="#HeadLiness类型的Service" class="headerlink" title="HeadLiness类型的Service"></a>HeadLiness类型的Service</h3><p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLiness  Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。</p>
<p>创建service-headliness.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>    </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f service-headliness.yaml</span></span><br><span class="line">service/service<span class="literal">-headliness</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取service， 发现CLUSTER-IP未分配</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc service-headliness -n dev -o wide</span></span><br><span class="line">NAME                 <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>   EXTERNAL<span class="literal">-IP</span>   PORT(S)   AGE   SELECTOR</span><br><span class="line">service<span class="literal">-headliness</span>   ClusterIP   None         &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">11</span>s   app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe svc service-headliness  -n dev</span></span><br><span class="line">Name:              service<span class="literal">-headliness</span></span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx<span class="literal">-pod</span></span><br><span class="line"><span class="built_in">Type</span>:              ClusterIP</span><br><span class="line">IP:                None</span><br><span class="line">Port:              &lt;unset&gt;  <span class="number">80</span>/TCP</span><br><span class="line">TargetPort:        <span class="number">80</span>/TCP</span><br><span class="line">Endpoints:         <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span></span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看域名的解析情况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span></span><br><span class="line">/ <span class="comment"># cat /etc/resolv.conf</span></span><br><span class="line">nameserver <span class="number">10.96</span>.<span class="number">0.10</span></span><br><span class="line">search dev.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># dig @10.96.0.10 service-headliness.dev.svc.cluster.local</span></span><br><span class="line">service<span class="literal">-headliness</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> A <span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line">service<span class="literal">-headliness</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> A <span class="number">10.244</span>.<span class="number">1.39</span></span><br><span class="line">service<span class="literal">-headliness</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> A <span class="number">10.244</span>.<span class="number">2.33</span></span><br></pre></td></tr></table></figure>

<h3 id="NodePort类型的Service"><a href="#NodePort类型的Service" class="headerlink" title="NodePort类型的Service"></a>NodePort类型的Service</h3><p>在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是<strong>将service的端口映射到Node的一个端口上</strong>，然后就可以通过<code>NodeIp:NodePort</code>来访问service了。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200620175731338.png" style="border:1px solid;" />

<p>创建service-nodeport.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-nodeport</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30002</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f service-nodeport.yaml</span></span><br><span class="line">service/service<span class="literal">-nodeport</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc -n dev -o wide</span></span><br><span class="line">NAME               <span class="built_in">TYPE</span>       CLUSTER<span class="literal">-IP</span>      EXTERNAL<span class="literal">-IP</span>   PORT(S)       SELECTOR</span><br><span class="line">service<span class="literal">-nodeport</span>   NodePort   <span class="number">10.105</span>.<span class="number">64.191</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">30002</span>/TCP  app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来可以通过电脑主机的浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod</span></span><br></pre></td></tr></table></figure>

<h3 id="LoadBalancer类型的Service"><a href="#LoadBalancer类型的Service" class="headerlink" title="LoadBalancer类型的Service"></a>LoadBalancer类型的Service</h3><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200510103945494.png" style="border:1px solid;" />

<h3 id="ExternalName类型的Service"><a href="#ExternalName类型的Service" class="headerlink" title="ExternalName类型的Service"></a>ExternalName类型的Service</h3><p>ExternalName类型的Service用于引入集群外部的服务，它通过<code>externalName</code>属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200510113311209.png" style="border:1px solid;" />

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-externalname</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">www.baidu.com</span>  <span class="comment">#改成ip地址也可以</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  create -f service-externalname.yaml</span></span><br><span class="line">service/service<span class="literal">-externalname</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 域名解析</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># dig @10.96.0.10 service-externalname.dev.svc.cluster.local</span></span><br><span class="line">service<span class="literal">-externalname</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> CNAME www.baidu.com.</span><br><span class="line">www.baidu.com.          <span class="number">30</span>      <span class="keyword">IN</span>      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       <span class="number">30</span>      <span class="keyword">IN</span>      A       <span class="number">39.156</span>.<span class="number">66.18</span></span><br><span class="line">www.a.shifen.com.       <span class="number">30</span>      <span class="keyword">IN</span>      A       <span class="number">39.156</span>.<span class="number">66.14</span></span><br></pre></td></tr></table></figure>

<h2 id="Ingress介绍"><a href="#Ingress介绍" class="headerlink" title="Ingress介绍"></a>Ingress介绍</h2><p>在前面课程中已经提到，Service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p>
<ul>
<li><p>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显</p>
</li>
<li><p>LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持</p>
<p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200623092808049.png" style="border:1px solid;" />

<p>实际上，Ingress相当于一个7层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解成在<strong>Ingress里建立诸多映射规则，Ingress Controller通过监听这些配置规则并转化成Nginx的反向代理配置 , 然后对外部提供服务</strong>。在这里有两个核心概念：</p>
<ul>
<li>ingress：kubernetes中的一个对象，作用是定义请求如何转发到service的规则</li>
<li>ingress controller：具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如Nginx, Contour, Haproxy等等</li>
</ul>
<p>Ingress（以Nginx为例）的工作原理如下：</p>
<ol>
<li>用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service</li>
<li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置</li>
<li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新</li>
<li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200516112704764.png" style="border:1px solid;" />

<h2 id="Ingress使用"><a href="#Ingress使用" class="headerlink" title="Ingress使用"></a>Ingress使用</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><strong>搭建ingress环境</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir ingress-controller</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cd ingress-controller/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取ingress-nginx，本次案例使用的是0.30版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改mandatory.yaml文件中的仓库</span></span><br><span class="line"><span class="comment"># 修改quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 为quay-mirror.qiniu.com/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 创建ingress-nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># kubectl apply -f ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ingress-nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># kubectl get pod -n ingress-nginx</span></span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx<span class="literal">-ingress-controller-fbf967dd5-4qpbp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">12</span><span class="built_in">h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># kubectl get svc -n ingress-nginx</span></span><br><span class="line">NAME            <span class="built_in">TYPE</span>       CLUSTER<span class="literal">-IP</span>     EXTERNAL<span class="literal">-IP</span>   PORT(S)                      AGE</span><br><span class="line">ingress<span class="literal">-nginx</span>   NodePort   <span class="number">10.98</span>.<span class="number">75.163</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">32240</span>/TCP,<span class="number">443</span>:<span class="number">31335</span>/TCP   <span class="number">11</span><span class="built_in">h</span></span><br></pre></td></tr></table></figure>

<p><strong>准备service和pod</strong></p>
<p>为了后面的实验比较方便，创建如下图所示的模型</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200516102419998.png" style="border:1px solid;" />

<p>创建tomcat-nginx.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tomcat:8.5-jre10-slim</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f tomcat-nginx.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc -n dev</span></span><br><span class="line">NAME             <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>   EXTERNAL<span class="literal">-IP</span>   PORT(S)    AGE</span><br><span class="line">nginx<span class="literal">-service</span>    ClusterIP   None         &lt;none&gt;        <span class="number">80</span>/TCP     <span class="number">48</span>s</span><br><span class="line">tomcat<span class="literal">-service</span>   ClusterIP   None         &lt;none&gt;        <span class="number">8080</span>/TCP   <span class="number">48</span>s</span><br></pre></td></tr></table></figure>

<h3 id="Http代理"><a href="#Http代理" class="headerlink" title="Http代理"></a>Http代理</h3><p>创建ingress-http.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-http</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f ingress-http.yaml</span></span><br><span class="line">ingress.extensions/ingress<span class="literal">-http</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ing ingress-http -n dev</span></span><br><span class="line">NAME           HOSTS                                  ADDRESS   PORTS   AGE</span><br><span class="line">ingress<span class="literal">-http</span>   nginx.itheima.com,tomcat.itheima.com             <span class="number">80</span>      <span class="number">22</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe ing ingress-http  -n dev</span></span><br><span class="line">...</span><br><span class="line">Rules:</span><br><span class="line">Host                Path  Backends</span><br><span class="line"><span class="literal">----</span>                <span class="literal">----</span>  <span class="literal">--------</span></span><br><span class="line">nginx.itheima.com   / nginx<span class="literal">-service</span>:<span class="number">80</span> (<span class="number">10.244</span>.<span class="number">1.96</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.97</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.112</span>:<span class="number">80</span>)</span><br><span class="line">tomcat.itheima.com  / tomcat<span class="literal">-service</span>:<span class="number">8080</span>(<span class="number">10.244</span>.<span class="number">1.94</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">1.95</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">2.111</span>:<span class="number">8080</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上</span></span><br><span class="line"><span class="comment"># 然后,就可以分别访问tomcat.itheima.com:32240  和  nginx.itheima.com:32240 查看效果了</span></span><br></pre></td></tr></table></figure>

<h3 id="Https代理"><a href="#Https代理" class="headerlink" title="Https代理"></a>Https代理</h3><p>创建证书</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line">openssl req <span class="literal">-x509</span> <span class="literal">-sha256</span> <span class="literal">-nodes</span> <span class="literal">-days</span> <span class="number">365</span> <span class="literal">-newkey</span> rsa:<span class="number">2048</span> <span class="literal">-keyout</span> tls.key <span class="literal">-out</span> tls.crt <span class="literal">-subj</span> <span class="string">&quot;/C=CN/ST=BJ/L=BJ/O=nginx/CN=itheima.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建密钥</span></span><br><span class="line">kubectl create secret tls tls<span class="literal">-secret</span> <span class="literal">--key</span> tls.key <span class="literal">--cert</span> tls.crt</span><br></pre></td></tr></table></figure>

<p>创建ingress-https.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-https</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-secret</span> <span class="comment"># 指定秘钥</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f ingress-https.yaml</span></span><br><span class="line">ingress.extensions/ingress<span class="literal">-https</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ing ingress-https -n dev</span></span><br><span class="line">NAME            HOSTS                                  ADDRESS         PORTS     AGE</span><br><span class="line">ingress<span class="literal">-https</span>   nginx.itheima.com,tomcat.itheima.com   <span class="number">10.104</span>.<span class="number">184.38</span>   <span class="number">80</span>, <span class="number">443</span>   <span class="number">2</span>m42s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe ing ingress-https -n dev</span></span><br><span class="line">...</span><br><span class="line">TLS:</span><br><span class="line">  tls<span class="literal">-secret</span> terminates nginx.itheima.com,tomcat.itheima.com</span><br><span class="line">Rules:</span><br><span class="line">Host              Path Backends</span><br><span class="line"><span class="literal">----</span>              <span class="literal">----</span> <span class="literal">--------</span></span><br><span class="line">nginx.itheima.com  /  nginx<span class="literal">-service</span>:<span class="number">80</span> (<span class="number">10.244</span>.<span class="number">1.97</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.98</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.119</span>:<span class="number">80</span>)</span><br><span class="line">tomcat.itheima.com /  tomcat<span class="literal">-service</span>:<span class="number">8080</span>(<span class="number">10.244</span>.<span class="number">1.99</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">2.117</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">2.120</span>:<span class="number">8080</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面可以通过浏览器访问https://nginx.itheima.com:31335 和 https://tomcat.itheima.com:31335来查看了</span></span><br></pre></td></tr></table></figure>

<h1 id="第七章-Service详解-1"><a href="#第七章-Service详解-1" class="headerlink" title="第七章 Service详解"></a>第七章 Service详解</h1><p>本章节主要介绍kubernetes的流量负载组件：Service和Ingress。</p>
<h2 id="Service介绍-1"><a href="#Service介绍-1" class="headerlink" title="Service介绍"></a>Service介绍</h2><p>在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。</p>
<p>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200408194716912-20220901093550626.png"></p>
<p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后<strong>它会将最新的Service信息转换成对应的访问规则</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509121254425.png" style="border:1px solid;" />

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 10.97.97.97:80 是service提供的访问入口</span></span><br><span class="line"><span class="comment"># 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，</span></span><br><span class="line"><span class="comment"># kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去</span></span><br><span class="line"><span class="comment"># 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">node1</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version <span class="number">1.2</span>.<span class="number">1</span> (size=<span class="number">4096</span>)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>kube-proxy目前支持三种工作模式:</p>
<p><strong>userspace 模式</strong></p>
<p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。<br>该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509151424280.png" style />

<p><strong>iptables 模式</strong></p>
<p>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。<br>该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509152947714.png" style />

<p><strong>ipvs 模式</strong></p>
<p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509153731363.png" style />

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此模式必须安装ipvs内核模块，否则会降级为iptables</span></span><br><span class="line"><span class="comment"># 开启ipvs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl edit cm kube-proxy -n kube-system</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete pod -l k8s-app=kube-proxy -n kube-system</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">node1</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version <span class="number">1.2</span>.<span class="number">1</span> (size=<span class="number">4096</span>)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="Service类型-1"><a href="#Service类型-1" class="headerlink" title="Service类型"></a>Service类型</h2><p>Service的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 资源版本</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service</span> <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 描述</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 标签选择器，用于确定当前service代理哪些pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="comment"># Service类型，指定service的访问方式</span></span><br><span class="line">  <span class="attr">clusterIP:</span>  <span class="comment"># 虚拟服务的ip地址</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="comment"># session亲和性，支持ClientIP、None两个选项</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="comment"># 端口信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">      <span class="attr">port:</span> <span class="number">3017</span>  <span class="comment"># service端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5003</span> <span class="comment"># pod端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31122</span> <span class="comment"># 主机端口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问</li>
<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li>
<li>ExternalName： 把集群外部的服务引入集群内部，直接使用</li>
</ul>
<h2 id="Service使用-1"><a href="#Service使用-1" class="headerlink" title="Service使用"></a>Service使用</h2><h3 id="实验环境准备-1"><a href="#实验环境准备-1" class="headerlink" title="实验环境准备"></a>实验环境准备</h3><p>在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置<code>app=nginx-pod</code>的标签</p>
<p>创建deployment.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f deployment.yaml</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide --show-labels</span></span><br><span class="line">NAME                             READY   STATUS     IP            NODE     LABELS</span><br><span class="line">pc<span class="literal">-deployment-66cb59b984-8p84h</span>   <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">10.244</span>.<span class="number">1.40</span>   node1    app=nginx<span class="literal">-pod</span></span><br><span class="line">pc<span class="literal">-deployment-66cb59b984-vx8vx</span>   <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">10.244</span>.<span class="number">2.33</span>   node2    app=nginx<span class="literal">-pod</span></span><br><span class="line">pc<span class="literal">-deployment-66cb59b984-wnncx</span>   <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">10.244</span>.<span class="number">1.39</span>   node1    app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致）</span></span><br><span class="line"><span class="comment"># kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span></span><br><span class="line"><span class="comment"># echo &quot;10.244.1.40&quot; &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改完毕之后，访问测试</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.40</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.39</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.39</span></span><br></pre></td></tr></table></figure>

<h3 id="ClusterIP类型的Service-1"><a href="#ClusterIP类型的Service-1" class="headerlink" title="ClusterIP类型的Service"></a>ClusterIP类型的Service</h3><p>创建service-clusterip.yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-clusterip</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.97</span><span class="number">.97</span><span class="number">.97</span> <span class="comment"># service的ip地址，如果不写，默认会生成一个</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># Service端口       </span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># pod端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f service-clusterip.yaml</span></span><br><span class="line">service/service<span class="literal">-clusterip</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc -n dev -o wide</span></span><br><span class="line">NAME                <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>    EXTERNAL<span class="literal">-IP</span>   PORT(S)   AGE   SELECTOR</span><br><span class="line">service<span class="literal">-clusterip</span>   ClusterIP   <span class="number">10.97</span>.<span class="number">97.97</span>   &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">13</span>s   app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service的详细信息</span></span><br><span class="line"><span class="comment"># 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe svc service-clusterip -n dev</span></span><br><span class="line">Name:              service<span class="literal">-clusterip</span></span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx<span class="literal">-pod</span></span><br><span class="line"><span class="built_in">Type</span>:              ClusterIP</span><br><span class="line">IP:                <span class="number">10.97</span>.<span class="number">97.97</span></span><br><span class="line">Port:              &lt;unset&gt;  <span class="number">80</span>/TCP</span><br><span class="line">TargetPort:        <span class="number">80</span>/TCP</span><br><span class="line">Endpoints:         <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span></span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ipvs的映射规则</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问10.97.97.97:80观察效果</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.97.97.97:80</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br></pre></td></tr></table></figure>

<p><strong>Endpoint</strong></p>
<pre><code>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。

一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，**Endpoints是实现实际服务的端点集合**。换句话说，service和pod之间的联系是通过endpoints实现的。
</code></pre>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200509191917069.png" style />

<p><strong>负载分发策略</strong></p>
<p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：</p>
<ul>
<li><p>如果不定义，默认使用kube-proxy的策略，比如随机、轮询</p>
</li>
<li><p>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上</p>
<p>此模式可以使在spec中添加<code>sessionAffinity:ClientIP</code>选项</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看ipvs的映射规则【rr 轮询】</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环访问测试</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># while true;do curl 10.97.97.97:80; sleep 5; done;</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.39</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.39</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分发策略----sessionAffinity:ClientIP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ipvs规则【persistent 代表持久】</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr persistent <span class="number">10800</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环访问测试</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># while true;do curl 10.97.97.97; sleep 5; done;</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f service-clusterip.yaml</span></span><br><span class="line">service <span class="string">&quot;service-clusterip&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h3 id="HeadLiness类型的Service-1"><a href="#HeadLiness类型的Service-1" class="headerlink" title="HeadLiness类型的Service"></a>HeadLiness类型的Service</h3><p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLiness  Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。</p>
<p>创建service-headliness.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>    </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f service-headliness.yaml</span></span><br><span class="line">service/service<span class="literal">-headliness</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取service， 发现CLUSTER-IP未分配</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc service-headliness -n dev -o wide</span></span><br><span class="line">NAME                 <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>   EXTERNAL<span class="literal">-IP</span>   PORT(S)   AGE   SELECTOR</span><br><span class="line">service<span class="literal">-headliness</span>   ClusterIP   None         &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">11</span>s   app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe svc service-headliness  -n dev</span></span><br><span class="line">Name:              service<span class="literal">-headliness</span></span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx<span class="literal">-pod</span></span><br><span class="line"><span class="built_in">Type</span>:              ClusterIP</span><br><span class="line">IP:                None</span><br><span class="line">Port:              &lt;unset&gt;  <span class="number">80</span>/TCP</span><br><span class="line">TargetPort:        <span class="number">80</span>/TCP</span><br><span class="line">Endpoints:         <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span></span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看域名的解析情况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span></span><br><span class="line">/ <span class="comment"># cat /etc/resolv.conf</span></span><br><span class="line">nameserver <span class="number">10.96</span>.<span class="number">0.10</span></span><br><span class="line">search dev.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># dig @10.96.0.10 service-headliness.dev.svc.cluster.local</span></span><br><span class="line">service<span class="literal">-headliness</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> A <span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line">service<span class="literal">-headliness</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> A <span class="number">10.244</span>.<span class="number">1.39</span></span><br><span class="line">service<span class="literal">-headliness</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> A <span class="number">10.244</span>.<span class="number">2.33</span></span><br></pre></td></tr></table></figure>

<h3 id="NodePort类型的Service-1"><a href="#NodePort类型的Service-1" class="headerlink" title="NodePort类型的Service"></a>NodePort类型的Service</h3><p>在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是<strong>将service的端口映射到Node的一个端口上</strong>，然后就可以通过<code>NodeIp:NodePort</code>来访问service了。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200620175731338.png" style />

<p>创建service-nodeport.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-nodeport</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30002</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f service-nodeport.yaml</span></span><br><span class="line">service/service<span class="literal">-nodeport</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc -n dev -o wide</span></span><br><span class="line">NAME               <span class="built_in">TYPE</span>       CLUSTER<span class="literal">-IP</span>      EXTERNAL<span class="literal">-IP</span>   PORT(S)       SELECTOR</span><br><span class="line">service<span class="literal">-nodeport</span>   NodePort   <span class="number">10.105</span>.<span class="number">64.191</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">30002</span>/TCP  app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来可以通过电脑主机的浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod</span></span><br></pre></td></tr></table></figure>

<h3 id="LoadBalancer类型的Service-1"><a href="#LoadBalancer类型的Service-1" class="headerlink" title="LoadBalancer类型的Service"></a>LoadBalancer类型的Service</h3><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200510103945494.png" style="border:1px solid;" />

<h3 id="ExternalName类型的Service-1"><a href="#ExternalName类型的Service-1" class="headerlink" title="ExternalName类型的Service"></a>ExternalName类型的Service</h3><p>ExternalName类型的Service用于引入集群外部的服务，它通过<code>externalName</code>属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200510113311209.png" style="border:solid 1px;" />

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-externalname</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">www.baidu.com</span>  <span class="comment">#改成ip地址也可以</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  create -f service-externalname.yaml</span></span><br><span class="line">service/service<span class="literal">-externalname</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 域名解析</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># dig @10.96.0.10 service-externalname.dev.svc.cluster.local</span></span><br><span class="line">service<span class="literal">-externalname</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> CNAME www.baidu.com.</span><br><span class="line">www.baidu.com.          <span class="number">30</span>      <span class="keyword">IN</span>      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       <span class="number">30</span>      <span class="keyword">IN</span>      A       <span class="number">39.156</span>.<span class="number">66.18</span></span><br><span class="line">www.a.shifen.com.       <span class="number">30</span>      <span class="keyword">IN</span>      A       <span class="number">39.156</span>.<span class="number">66.14</span></span><br></pre></td></tr></table></figure>

<h2 id="Ingress介绍-1"><a href="#Ingress介绍-1" class="headerlink" title="Ingress介绍"></a>Ingress介绍</h2><p>在前面课程中已经提到，Service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p>
<ul>
<li><p>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显</p>
</li>
<li><p>LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持</p>
<p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200623092808049.png" style="border:solid 1px;" />

<p>实际上，Ingress相当于一个7层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解成在<strong>Ingress里建立诸多映射规则，Ingress Controller通过监听这些配置规则并转化成Nginx的反向代理配置 , 然后对外部提供服务</strong>。在这里有两个核心概念：</p>
<ul>
<li>ingress：kubernetes中的一个对象，作用是定义请求如何转发到service的规则</li>
<li>ingress controller：具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如Nginx, Contour, Haproxy等等</li>
</ul>
<p>Ingress（以Nginx为例）的工作原理如下：</p>
<ol>
<li>用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service</li>
<li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置</li>
<li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新</li>
<li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200516112704764.png" style="border:solid 1px;" />

<h2 id="Ingress使用-1"><a href="#Ingress使用-1" class="headerlink" title="Ingress使用"></a>Ingress使用</h2><h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h3><p><strong>搭建ingress环境</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir ingress-controller</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cd ingress-controller/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取ingress-nginx，本次案例使用的是0.30版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改mandatory.yaml文件中的仓库</span></span><br><span class="line"><span class="comment"># 修改quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 为quay-mirror.qiniu.com/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 创建ingress-nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># kubectl apply -f ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ingress-nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># kubectl get pod -n ingress-nginx</span></span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx<span class="literal">-ingress-controller-fbf967dd5-4qpbp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">12</span><span class="built_in">h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># kubectl get svc -n ingress-nginx</span></span><br><span class="line">NAME            <span class="built_in">TYPE</span>       CLUSTER<span class="literal">-IP</span>     EXTERNAL<span class="literal">-IP</span>   PORT(S)                      AGE</span><br><span class="line">ingress<span class="literal">-nginx</span>   NodePort   <span class="number">10.98</span>.<span class="number">75.163</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">32240</span>/TCP,<span class="number">443</span>:<span class="number">31335</span>/TCP   <span class="number">11</span><span class="built_in">h</span></span><br></pre></td></tr></table></figure>

<p><strong>准备service和pod</strong></p>
<p>为了后面的实验比较方便，创建如下图所示的模型</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200516102419998.png" style="border:solid 1px;" />

<p>创建tomcat-nginx.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tomcat:8.5-jre10-slim</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f tomcat-nginx.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc -n dev</span></span><br><span class="line">NAME             <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>   EXTERNAL<span class="literal">-IP</span>   PORT(S)    AGE</span><br><span class="line">nginx<span class="literal">-service</span>    ClusterIP   None         &lt;none&gt;        <span class="number">80</span>/TCP     <span class="number">48</span>s</span><br><span class="line">tomcat<span class="literal">-service</span>   ClusterIP   None         &lt;none&gt;        <span class="number">8080</span>/TCP   <span class="number">48</span>s</span><br></pre></td></tr></table></figure>

<h3 id="Http代理-1"><a href="#Http代理-1" class="headerlink" title="Http代理"></a>Http代理</h3><p>创建ingress-http.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-http</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f ingress-http.yaml</span></span><br><span class="line">ingress.extensions/ingress<span class="literal">-http</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ing ingress-http -n dev</span></span><br><span class="line">NAME           HOSTS                                  ADDRESS   PORTS   AGE</span><br><span class="line">ingress<span class="literal">-http</span>   nginx.itheima.com,tomcat.itheima.com             <span class="number">80</span>      <span class="number">22</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe ing ingress-http  -n dev</span></span><br><span class="line">...</span><br><span class="line">Rules:</span><br><span class="line">Host                Path  Backends</span><br><span class="line"><span class="literal">----</span>                <span class="literal">----</span>  <span class="literal">--------</span></span><br><span class="line">nginx.itheima.com   / nginx<span class="literal">-service</span>:<span class="number">80</span> (<span class="number">10.244</span>.<span class="number">1.96</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.97</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.112</span>:<span class="number">80</span>)</span><br><span class="line">tomcat.itheima.com  / tomcat<span class="literal">-service</span>:<span class="number">8080</span>(<span class="number">10.244</span>.<span class="number">1.94</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">1.95</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">2.111</span>:<span class="number">8080</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上</span></span><br><span class="line"><span class="comment"># 然后,就可以分别访问tomcat.itheima.com:32240  和  nginx.itheima.com:32240 查看效果了</span></span><br></pre></td></tr></table></figure>

<h3 id="Https代理-1"><a href="#Https代理-1" class="headerlink" title="Https代理"></a>Https代理</h3><p>创建证书</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line">openssl req <span class="literal">-x509</span> <span class="literal">-sha256</span> <span class="literal">-nodes</span> <span class="literal">-days</span> <span class="number">365</span> <span class="literal">-newkey</span> rsa:<span class="number">2048</span> <span class="literal">-keyout</span> tls.key <span class="literal">-out</span> tls.crt <span class="literal">-subj</span> <span class="string">&quot;/C=CN/ST=BJ/L=BJ/O=nginx/CN=itheima.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建密钥</span></span><br><span class="line">kubectl create secret tls tls<span class="literal">-secret</span> <span class="literal">--key</span> tls.key <span class="literal">--cert</span> tls.crt</span><br></pre></td></tr></table></figure>

<p>创建ingress-https.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-https</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-secret</span> <span class="comment"># 指定秘钥</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.itheima.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f ingress-https.yaml</span></span><br><span class="line">ingress.extensions/ingress<span class="literal">-https</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ing ingress-https -n dev</span></span><br><span class="line">NAME            HOSTS                                  ADDRESS         PORTS     AGE</span><br><span class="line">ingress<span class="literal">-https</span>   nginx.itheima.com,tomcat.itheima.com   <span class="number">10.104</span>.<span class="number">184.38</span>   <span class="number">80</span>, <span class="number">443</span>   <span class="number">2</span>m42s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe ing ingress-https -n dev</span></span><br><span class="line">...</span><br><span class="line">TLS:</span><br><span class="line">  tls<span class="literal">-secret</span> terminates nginx.itheima.com,tomcat.itheima.com</span><br><span class="line">Rules:</span><br><span class="line">Host              Path Backends</span><br><span class="line"><span class="literal">----</span>              <span class="literal">----</span> <span class="literal">--------</span></span><br><span class="line">nginx.itheima.com  /  nginx<span class="literal">-service</span>:<span class="number">80</span> (<span class="number">10.244</span>.<span class="number">1.97</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.98</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.119</span>:<span class="number">80</span>)</span><br><span class="line">tomcat.itheima.com /  tomcat<span class="literal">-service</span>:<span class="number">8080</span>(<span class="number">10.244</span>.<span class="number">1.99</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">2.117</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">2.120</span>:<span class="number">8080</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面可以通过浏览器访问https://nginx.itheima.com:31335 和 https://tomcat.itheima.com:31335来查看了</span></span><br></pre></td></tr></table></figure>

<h1 id="第八章-数据存储"><a href="#第八章-数据存储" class="headerlink" title="第八章 数据存储"></a>第八章 数据存储</h1><p>在前面已经提到，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes引入了Volume的概念。</p>
<p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。</p>
<p>kubernetes的Volume支持多种类型，比较常见的有下面几个：</p>
<ul>
<li>简单存储：EmptyDir、HostPath、NFS</li>
<li>高级存储：PV、PVC</li>
<li>配置存储：ConfigMap、Secret</li>
</ul>
<h2 id="基本存储"><a href="#基本存储" class="headerlink" title="基本存储"></a>基本存储</h2><h3 id="EmptyDir"><a href="#EmptyDir" class="headerlink" title="EmptyDir"></a>EmptyDir</h3><p>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。</p>
<p>EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：</p>
<ul>
<li><p>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</p>
</li>
<li><p>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</p>
</li>
</ul>
<p>接下来，通过一个容器之间文件共享的案例来使用一下EmptyDir。</p>
<p>在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200413174713773.png" style="border:solid 1px;" />

<p>创建一个volume-emptydir.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-emptydir</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14-alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>  <span class="comment"># 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] <span class="comment"># 初始命令，动态读取指定文件中内容</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>  <span class="comment"># 将logs-volume 挂在到busybox容器中，对应的目录为 /logs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 声明volume， name为logs-volume，类型为emptyDir</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f volume-emptydir.yaml</span></span><br><span class="line">pod/volume<span class="literal">-emptydir</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods volume-emptydir -n dev -o wide</span></span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE   IP             NODE   ...... </span><br><span class="line">volume<span class="literal">-emptydir</span>   <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">97</span>s   <span class="number">10.244</span>.<span class="number">1.100</span>   node1  ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过podIp访问nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.100</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过kubectl logs命令查看指定容器的标准输出</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl logs -f volume-emptydir -n dev -c busybox</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">0.0</span> - - [<span class="number">13</span>/<span class="type">Apr</span>/<span class="number">2020</span>:<span class="number">10</span>:<span class="number">58</span>:<span class="number">47</span> +<span class="number">0000</span>] <span class="string">&quot;GET / HTTP/1.1&quot;</span> <span class="number">200</span> <span class="number">612</span> <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.29.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="HostPath"><a href="#HostPath" class="headerlink" title="HostPath"></a>HostPath</h3><p>上节课提到，EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。</p>
<p>HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200413214031331.png" style="border:1px solid;" />

<p>创建一个volume-hostpath.yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-hostpath</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span> </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/root/logs</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span>  <span class="comment"># 目录存在就使用，不存在就先创建后使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">关于type的值的一点说明：</span><br><span class="line"><span class="code">	DirectoryOrCreate 目录存在就使用，不存在就先创建后使用</span></span><br><span class="line"><span class="code">	Directory	目录必须存在</span></span><br><span class="line"><span class="code">	FileOrCreate  文件存在就使用，不存在就先创建后使用</span></span><br><span class="line"><span class="code">	File 文件必须存在	</span></span><br><span class="line"><span class="code">    Socket	unix套接字必须存在</span></span><br><span class="line"><span class="code">	CharDevice	字符设备必须存在</span></span><br><span class="line"><span class="code">	BlockDevice 块设备必须存在</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f volume-hostpath.yaml</span></span><br><span class="line">pod/volume<span class="literal">-hostpath</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods volume-hostpath -n dev -o wide</span></span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE   IP             NODE   ......</span><br><span class="line">pod<span class="literal">-volume-hostpath</span>   <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">16</span>s   <span class="number">10.244</span>.<span class="number">1.104</span>   node1  ......</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.104</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就可以去host的/root/logs目录下查看存储的文件了</span></span><br><span class="line"><span class="comment">###  注意: 下面的操作需要到Pod所在的节点运行（案例中是node1）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">node1</span> ~]<span class="comment"># ls /root/logs/</span></span><br><span class="line">access.log  error.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样的道理，如果在此目录下创建一个文件，到容器中也是可以看到的</span></span><br></pre></td></tr></table></figure>

<h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><pre><code>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。

NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200413215133559.png" alt="image-20200413215133559"></p>
<p>1）首先要准备nfs的服务器，这里为了简单，直接是master节点做nfs服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在master上安装nfs服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install nfs-utils -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备一个共享目录</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir /root/data/nfs -pv</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将共享目录以读写权限暴露给192.168.109.0/24网段中的所有主机</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim /etc/exports</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># more /etc/exports</span></span><br><span class="line">/root/<span class="keyword">data</span>/nfs     <span class="number">192.168</span>.<span class="number">109.0</span>/<span class="number">24</span>(rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动nfs服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl start nfs</span></span><br></pre></td></tr></table></figure>

<p>2）接下来，要在的每个node节点上都安装下nfs，这样的目的是为了node节点可以驱动nfs设备</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在node上安装nfs服务，注意不需要启动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install nfs-utils -y</span></span><br></pre></td></tr></table></figure>

<p>3）接下来，就可以编写pod的配置文件了，创建volume-nfs.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-nfs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] </span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span>  <span class="comment">#nfs服务器地址</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/root/data/nfs</span> <span class="comment">#共享文件路径</span></span><br></pre></td></tr></table></figure>

<p>4）最后，运行下pod，观察结果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f volume-nfs.yaml</span></span><br><span class="line">pod/volume<span class="literal">-nfs</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods volume-nfs -n dev</span></span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">volume<span class="literal">-nfs</span>        <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">2</span>m9s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看nfs服务器上的共享目录，发现已经有文件了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ls /root/data/</span></span><br><span class="line">access.log  error.log</span><br></pre></td></tr></table></figure>

<h2 id="高级存储"><a href="#高级存储" class="headerlink" title="高级存储"></a>高级存储</h2><h3 id="PV和PVC"><a href="#PV和PVC" class="headerlink" title="PV和PVC"></a>PV和PVC</h3><p>前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。</p>
<p>PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。</p>
<p>PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200514194111567.png" alt="image-20200514194111567"></p>
<p>使用了PV和PVC之后，工作可以得到进一步的细分：</p>
<ul>
<li>存储：存储工程师维护</li>
<li>PV：  kubernetes管理员维护</li>
<li>PVC：kubernetes用户维护</li>
</ul>
<h3 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h3><p>PV是存储资源的抽象，下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 存储类型，与底层真正存储对应</span></span><br><span class="line">  <span class="attr">capacity:</span>  <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span>  <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="comment"># 回收策略</span></span><br></pre></td></tr></table></figure>

<p>PV 的关键配置参数说明：</p>
<ul>
<li><p><strong>存储类型</strong></p>
<p>底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异</p>
</li>
<li><p><strong>存储能力（capacity）</strong></p>
<p>目前只支持存储空间的设置( storage&#x3D;1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置</p>
</li>
<li><p><strong>访问模式（accessModes）</strong></p>
<p>用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p>
<ul>
<li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li>
<li>ReadOnlyMany（ROX）：  只读权限，可以被多个节点挂载</li>
<li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的访问模式不同</code></p>
</li>
<li><p><strong>回收策略（persistentVolumeReclaimPolicy）</strong></p>
<p>当PV不再被使用了之后，对其的处理方式。目前支持三种策略：</p>
<ul>
<li>Retain  （保留）  保留数据，需要管理员手工清理数据</li>
<li>Recycle（回收）  清除 PV 中的数据，效果相当于执行 rm -rf &#x2F;thevolume&#x2F;*</li>
<li>Delete  （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务</li>
</ul>
<p>需要注意的是，底层不同的存储类型可能支持的回收策略不同</p>
</li>
<li><p><strong>存储类别</strong></p>
<p>PV可以通过storageClassName参数指定一个存储类别</p>
<ul>
<li><p>具有特定类别的PV只能与请求了该类别的PVC进行绑定</p>
</li>
<li><p>未设定类别的PV则只能与不请求任何类别的PVC进行绑定</p>
</li>
</ul>
</li>
<li><p><strong>状态（status）</strong></p>
<p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p>
<ul>
<li>Available（可用）：     表示可用状态，还未被任何 PVC 绑定</li>
<li>Bound（已绑定）：     表示 PV 已经被 PVC 绑定</li>
<li>Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）：         表示该 PV 的自动回收失败</li>
</ul>
</li>
</ul>
<p><strong>实验</strong></p>
<p>使用NFS作为存储，来演示PV的使用，创建3个PV，对应NFS中的3个暴露的路径。</p>
<ol>
<li>准备NFS环境</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir /root/data/&#123;pv1,pv2,pv3&#125; -pv</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># more /etc/exports</span></span><br><span class="line">/root/<span class="keyword">data</span>/pv1     <span class="number">192.168</span>.<span class="number">109.0</span>/<span class="number">24</span>(rw,no_root_squash)</span><br><span class="line">/root/<span class="keyword">data</span>/pv2     <span class="number">192.168</span>.<span class="number">109.0</span>/<span class="number">24</span>(rw,no_root_squash)</span><br><span class="line">/root/<span class="keyword">data</span>/pv3     <span class="number">192.168</span>.<span class="number">109.0</span>/<span class="number">24</span>(rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  systemctl restart nfs</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建pv.yaml</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">/root/data/pv1</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv2</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv3</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv3</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 pv</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pv.yaml</span></span><br><span class="line">persistentvolume/pv1 created</span><br><span class="line">persistentvolume/pv2 created</span><br><span class="line">persistentvolume/pv3 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pv</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pv -o wide</span></span><br><span class="line">NAME   CAPACITY   ACCESS MODES  RECLAIM POLICY  STATUS      AGE   VOLUMEMODE</span><br><span class="line">pv1    <span class="number">1</span><span class="built_in">Gi</span>        RWX            Retain        Available    <span class="number">10</span>s   Filesystem</span><br><span class="line">pv2    <span class="number">2</span><span class="built_in">Gi</span>        RWX            Retain        Available    <span class="number">10</span>s   Filesystem</span><br><span class="line">pv3    <span class="number">3</span><span class="built_in">Gi</span>        RWX            Retain        Available    <span class="number">9</span>s    Filesystem</span><br></pre></td></tr></table></figure>

<h3 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h3><p>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 采用标签对PV选择</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="comment"># 请求空间</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br></pre></td></tr></table></figure>

<p>PVC 的关键配置参数说明：</p>
<ul>
<li><p><strong>访问模式（accessModes）</strong></p>
<p>用于描述用户应用对存储资源的访问权限</p>
</li>
<li><p><strong>选择条件（selector）</strong></p>
<p>通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选</p>
</li>
<li><p><strong>存储类别（storageClassName）</strong></p>
<p>PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</p>
</li>
<li><p><strong>资源请求（Resources ）</strong></p>
<p>描述对存储资源的请求</p>
</li>
</ul>
<p><strong>实验</strong></p>
<ol>
<li>创建pvc.yaml，申请pv</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">equests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">equests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pvc</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pvc.yaml</span></span><br><span class="line">persistentvolumeclaim/pvc1 created</span><br><span class="line">persistentvolumeclaim/pvc2 created</span><br><span class="line">persistentvolumeclaim/pvc3 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pvc</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pvc  -n dev -o wide</span></span><br><span class="line">NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE   VOLUMEMODE</span><br><span class="line">pvc1   Bound    pv1      <span class="number">1</span><span class="built_in">Gi</span>        RWX                           <span class="number">15</span>s   Filesystem</span><br><span class="line">pvc2   Bound    pv2      <span class="number">2</span><span class="built_in">Gi</span>        RWX                           <span class="number">15</span>s   Filesystem</span><br><span class="line">pvc3   Bound    pv3      <span class="number">3</span><span class="built_in">Gi</span>        RWX                           <span class="number">15</span>s   Filesystem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pv</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pv -o wide</span></span><br><span class="line">NAME  CAPACITY ACCESS MODES  RECLAIM POLICY  STATUS    CLAIM       AGE     VOLUMEMODE</span><br><span class="line">pv1    <span class="number">1</span><span class="built_in">Gi</span>        RWx        Retain          Bound    dev/pvc1    <span class="number">3</span>h37m    Filesystem</span><br><span class="line">pv2    <span class="number">2</span><span class="built_in">Gi</span>        RWX        Retain          Bound    dev/pvc2    <span class="number">3</span>h37m    Filesystem</span><br><span class="line">pv3    <span class="number">3</span><span class="built_in">Gi</span>        RWX        Retain          Bound    dev/pvc3    <span class="number">3</span>h37m    Filesystem   </span><br></pre></td></tr></table></figure>

<ol>
<li>创建pods.yaml, 使用pv</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">usybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod1 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ame:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc1</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">mage:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod2 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc2</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span>        </span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pods.yaml</span></span><br><span class="line">pod/pod1 created</span><br><span class="line">pod/pod2 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME   READY   STATUS    RESTARTS   AGE   IP            NODE   </span><br><span class="line">pod1   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">14</span>s   <span class="number">10.244</span>.<span class="number">1.69</span>   node1   </span><br><span class="line">pod2   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">14</span>s   <span class="number">10.244</span>.<span class="number">1.70</span>   node1  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pvc</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pvc -n dev -o wide</span></span><br><span class="line">NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES      AGE   VOLUMEMODE</span><br><span class="line">pvc1   Bound    pv1      <span class="number">1</span><span class="built_in">Gi</span>        RWX               <span class="number">94</span>m   Filesystem</span><br><span class="line">pvc2   Bound    pv2      <span class="number">2</span><span class="built_in">Gi</span>        RWX               <span class="number">94</span>m   Filesystem</span><br><span class="line">pvc3   Bound    pv3      <span class="number">3</span><span class="built_in">Gi</span>        RWX               <span class="number">94</span>m   Filesystem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pv</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pv -n dev -o wide</span></span><br><span class="line">NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM       AGE     VOLUMEMODE</span><br><span class="line">pv1    <span class="number">1</span><span class="built_in">Gi</span>        RWX            Retain           Bound    dev/pvc1    <span class="number">5</span>h11m   Filesystem</span><br><span class="line">pv2    <span class="number">2</span><span class="built_in">Gi</span>        RWX            Retain           Bound    dev/pvc2    <span class="number">5</span>h11m   Filesystem</span><br><span class="line">pv3    <span class="number">3</span><span class="built_in">Gi</span>        RWX            Retain           Bound    dev/pvc3    <span class="number">5</span>h11m   Filesystem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看nfs中的文件存储</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># more /root/data/pv1/out.txt</span></span><br><span class="line">node1</span><br><span class="line">node1</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># more /root/data/pv2/out.txt</span></span><br><span class="line">node2</span><br><span class="line">node2</span><br></pre></td></tr></table></figure>

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期：</p>
<ul>
<li><p><strong>资源供应</strong>：管理员手动创建底层存储和PV</p>
</li>
<li><p><strong>资源绑定</strong>：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定</p>
<p>在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的</p>
<ul>
<li><p>一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了</p>
</li>
<li><p>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV</p>
</li>
</ul>
<p>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</p>
</li>
<li><p><strong>资源使用</strong>：用户可在pod中像volume一样使用pvc</p>
<p>Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。</p>
</li>
<li><p><strong>资源释放</strong>：用户删除pvc来释放pv</p>
</li>
</ul>
<p>当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。</p>
<ul>
<li><p><strong>资源回收</strong>：kubernetes根据pv设置的回收策略进行资源的回收</p>
<p>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200515002806726.png" alt="image-20200515002806726"></p>
<h2 id="配置存储"><a href="#配置存储" class="headerlink" title="配置存储"></a>配置存储</h2><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>ConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。<br>创建configmap.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    username:admin</span></span><br><span class="line"><span class="string">    password:123456</span></span><br></pre></td></tr></table></figure>

<p>接下来，使用此配置文件创建configmap</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建configmap</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f configmap.yaml</span></span><br><span class="line">configmap/configmap created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看configmap详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe cm configmap -n dev</span></span><br><span class="line">Name:         configmap</span><br><span class="line">Namespace:    dev</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Data</span></span><br><span class="line">====</span><br><span class="line">info:</span><br><span class="line"><span class="literal">----</span></span><br><span class="line">username:admin</span><br><span class="line">password:<span class="number">123456</span></span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>接下来创建一个pod-configmap.yaml，将上面创建的configmap挂载进去</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将configmap挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/configmap/config</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 引用configmap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">configmap</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-configmap.yaml</span></span><br><span class="line">pod/pod<span class="literal">-configmap</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-configmap -n dev</span></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-configmap</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">6</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl exec -it pod-configmap -n dev /bin/sh</span></span><br><span class="line"><span class="comment"># cd /configmap/config/</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">info</span><br><span class="line"><span class="comment"># more info</span></span><br><span class="line">username:admin</span><br><span class="line">password:<span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到映射已经成功，每个configmap都映射成了一个目录</span></span><br><span class="line"><span class="comment"># key---&gt;文件     value----&gt;文件中的内容</span></span><br><span class="line"><span class="comment"># 此时如果更新configmap的内容, 容器中的值也会动态更新</span></span><br></pre></td></tr></table></figure>

<h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><p>在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。</p>
<ol>
<li>首先使用base64对数据进行编码</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@master</span> <span class="string">~</span>]<span class="comment"># echo -n &#x27;admin&#x27; | base64 #准备username</span></span><br><span class="line"><span class="string">YWRtaW4=</span></span><br><span class="line">[<span class="string">root@master</span> <span class="string">~</span>]<span class="comment"># echo -n &#x27;123456&#x27; | base64 #准备password</span></span><br><span class="line"><span class="string">MTIzNDU2</span></span><br></pre></td></tr></table></figure>

<ol>
<li>接下来编写secret.yaml，并创建Secret</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MTIzNDU2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建secret</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f secret.yaml</span></span><br><span class="line">secret/secret created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看secret详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe secret secret -n dev</span></span><br><span class="line">Name:         secret</span><br><span class="line">Namespace:    dev</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"><span class="built_in">Type</span>:  Opaque</span><br><span class="line"><span class="keyword">Data</span></span><br><span class="line">====</span><br><span class="line">password:  <span class="number">6</span> bytes</span><br><span class="line">username:  <span class="number">5</span> bytes</span><br></pre></td></tr></table></figure>

<ol>
<li>创建pod-secret.yaml，将上面创建的secret挂载进去：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将secret挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/secret/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-secret.yaml</span></span><br><span class="line">pod/pod<span class="literal">-secret</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-secret -n dev</span></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-secret</span>      <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>m28s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器，查看secret信息，发现已经自动解码了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl exec -it pod-secret /bin/sh -n dev</span></span><br><span class="line">/ <span class="comment"># ls /secret/config/</span></span><br><span class="line">password  username</span><br><span class="line">/ <span class="comment"># more /secret/config/username</span></span><br><span class="line">admin</span><br><span class="line">/ <span class="comment"># more /secret/config/password</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>至此，已经实现了利用secret实现了信息的编码。</p>
<h1 id="第九章-安全认证"><a href="#第九章-安全认证" class="headerlink" title="第九章 安全认证"></a>第九章 安全认证</h1><p>本章节主要介绍Kubernetes的安全认证机制。</p>
<h2 id="访问控制概述"><a href="#访问控制概述" class="headerlink" title="访问控制概述"></a>访问控制概述</h2><p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种<strong>客户端</strong>进行<strong>认证和鉴权</strong>操作。</p>
<p><strong>客户端</strong></p>
<p>在Kubernetes集群中，客户端通常有两类：</p>
<ul>
<li><p><strong>User Account</strong>：一般是独立于kubernetes之外的其他服务管理的用户账号。</p>
</li>
<li><p><strong>Service Account</strong>：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200520102949189.png" style="border:1px solid;" />

<p><strong>认证、授权与准入控制</strong></p>
<p>ApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：</p>
<ul>
<li>Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证</li>
<li>Authorization（授权）：  判断用户是否有权限对访问的资源执行特定的动作</li>
<li>Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200520103942580.png" style="border:1px solid;" />

<h2 id="认证管理"><a href="#认证管理" class="headerlink" title="认证管理"></a>认证管理</h2><p>Kubernetes集群安全的最关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式：</p>
<ul>
<li><p>HTTP Base认证：通过用户名+密码的方式认证</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP Token认证：通过一个Token来识别合法用户</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这种认证方式是用一个很长的难以被模仿的字符串--Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200518211037434.png" alt="image-20200518211037434"></p>
<p><strong>HTTPS认证大体分为3个过程：</strong></p>
<ol>
<li><p>证书申请和下发</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">HTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端和服务端的双向认证</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1&gt; 客户端向服务器端发起请求，服务端下发自己的证书给客户端，</span><br><span class="line">   客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥，</span><br><span class="line">   客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器</span><br><span class="line">2&gt; 客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书，</span><br><span class="line">   在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器端和客户端进行通信</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。</span><br><span class="line">服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意:  Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可</p>
</blockquote>
<h2 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h2><p>授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后Kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。</p>
<p>每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。</p>
<p>API Server目前支持以下几种授权策略：</p>
<ul>
<li><p>AlwaysDeny：表示拒绝所有请求，一般用于测试</p>
</li>
<li><p>AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）</p>
</li>
<li><p>ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</p>
</li>
<li><p>Webhook：通过调用外部REST服务对用户进行授权</p>
</li>
<li><p>Node：是一种专用模式，用于对kubelet发出的请求进行访问控制</p>
</li>
<li><p>RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）</p>
</li>
</ul>
<p>RBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：<strong>给哪些对象授予了哪些权限</strong></p>
<p>其中涉及到了下面几个概念：</p>
<ul>
<li>对象：User、Groups、ServiceAccount</li>
<li>角色：代表着一组定义在资源上的可操作动作(权限)的集合</li>
<li>绑定：将定义好的角色跟用户绑定在一起</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200519181209566.png" style="border:1px solid;" />

<p>RBAC引入了4个顶级资源对象：</p>
<ul>
<li>Role、ClusterRole：角色，用于指定一组权限</li>
<li>RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象</li>
</ul>
<p><strong>Role、ClusterRole</strong></p>
<p>一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Role只能对命名空间内的资源进行授权，需要指定nameapce</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]  <span class="comment"># 支持的API组列表,&quot;&quot; 空字符串，表示核心API群</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>] <span class="comment"># 支持的资源对象列表</span></span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>] <span class="comment"># 允许的对资源对象的操作方法列表</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>需要详细说明的是，rules中的参数：</p>
<ul>
<li><p>apiGroups: 支持的API组列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>,<span class="string">&quot;apps&quot;</span>, <span class="string">&quot;autoscaling&quot;</span>, <span class="string">&quot;batch&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>resources：支持的资源对象列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;services&quot;</span>, <span class="string">&quot;endpoints&quot;</span>, <span class="string">&quot;pods&quot;</span>,<span class="string">&quot;secrets&quot;</span>,<span class="string">&quot;configmaps&quot;</span>,<span class="string">&quot;crontabs&quot;</span>,<span class="string">&quot;deployments&quot;</span>,<span class="string">&quot;jobs&quot;</span>,</span><br><span class="line"><span class="string">&quot;nodes&quot;</span>,<span class="string">&quot;rolebindings&quot;</span>,<span class="string">&quot;clusterroles&quot;</span>,<span class="string">&quot;daemonsets&quot;</span>,<span class="string">&quot;replicasets&quot;</span>,<span class="string">&quot;statefulsets&quot;</span>,</span><br><span class="line"><span class="string">&quot;horizontalpodautoscalers&quot;</span>,<span class="string">&quot;replicationcontrollers&quot;</span>,<span class="string">&quot;cronjobs&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>verbs：对资源对象的操作方法列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;exec&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>RoleBinding、ClusterRoleBinding</strong></p>
<p>角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是User、Group或者ServiceAccount。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RoleBinding可以将同一namespace中的subject绑定到某个Role下，则此subject即具有该Role定义的权限</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">authorization-clusterrole-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p><strong>RoleBinding引用ClusterRole进行授权</strong></p>
<p>RoleBinding可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">一种很常用的做法就是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。这样可以大幅提高授权管理工作效率，也使得各个命名空间下的基础性授权规则与使用体验保持一致。</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding</span></span><br><span class="line"><span class="comment"># 所以heima只能读取dev命名空间中的资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding-ns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p><strong>实战：创建一个只能管理dev空间下Pods资源的账号</strong></p>
<ol>
<li>创建账号</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1) 创建证书</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># cd /etc/kubernetes/pki/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># (umask 077;openssl genrsa -out devman.key 2048)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 用apiserver的证书去签署</span></span><br><span class="line"><span class="comment"># 2-1) 签名申请，申请的用户是devman,组是devgroup</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># openssl req -new -key devman.key -out devman.csr -subj &quot;/CN=devman/O=devgroup&quot;     </span></span><br><span class="line"><span class="comment"># 2-2) 签署证书</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># openssl x509 -req -in devman.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out devman.crt -days 3650</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 设置集群、用户、上下文信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl config set-cluster kubernetes --embed-certs=true --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.109.100:6443</span></span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl config set-credentials devman --embed-certs=true --client-certificate=/etc/kubernetes/pki/devman.crt --client-key=/etc/kubernetes/pki/devman.key</span></span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl config set-context devman@kubernetes --cluster=kubernetes --user=devman</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换账户到devman</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl config use-context devman@kubernetes</span></span><br><span class="line">Switched to context <span class="string">&quot;devman@kubernetes&quot;</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看dev下pod，发现没有权限</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">Error from server (Forbidden): pods is forbidden: User <span class="string">&quot;devman&quot;</span> cannot list resource <span class="string">&quot;pods&quot;</span> <span class="keyword">in</span> API <span class="built_in">group</span> <span class="string">&quot;&quot;</span> <span class="keyword">in</span> the namespace <span class="string">&quot;dev&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到admin账户</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl config use-context kubernetes-admin@kubernetes</span></span><br><span class="line">Switched to context <span class="string">&quot;kubernetes-admin@kubernetes&quot;</span>.</span><br></pre></td></tr></table></figure>

<p>2） 创建Role和RoleBinding，为devman用户授权</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line">  </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">devman</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl create -f dev-role.yaml</span></span><br><span class="line">role.rbac.authorization.k8s.io/dev<span class="literal">-role</span> created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/authorization<span class="literal">-role-binding</span> created</span><br></pre></td></tr></table></figure>

<ol>
<li>切换账户，再次验证</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换账户到devman</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl config use-context devman@kubernetes</span></span><br><span class="line">Switched to context <span class="string">&quot;devman@kubernetes&quot;</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                                 READY   STATUS             RESTARTS   AGE</span><br><span class="line">nginx<span class="literal">-deployment-66cb59b984-8wp2k</span>    <span class="number">1</span>/<span class="number">1</span>     Running            <span class="number">0</span>          <span class="number">4</span>d1<span class="built_in">h</span></span><br><span class="line">nginx<span class="literal">-deployment-66cb59b984-dc46j</span>    <span class="number">1</span>/<span class="number">1</span>     Running            <span class="number">0</span>          <span class="number">4</span>d1<span class="built_in">h</span></span><br><span class="line">nginx<span class="literal">-deployment-66cb59b984-thfck</span>    <span class="number">1</span>/<span class="number">1</span>     Running            <span class="number">0</span>          <span class="number">4</span>d1<span class="built_in">h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了不影响后面的学习,切回admin账户</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pki</span>]<span class="comment"># kubectl config use-context kubernetes-admin@kubernetes</span></span><br><span class="line">Switched to context <span class="string">&quot;kubernetes-admin@kubernetes&quot;</span>.</span><br></pre></td></tr></table></figure>

<h2 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h2><p>通过了前面的认证和授权之后，还需要经过准入控制处理通过之后，apiserver才会处理这个请求。</p>
<p>准入控制是一个可配置的控制器列表，可以通过在Api-Server上通过命令行设置选择执行哪些准入控制器：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="literal">--admission-control</span>=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,</span><br><span class="line">                      DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds</span><br></pre></td></tr></table></figure>

<p>只有当所有的准入控制器都检查通过之后，apiserver才执行该请求，否则返回拒绝。</p>
<p>当前可配置的Admission Control准入控制如下：</p>
<ul>
<li>AlwaysAdmit：允许所有请求</li>
<li>AlwaysDeny：禁止所有请求，一般用于测试</li>
<li>AlwaysPullImages：在启动容器之前总去下载镜像</li>
<li>DenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求</li>
<li>ImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。</li>
<li>Service Account：实现ServiceAccount实现了自动化</li>
<li>SecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效</li>
<li>ResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标</li>
<li>LimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制</li>
<li>InitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置</li>
<li>NamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象。</li>
<li>DefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节</li>
<li>DefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min</li>
<li>PodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的PodSecurityPolicy对Pod的安全策略进行控制</li>
</ul>
<h1 id="第十章-DashBoard"><a href="#第十章-DashBoard" class="headerlink" title="第十章 DashBoard"></a>第十章 DashBoard</h1><pre><code>之前在kubernetes中完成的所有操作都是通过命令行工具kubectl完成的。其实，为了提供更丰富的用户体验，kubernetes还开发了一个基于web的用户界面（Dashboard）。用户可以使用Dashboard部署容器化的应用，还可以监控应用的状态，执行故障排查以及管理kubernetes中各种资源。
</code></pre>
<h2 id="部署Dashboard"><a href="#部署Dashboard" class="headerlink" title="部署Dashboard"></a>部署Dashboard</h2><ol>
<li>下载yaml，并运行Dashboard</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># wget  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改kubernetes-dashboard的Service类型</span></span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s<span class="literal">-app</span>: kubernetes<span class="literal">-dashboard</span></span><br><span class="line">  name: kubernetes<span class="literal">-dashboard</span></span><br><span class="line">  namespace: kubernetes<span class="literal">-dashboard</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort  <span class="comment"># 新增</span></span><br><span class="line">  ports:</span><br><span class="line">    - port: <span class="number">443</span></span><br><span class="line">      targetPort: <span class="number">8443</span></span><br><span class="line">      nodePort: <span class="number">30009</span>  <span class="comment"># 新增</span></span><br><span class="line">  selector:</span><br><span class="line">    k8s<span class="literal">-app</span>: kubernetes<span class="literal">-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f recommended.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看namespace下的kubernetes-dashboard下的资源</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod,svc -n kubernetes-dashboard</span></span><br><span class="line">NAME                                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/dashboard<span class="literal">-metrics-scraper-c79c65bb7-zwfvw</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">111</span>s</span><br><span class="line">pod/kubernetes<span class="literal">-dashboard-56484d4c5-z95z5</span>        <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">111</span>s</span><br><span class="line"></span><br><span class="line">NAME                               <span class="built_in">TYPE</span>       CLUSTER<span class="literal">-IP</span>      EXTERNAL<span class="literal">-IP</span>  PORT(S)         AGE</span><br><span class="line">service/dashboard<span class="literal">-metrics-scraper</span>  ClusterIP  <span class="number">10.96</span>.<span class="number">89.218</span>    &lt;none&gt;       <span class="number">8000</span>/TCP        <span class="number">111</span>s</span><br><span class="line">service/kubernetes<span class="literal">-dashboard</span>       NodePort   <span class="number">10.104</span>.<span class="number">178.171</span>  &lt;none&gt;       <span class="number">443</span>:<span class="number">30009</span>/TCP   <span class="number">111</span>s</span><br></pre></td></tr></table></figure>

<p>2）创建访问账户，获取token</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建账号</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span>-<span class="number">1</span> ~]<span class="comment"># kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span>-<span class="number">1</span> ~]<span class="comment"># kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取账号token</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin</span></span><br><span class="line">dashboard<span class="literal">-admin-token-xbqhh</span>        kubernetes.io/service<span class="literal">-account-token</span>   <span class="number">3</span>      <span class="number">2</span>m35s</span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe secrets dashboard-admin-token-xbqhh -n kubernetes-dashboard</span></span><br><span class="line">Name:         dashboard<span class="literal">-admin-token-xbqhh</span></span><br><span class="line">Namespace:    kubernetes<span class="literal">-dashboard</span></span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service<span class="literal">-account</span>.name: dashboard<span class="literal">-admin</span></span><br><span class="line">              kubernetes.io/service<span class="literal">-account</span>.uid: <span class="number">95</span>d84d80<span class="literal">-be7a-4d10-a2e0-68f90222d039</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Type</span>:  kubernetes.io/service<span class="literal">-account-token</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Data</span></span><br><span class="line">====</span><br><span class="line">namespace:  <span class="number">20</span> bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6ImJrYkF4bW5XcDhWcmNGUGJtek5NODFuSXl1aWptMmU2M3o4LTY5a2FKS2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4teGJxaGgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiOTVkODRkODAtYmU3YS00ZDEwLWEyZTAtNjhmOTAyMjJkMDM5Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.NAl7e8ZfWWdDoPxkqzJzTB46sK9E8iuJYnUI9vnBaY3Jts7T1g1msjsBnbxzQSYgAG<span class="literal">--cV0WYxjndzJY_UWCwaGPrQrt_GunxmOK9AUnzURqm55GR2RXIZtjsWVP2EBatsDgHRmuUbQvTFOvdJB4x3nXcYLN2opAaMqg3rnU2rr-A8zCrIuX_eca12wIp_QiuP3SF-tzpdLpsyRfegTJZl6YnSGyaVkC9id-cxZRb307qdCfXPfCHR_2rt5FVfxARgg_C0e3eFHaaYQO7CitxsnIoIXpOFNAR8aUrmopJyODQIPqBWUehb7FhlU1DCduHnIIXVC_UICZ-MKYewBDLw</span></span><br><span class="line">ca.crt:     <span class="number">1025</span> bytes</span><br></pre></td></tr></table></figure>

<p>3）通过浏览器访问Dashboard的UI</p>
<p>在登录页面上输入上面的token</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200520144548997.png" alt="image-20200520144548997"></p>
<p>出现下面的页面代表成功</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200520144959353.png" alt="image-20200520144959353" style="border:1px solid;" />

<h2 id="使用DashBoard"><a href="#使用DashBoard" class="headerlink" title="使用DashBoard"></a>使用DashBoard</h2><p>本章节以Deployment为例演示DashBoard的使用</p>
<p><strong>查看</strong></p>
<p>选择指定的命名空间<code>dev</code>，然后点击<code>Deployments</code>，查看dev空间下的所有deployment</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200520154628679.png" style="border:1px solid;" />

<p><strong>扩缩容</strong></p>
<p>在<code>Deployment</code>上点击<code>规模</code>，然后指定<code>目标副本数量</code>，点击确定</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200520162605102.png" style="border:1px solid;" />

<p><strong>编辑</strong></p>
<p>在<code>Deployment</code>上点击<code>编辑</code>，然后修改<code>yaml文件</code>，点击确定</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200520163253644.png" alt="image-20200520163253644" style="border:1px solid;" />

<p><strong>查看Pod</strong></p>
<p>点击<code>Pods</code>, 查看pods列表</p>
<img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200520163552110.png" style="border:1px solid;" />

<p><strong>操作Pod</strong></p>
<p>选中某个Pod，可以对其执行日志（logs）、进入执行（exec）、编辑、删除操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/Ghostpanter/tuchuang/img/image-20200520163832827.png" alt="image-20200520163832827"></p>
<blockquote>
<p>Dashboard提供了kubectl的绝大部分功能，这里不再一一演示</p>
</blockquote>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>（Docker）Alpine apk设置国内源</title>
    <url>/2022/12/29/%EF%BC%88Docker%EF%BC%89Alpine%20apk%E8%AE%BE%E7%BD%AE%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<h2 id="运行容器xxx，示例"><a href="#运行容器xxx，示例" class="headerlink" title="运行容器xxx，示例:"></a>运行容器xxx，示例:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d  \</span><br><span class="line">--name jk -u root \</span><br><span class="line">-p 9090:8080  \</span><br><span class="line">-v /var/jenkins_home:/var/jenkins_home  \</span><br><span class="line">jenkinsci/blueocean</span><br></pre></td></tr></table></figure>

<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it jk bash <span class="comment">#这里的“jk”是指你创建的镜像容器</span></span><br></pre></td></tr></table></figure>

<p>修改源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apk/repositories</span><br></pre></td></tr></table></figure>

<p>更新设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apk update</span><br></pre></td></tr></table></figure>

<p>然后你就可以愉快的使用apk了：apk add maven</p>
<p>附录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#apk命令</span></span><br><span class="line"></span><br><span class="line">apk update <span class="comment">#更新最新本地镜像源</span></span><br><span class="line">apk upgrade <span class="comment">#升级软件</span></span><br><span class="line">apk add --upgrade busybox <span class="comment">#指定升级部分软件包</span></span><br><span class="line">apk search <span class="comment">#查找所以可用软件包</span></span><br><span class="line">apk search -v <span class="comment">#查找所有可用软件包及其描述内容</span></span><br><span class="line">apk search -v <span class="string">&#x27;acf*&#x27;</span> <span class="comment">#通过软件包名称查找软件包</span></span><br><span class="line">apk search -v -d <span class="string">&#x27;docker&#x27;</span> <span class="comment">#通过描述文件查找特定的软件包</span></span><br><span class="line">apk info <span class="comment">#列出所有已安装的软件包</span></span><br><span class="line">apk info -a zlib <span class="comment">#显示完整的软件包信息</span></span><br><span class="line">apk info --who-owns /sbin/lbu <span class="comment">#显示指定文件属于的包</span></span><br><span class="line">apk add --allow-untrusted /path/to/file.apk  <span class="comment">#本地安装</span></span><br></pre></td></tr></table></figure>

<p>添加镜像地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a. 编辑/etc/apk/repositories，在文件内添加对应的镜像源</span><br><span class="line">b. 使用sed命令，如：sed -i <span class="string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apk/repositories</span><br></pre></td></tr></table></figure>

<p>常用apk镜像站<br>清华TUNA镜像源：<code>https://mirror.tuna.tsinghua.edu.cn/alpine/</code><br>中科大镜像源：<code>http://mirrors.ustc.edu.cn/alpine/</code><br>阿里云镜像源：<code>http://mirrors.aliyun.com/alpine/</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://dl-cdn.alpinelinux.org/alpine/</span><br><span class="line">http://nl.alpinelinux.org/alpine/</span><br><span class="line">http://uk.alpinelinux.org/alpine/</span><br><span class="line">http://dl-2.alpinelinux.org/alpine/</span><br><span class="line">http://dl-3.alpinelinux.org/alpine/</span><br><span class="line">http://dl-4.alpinelinux.org/alpine/</span><br><span class="line">http://dl-5.alpinelinux.org/alpine/</span><br><span class="line">http://dl-8.alpinelinux.org/alpine/</span><br><span class="line">http://mirror.yandex.ru/mirrors/alpine/</span><br><span class="line">http://mirrors.gigenet.com/alpinelinux/</span><br><span class="line">http://mirror1.hs-esslingen.de/pub/Mirrors/alpine/</span><br><span class="line">http://mirror.leaseweb.com/alpine/</span><br><span class="line">http://repository.fit.cvut.cz/mirrors/alpine/</span><br><span class="line">http://alpine.mirror.far.fi/</span><br><span class="line">http://alpine.mirror.wearetriple.com/</span><br><span class="line">http://mirror.clarkson.edu/alpine/</span><br><span class="line">http://linorg.usp.br/AlpineLinux/</span><br><span class="line">http://ftp.yzu.edu.tw/Linux/alpine/</span><br><span class="line">http://mirror.aarnet.edu.au/pub/alpine</span><br><span class="line">http://mirror.csclub.uwaterloo.ca/alpine</span><br><span class="line">http://ftp.acc.umu.se/mirror/alpinelinux.org</span><br><span class="line">http://ftp.halifax.rwth-aachen.de/alpine</span><br><span class="line">http://speglar.siminn.is/alpine</span><br><span class="line">http://mirrors.dotsrc.org/alpine</span><br><span class="line">http://ftp.tsukuba.wide.ad.jp/Linux/alpine</span><br><span class="line">http://mirror.rise.ph/alpine</span><br><span class="line">http://mirror.neostrada.nl/alpine/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
